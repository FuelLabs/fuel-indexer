# https://github.com/FuelLabs/fuel-indexer/issues/897

type TransactionPointer {
  id: ID!
  block_height: BlockHeight!
  tx_index: UInt4!
}

type TransactionIdFragment {
  id: ID!
}

type UtxoId {
  id: ID!
  tx_id: TxId!
  output_index: UInt4!
}


type TxPointer {
  id: ID!
  block_height: BlockHeight!
  tx_index: UInt4!
}

type ContractIdFragment {
  id: ID!
}

type BlockIdFragment {
  id: ID!
}

# TODO: Should this be a FK?
type Genesis {
  id: ID!
  chain_config_hash: Bytes32!
  coins_root: Bytes32!
  contracts_root: Bytes32!
  messages_root: Bytes32!
}

# TODO: Should this be a FK?
type PoA {
  signature: Signature! @norelation
}

# TODO: Should this be a FK?
type Unknown {
  value: Boolean! @norelation
}

# TODO: Should this be a FK?
type Consensus {
  id: ID!
  genesis: Genesis
  poa: PoA
  unknown: Unknown
  label: Charfield!
}

type Witness {
  data: Blob! @norelation
}

type InputCoin {
  id: ID!
  utxo_id: UtxoId!
  owner: Address!
  amount: UInt8!
  asset_id: AssetId!
  tx_pointer: TransactionPointer!
  witness_index: Int8!
  maturity: UInt8!
  predicate: HexString!
  predicate_data: HexString!
}

type InputContract {
  id: ID!
  utxo_id: UtxoId!
  balance_root: Bytes32!
  state_root: Bytes32!
  tx_pointer: TransactionPointer!
  contract: ContractIdFragment!
}

type InputMessage {
  id: ID!
  sender: Address!
  recipient: Address!
  amount: UInt8!
  nonce: UInt8!
  witness_index: Int8!
  data: HexString!
  predicate: HexString!
  predicate_data: HexString!
}

type Input {
  id: ID!
  coin: InputCoin
  contract: InputContract
  message: InputMessage
}

type CreateTransaction {
  id: ID!
  gas_price: UInt8!
  gas_limit: UInt8!
  maturity: BlockHeight!
  bytecode_length: UInt8!
  bytecode_witness_index: UInt4!
  #   storage_slots: [StorageSlot]!
  #   inputs: [Input]!
  #   outputs: [Output]!
  #   witnesses: [Witness]!
  salt: Salt!
  metadata: Json
}

type ScriptTransaction {
  id: ID!
  gas_price: UInt8!
  gas_limit: UInt8!
  maturity: BlockHeight!
  script: Blob!
  #   inputs: [Input]!
  #   outputs: [Output]!
  #   witnesses: [Witness]!
  receipts_root: Bytes32!
  metadata: Json
}

type MintTransaction {
  id: ID!
  tx_pointer: TransactionPointer!
  #   outputs: [Output]!
  metadata: Json
}

type SubmittedStatus {
  id: ID!
  time: UInt8!
}

type SqueezedOutStatus {
  id: ID!
  reason: Charfield!
}

enum ReturnType {
  RETURN
  RETURNDATA
  REVERT
}

type TransactionReturnType {
  id: ID!
  return_type: ReturnType!
}

# TODO: Should this be a FK?
type ProgramState {
  id: ID!
  return_type: TransactionReturnType!
  data: HexString!
}

type FailureStatus {
  id: ID!
  block: BlockIdFragment!
  time: UInt8!
  reason: Charfield!
  program_state: ProgramState
}

type SuccessStatus {
  id: ID!
  time: UInt8!
  block: BlockIdFragment!
  program_state: ProgramState
}

type UnknownStatus {
  id: ID!
  label: Charfield!
}

type TransactionStatus {
  id: ID!
  submitted_status: SubmittedStatus
  squeezed_out_status: SqueezedOutStatus
  failure_status: FailureStatus
  success_status: SuccessStatus
  unknown_status: UnknownStatus
}

type Transaction {
  id: ID!
  creates: CreateTransaction
  scripts: ScriptTransaction
  mints: MintTransaction
}

type Header {
  id: ID!
  block_id: BlockId!
  da_height: UInt8!
  transactions_count: UInt8!
  message_receipt_count: UInt8!
  transactions_root: Bytes32!
  message_receipt_root: Bytes32!
  height: UInt8!
  prev_root: Bytes32!
  time: Int8!
  application_hash: Bytes32!
}

type Block {
  id: ID!
  block_id: BlockId!
  header: Header!
  consensus: Consensus!
  #   transactions: [TransactionIdFragment]!
}

type NodeInfo {
  id: ID!
  utxo_validation: Boolean!
  vm_backtrace: Boolean!
  min_gas_price: UInt8!
  max_tx: UInt8!
  max_depth: UInt8!
  node_version: Charfield!
}

type ContractCreated {
  id: ID!
  contract: ContractIdFragment!
  state_root: Bytes32!
}

type VariableOutput {
  id: ID!
  recipient: Address!
  amount: UInt8!
  asset_id: AssetId!
}

type ChangeOutput {
  id: ID!
  recipient: Address!
  amount: UInt8!
  asset_id: AssetId!
}

type ContractOutput {
  id: ID!
  input_index: Int8!
  balance_root: Bytes32!
  state_root: Bytes32!
}

type CoinOutput {
  id: ID!
  recipient: Address!
  amount: UInt8!
  asset_id: AssetId!
}

type Output {
  id: ID!
  coin: CoinOutput
  contract: ContractOutput
  change: ChangeOutput
  variable: VariableOutput
  contract_created: ContractCreated
  unknown: Unknown
}

type DryRun {
  tx: HexString! @norelation
  utxo_validation: Boolean
}

type Balance {
  id: ID!
  owner: Address!
  amount: UInt8!
  asset_id: AssetId!
}

type ConsensusParameters {
  id: ID!
  contract_max_size: UInt8!
  max_inputs: UInt8!
  max_outputs: UInt8!
  max_witnesses: UInt8!
  max_gas_per_tx: UInt8!
  max_script_length: UInt8!
  max_script_data_length: UInt8!
  max_storage_slots: UInt8!
  max_predicate_length: UInt8!
  gas_price_factor: UInt8!
  gas_per_byte: UInt8!
  max_message_data_length: UInt8!
  chain_id: UInt8!
}

type ChainInfo {
  id: ID!
  base_chain_height: UInt4!
  name: Charfield!
  peer_count: Int4!
  latest_block: Block!
  consensus_parameters: ConsensusParameters!
}

type Coin {
  id: ID!
  amount: UInt8!
  block_created: UInt4!
  asset_id: AssetId!
  utxo_id: UtxoId!
  maturity: UInt4!
  owner: Address!
}

type MessageCoin {
  id: ID!
  amount: UInt8!
  sender: Address!
  recipient: Address!
  nonce: Nonce!
  da_height: UInt8!
}

type ContractBalance {
  id: ID!
  contract_id: ContractId!
  amount: UInt8!
  asset_id: AssetId!
}

type Contract {
  id: ID!
  contract_id: ContractId!
  bytecode: HexString!
  salt: Salt!
}

type Message {
  id: ID!
  amount: UInt8!
  sender: Address!
  recipient: Address!
  nonce: Nonce!
  data: HexString!
  da_height: UInt8!
}

type MerkleProof {
  id: ID!
  # proof_set: [Bytes32]!
  proof_index: UInt8!
}

type MessageProof {
  id: ID!
  message_proof: MerkleProof!
  block_proof: MerkleProof!
  message_block_header: Header!
  commit_block_header: Header!
  sender: Address!
  recipient: Address!
  nonce: Nonce!
  amount: UInt8!
  data: HexString!
}

type CallReceipt {
  id: ID!
  some_id: ContractId!
  recipient: ContractId!
  amount: UInt8!
  asset_id: AssetId!
  gas: UInt8!
  param1: UInt8!
  param2: UInt8!
  pc_register: UInt8!
  is_register: UInt8!
}

type ReturnDataReceipt {
  id: ID!
  some_id: ContractId!
  ptr: UInt8!
  len: UInt8!
  digest: Bytes32!
  data: Blob!
  pc_register: UInt8!
  is_register: UInt8!
}

enum PanicReason {
  Success
  Revert
  OutOfGas
  TransactionValidity
  MemoryOverflow
  ArithmeticOverflow
  ContractNotFound
  MemoryOwnership
  NotEnoughBalance
  ExpectedInternalContext
  AssetIdNotFound
  InputNotFound
  OutputNotFound
  WitnessNotFound
  TransactionMaturity
  InvalidMetadataIdentifier
  MalformedCallStructure
  ReservedRegisterNotWritable
  ErrorFlag
  InvalidImmediateValue
  ExpectedCoinInput
  MaxMemoryAccess
  MemoryWriteOverlap
  ContractNotInInputs
  InternalBalanceOverflow
  ContractMaxSize
  ExpectedUnallocatedStack
  MaxStaticContractsReached
  TransferAmountCannotBeZero
  ExpectedOutputVariable
  ExpectedParentInternalContext
  IllegalJump
  ContractIdAlreadyDeployed
  ContractMismatch
  MessageDataTooLong
  ArithmeticError
  UnknownPanicReason
}

type InstructionResult {
  id: ID!
  reason: PanicReason!
  #   instruction: RawInstruction!
  instruction: UInt4!
}

type PanicReceipt {
  id: ID!
  some_id: ContractId!
  reason: InstructionResult
  pc_register: UInt8!
  is_register: UInt8!
  contract_id: ContractId
}

type RevertReceipt {
  id: ID!
  some_id: ContractId!
  ra: UInt8!
  pc_register: UInt8!
  is_register: UInt8!
}

type LogReceipt {
  id: ID!
  some_id: ContractId!
  ra: UInt8!
  rb: UInt8!
  rc: UInt8!
  rd: UInt8!
  pc_register: UInt8!
  is_register: UInt8!
}

type LogDataReceipt {
  id: ID!
  some_id: ContractId!
  ra: UInt8!
  rb: UInt8!
  ptr: UInt8!
  len: UInt8!
  digest: Bytes32!
  data: Blob!
  pc_register: UInt8!
  is_register: UInt8!
}

# TODO: Finish this?
# type Receipt {
#   id: ID!
#   call: CallReceipt
#   return: ReturnReceipt
#   return_data: ReturnDataReceipt
#   panic: PanicReceipt
#   revert: RevertReceipt
#   log: LogReceipt
#   log_data: LogDataReceipt
#   transfer: TransferReceipt
#   transfer_out: TransferOutReceipt
#   script_result: ScriptResultReceipt
#   message_out: MessageOutReceipt
# }
