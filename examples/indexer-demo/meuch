#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
extern crate alloc;
use fuel_indexer_derive::{graphql_schema, handler};
use fuels_abigen_macro::wasm_abigen;
use alloc::{format, vec, vec::Vec};
use fuel_indexer::{Entity, Logger};
use fuel_indexer::types::*;
const NAMESPACE: &'static str = "demo_namespace";
#[no_mangle]
fn get_namespace_ptr() -> *const u8 {
    NAMESPACE.as_ptr()
}
#[no_mangle]
fn get_namespace_len() -> u32 {
    NAMESPACE.len() as u32
}
const VERSION: &'static str = "9f747e715dddfd4b9f42162778fb0b3f390473a84b4ef977a952d4f767b55cf7";
#[no_mangle]
fn get_version_ptr() -> *const u8 {
    VERSION.as_ptr()
}
#[no_mangle]
fn get_version_len() -> u32 {
    VERSION.len() as u32
}
pub struct Thing1 {
    id: ID,
    account: Address,
    count: UInt8,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Thing1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            Thing1 {
                id: ref __self_0_0,
                account: ref __self_0_1,
                count: ref __self_0_2,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Thing1");
                let _ = ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "account",
                    &&(*__self_0_1),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "count", &&(*__self_0_2));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for Thing1 {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Thing1 {
    #[inline]
    fn eq(&self, other: &Thing1) -> bool {
        match *other {
            Thing1 {
                id: ref __self_1_0,
                account: ref __self_1_1,
                count: ref __self_1_2,
            } => match *self {
                Thing1 {
                    id: ref __self_0_0,
                    account: ref __self_0_1,
                    count: ref __self_0_2,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &Thing1) -> bool {
        match *other {
            Thing1 {
                id: ref __self_1_0,
                account: ref __self_1_1,
                count: ref __self_1_2,
            } => match *self {
                Thing1 {
                    id: ref __self_0_0,
                    account: ref __self_0_1,
                    count: ref __self_0_2,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                }
            },
        }
    }
}
impl ::core::marker::StructuralEq for Thing1 {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for Thing1 {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<ID>;
            let _: ::core::cmp::AssertParamIsEq<Address>;
            let _: ::core::cmp::AssertParamIsEq<UInt8>;
        }
    }
}
impl Entity for Thing1 {
    const TYPE_ID: u64 = 12605612246036801531u64;
    fn from_row(mut vec: Vec<FtColumn>) -> Self {
        let item = vec.pop().expect("Missing item in row");
        let count = match item {
            FtColumn::UInt8(t) => t,
            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid column type "],
                &[::core::fmt::ArgumentV1::new_debug(&item)],
            )),
        };
        let item = vec.pop().expect("Missing item in row");
        let account = match item {
            FtColumn::Address(t) => t,
            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid column type "],
                &[::core::fmt::ArgumentV1::new_debug(&item)],
            )),
        };
        let item = vec.pop().expect("Missing item in row");
        let id = match item {
            FtColumn::ID(t) => t,
            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid column type "],
                &[::core::fmt::ArgumentV1::new_debug(&item)],
            )),
        };
        Self { id, account, count }
    }
    fn to_row(&self) -> Vec<FtColumn> {
        <[_]>::into_vec(box [
            FtColumn::ID(self.id),
            FtColumn::Address(self.account),
            FtColumn::UInt8(self.count),
        ])
    }
}
pub struct Thing2 {
    id: ID,
    hash: Bytes32,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Thing2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            Thing2 {
                id: ref __self_0_0,
                hash: ref __self_0_1,
            } => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Thing2");
                let _ = ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "hash", &&(*__self_0_1));
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for Thing2 {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Thing2 {
    #[inline]
    fn eq(&self, other: &Thing2) -> bool {
        match *other {
            Thing2 {
                id: ref __self_1_0,
                hash: ref __self_1_1,
            } => match *self {
                Thing2 {
                    id: ref __self_0_0,
                    hash: ref __self_0_1,
                } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &Thing2) -> bool {
        match *other {
            Thing2 {
                id: ref __self_1_0,
                hash: ref __self_1_1,
            } => match *self {
                Thing2 {
                    id: ref __self_0_0,
                    hash: ref __self_0_1,
                } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
            },
        }
    }
}
impl ::core::marker::StructuralEq for Thing2 {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for Thing2 {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<ID>;
            let _: ::core::cmp::AssertParamIsEq<Bytes32>;
        }
    }
}
impl Entity for Thing2 {
    const TYPE_ID: u64 = 18288246218248631107u64;
    fn from_row(mut vec: Vec<FtColumn>) -> Self {
        let item = vec.pop().expect("Missing item in row");
        let hash = match item {
            FtColumn::Bytes32(t) => t,
            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid column type "],
                &[::core::fmt::ArgumentV1::new_debug(&item)],
            )),
        };
        let item = vec.pop().expect("Missing item in row");
        let id = match item {
            FtColumn::ID(t) => t,
            _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["Invalid column type "],
                &[::core::fmt::ArgumentV1::new_debug(&item)],
            )),
        };
        Self { id, hash }
    }
    fn to_row(&self) -> Vec<FtColumn> {
        <[_]>::into_vec(box [FtColumn::ID(self.id), FtColumn::Bytes32(self.hash)])
    }
}
pub use no_name_mod::*;
#[allow(clippy::too_many_arguments)]
mod no_name_mod {
    #![allow(clippy::enum_variant_names)]
    #![allow(dead_code)]
    #![allow(unused_imports)]
    use alloc::{vec, vec::Vec};
    use fuels::core::{Detokenize, EnumSelector, ParamType, Tokenizable, Token};
    pub struct LogEvent {
        pub contract: [u8; 32],
        pub rega: u64,
        pub regb: u64,
        pub regc: u64,
        pub regd: u64,
        pub pc: u64,
        pub is: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for LogEvent {
        #[inline]
        fn clone(&self) -> LogEvent {
            match *self {
                LogEvent {
                    contract: ref __self_0_0,
                    rega: ref __self_0_1,
                    regb: ref __self_0_2,
                    regc: ref __self_0_3,
                    regd: ref __self_0_4,
                    pc: ref __self_0_5,
                    is: ref __self_0_6,
                } => LogEvent {
                    contract: ::core::clone::Clone::clone(&(*__self_0_0)),
                    rega: ::core::clone::Clone::clone(&(*__self_0_1)),
                    regb: ::core::clone::Clone::clone(&(*__self_0_2)),
                    regc: ::core::clone::Clone::clone(&(*__self_0_3)),
                    regd: ::core::clone::Clone::clone(&(*__self_0_4)),
                    pc: ::core::clone::Clone::clone(&(*__self_0_5)),
                    is: ::core::clone::Clone::clone(&(*__self_0_6)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for LogEvent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                LogEvent {
                    contract: ref __self_0_0,
                    rega: ref __self_0_1,
                    regb: ref __self_0_2,
                    regc: ref __self_0_3,
                    regd: ref __self_0_4,
                    pc: ref __self_0_5,
                    is: ref __self_0_6,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "LogEvent");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "contract",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "rega",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "regb",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "regc",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "regd",
                        &&(*__self_0_4),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "pc", &&(*__self_0_5));
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "is", &&(*__self_0_6));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for LogEvent {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for LogEvent {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<[u8; 32]>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for LogEvent {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for LogEvent {
        #[inline]
        fn eq(&self, other: &LogEvent) -> bool {
            match *other {
                LogEvent {
                    contract: ref __self_1_0,
                    rega: ref __self_1_1,
                    regb: ref __self_1_2,
                    regc: ref __self_1_3,
                    regd: ref __self_1_4,
                    pc: ref __self_1_5,
                    is: ref __self_1_6,
                } => match *self {
                    LogEvent {
                        contract: ref __self_0_0,
                        rega: ref __self_0_1,
                        regb: ref __self_0_2,
                        regc: ref __self_0_3,
                        regd: ref __self_0_4,
                        pc: ref __self_0_5,
                        is: ref __self_0_6,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LogEvent) -> bool {
            match *other {
                LogEvent {
                    contract: ref __self_1_0,
                    rega: ref __self_1_1,
                    regb: ref __self_1_2,
                    regc: ref __self_1_3,
                    regd: ref __self_1_4,
                    pc: ref __self_1_5,
                    is: ref __self_1_6,
                } => match *self {
                    LogEvent {
                        contract: ref __self_0_0,
                        rega: ref __self_0_1,
                        regb: ref __self_0_2,
                        regc: ref __self_0_3,
                        regd: ref __self_0_4,
                        pc: ref __self_0_5,
                        is: ref __self_0_6,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                    }
                },
            }
        }
    }
    impl LogEvent {
        pub fn param_types() -> Vec<ParamType> {
            let mut types = Vec::new();
            types.push(ParamType::B256);
            types.push(ParamType::U64);
            types.push(ParamType::U64);
            types.push(ParamType::U64);
            types.push(ParamType::U64);
            types.push(ParamType::U64);
            types.push(ParamType::U64);
            types
        }
        pub fn into_token(self) -> Token {
            let mut tokens = Vec::new();
            tokens.push(Token::B256(self.contract));
            tokens.push(Token::U64(self.rega));
            tokens.push(Token::U64(self.regb));
            tokens.push(Token::U64(self.regc));
            tokens.push(Token::U64(self.regd));
            tokens.push(Token::U64(self.pc));
            tokens.push(Token::U64(self.is));
            Token::Struct(tokens)
        }
        pub fn new_from_tokens(tokens: &[Token]) -> Self {
            Self { contract : < [u8 ; 32] > :: from_token (tokens [0usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , rega : < u64 > :: from_token (tokens [1usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , regb : < u64 > :: from_token (tokens [2usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , regc : < u64 > :: from_token (tokens [3usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , regd : < u64 > :: from_token (tokens [4usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , pc : < u64 > :: from_token (tokens [5usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , is : < u64 > :: from_token (tokens [6usize] . clone ()) . expect ("Failed to run `new_from_tokens()` for custom LogEvent struct (tokens have wrong order and/or wrong types)") , }
        }
    }
    impl Detokenize for LogEvent {
        fn from_tokens(mut tokens: Vec<Token>) -> Result<Self, InvalidOutputType> {
            let token = match tokens.len() {
                0 => Token::Struct(::alloc::vec::Vec::new()),
                1 => tokens.remove(0),
                _ => Token::Struct(tokens),
            };
            if let Token::Struct(tokens) = token.clone() {
                Ok(LogEvent::new_from_tokens(&tokens))
            } else {
                Err(InvalidOutputType(
                    "Struct token doesn't contain inner tokens. This shouldn't happen.".to_string(),
                ))
            }
        }
    }
}
#[no_mangle]
fn function_one(blobs: *mut *mut u8, lens: *mut usize, len: usize) {
    use fuel_indexer::types::*;
    use fuels::core::abi_decoder::ABIDecoder;
    let mut decoder = ABIDecoder::new();
    let (blobs, lens) = unsafe {
        (
            Vec::from_raw_parts(blobs, len, len),
            Vec::from_raw_parts(lens, len, len),
        )
    };
    let tokens = unsafe { Vec::from_raw_parts(blobs[0usize], lens[0usize], lens[0usize]) };
    let event = decoder
        .decode(&LogEvent::param_types(), &tokens)
        .expect("Failed decoding");
    core::mem::forget(tokens);
    let event = LogEvent::new_from_tokens(&event);
    core::mem::forget(blobs);
    core::mem::forget(lens);
    Logger::info("Callin' the event handler");
    let LogEvent {
        contract,
        rega,
        regb,
        ..
    } = event;
    let mut t1 = match Thing1::load(rega) {
        Some(t) => t,
        None => Thing1 {
            id: rega,
            account: Address::from(contract),
            count: 0,
        },
    };
    t1.count += regb;
    t1.save();
}
