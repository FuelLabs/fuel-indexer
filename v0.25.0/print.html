<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fuel Indexer Service</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">The Fuel Indexer</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="getting-started/dependencies.html"><strong aria-hidden="true">1.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="getting-started/indexer-service-infrastructure.html"><strong aria-hidden="true">2.</strong> Service Infrastructure</a></li><li class="chapter-item expanded "><a href="getting-started/how-it-compares.html"><strong aria-hidden="true">3.</strong> How it Compares</a></li><li class="chapter-item expanded "><a href="getting-started/quickstart.html"><strong aria-hidden="true">4.</strong> Quickstart</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="project-components/index.html"><strong aria-hidden="true">5.</strong> Project Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project-components/manifest.html"><strong aria-hidden="true">5.1.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="project-components/schema.html"><strong aria-hidden="true">5.2.</strong> Schema</a></li><li class="chapter-item expanded "><a href="project-components/module.html"><strong aria-hidden="true">5.3.</strong> Module</a></li></ol></li><li class="chapter-item expanded "><a href="designing-a-schema/index.html"><strong aria-hidden="true">6.</strong> Designing a Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="designing-a-schema/types.html"><strong aria-hidden="true">6.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="designing-a-schema/scalars.html"><strong aria-hidden="true">6.2.</strong> Scalars</a></li><li class="chapter-item expanded "><a href="designing-a-schema/directives.html"><strong aria-hidden="true">6.3.</strong> Directives</a></li><li class="chapter-item expanded "><a href="designing-a-schema/relationships.html"><strong aria-hidden="true">6.4.</strong> Relationships</a></li></ol></li><li class="chapter-item expanded "><a href="indexing-fuel-types/index.html"><strong aria-hidden="true">7.</strong> Indexing Fuel Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="indexing-fuel-types/blocks.html"><strong aria-hidden="true">7.1.</strong> Blocks</a></li><li class="chapter-item expanded "><a href="indexing-fuel-types/transactions.html"><strong aria-hidden="true">7.2.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="indexing-fuel-types/receipts.html"><strong aria-hidden="true">7.3.</strong> Receipts</a></li></ol></li><li class="chapter-item expanded "><a href="indexing-custom-types/index.html"><strong aria-hidden="true">8.</strong> Indexing Custom Types</a></li><li class="chapter-item expanded "><a href="storing-records/index.html"><strong aria-hidden="true">9.</strong> Storing Records</a></li><li class="chapter-item expanded "><a href="querying/index.html"><strong aria-hidden="true">10.</strong> Querying</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="querying/basic-queries.html"><strong aria-hidden="true">10.1.</strong> Basic Queries</a></li><li class="chapter-item expanded "><a href="querying/playground.html"><strong aria-hidden="true">10.2.</strong> Playground</a></li><li class="chapter-item expanded "><a href="querying/search-and-filtering.html"><strong aria-hidden="true">10.3.</strong> Search and Filtering</a></li><li class="chapter-item expanded "><a href="querying/pagination.html"><strong aria-hidden="true">10.4.</strong> Pagination</a></li><li class="chapter-item expanded "><a href="querying/full-example.html"><strong aria-hidden="true">10.5.</strong> A Full Example</a></li></ol></li><li class="chapter-item expanded "><a href="authentication/index.html"><strong aria-hidden="true">11.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="forc-index/index.html"><strong aria-hidden="true">12.</strong> forc index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc-index/auth.html"><strong aria-hidden="true">12.1.</strong> auth</a></li><li class="chapter-item expanded "><a href="forc-index/build.html"><strong aria-hidden="true">12.2.</strong> build</a></li><li class="chapter-item expanded "><a href="forc-index/check.html"><strong aria-hidden="true">12.3.</strong> check</a></li><li class="chapter-item expanded "><a href="forc-index/deploy.html"><strong aria-hidden="true">12.4.</strong> deploy</a></li><li class="chapter-item expanded "><a href="forc-index/kill.html"><strong aria-hidden="true">12.5.</strong> kill</a></li><li class="chapter-item expanded "><a href="forc-index/new.html"><strong aria-hidden="true">12.6.</strong> new</a></li><li class="chapter-item expanded "><a href="forc-index/remove.html"><strong aria-hidden="true">12.7.</strong> remove</a></li><li class="chapter-item expanded "><a href="forc-index/start.html"><strong aria-hidden="true">12.8.</strong> start</a></li><li class="chapter-item expanded "><a href="forc-index/status.html"><strong aria-hidden="true">12.9.</strong> status</a></li></ol></li><li class="chapter-item expanded "><a href="forc-postgres/index.html"><strong aria-hidden="true">13.</strong> forc postgres</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forc-postgres/create.html"><strong aria-hidden="true">13.1.</strong> create</a></li><li class="chapter-item expanded "><a href="forc-postgres/drop.html"><strong aria-hidden="true">13.2.</strong> drop</a></li><li class="chapter-item expanded "><a href="forc-postgres/start.html"><strong aria-hidden="true">13.3.</strong> start</a></li><li class="chapter-item expanded "><a href="forc-postgres/stop.html"><strong aria-hidden="true">13.4.</strong> stop</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">For Contributors</li><li class="chapter-item expanded "><a href="for-contributors/index.html"><strong aria-hidden="true">14.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="for-contributors/contributing-standards.html"><strong aria-hidden="true">15.</strong> Contributing Standards</a></li><li class="chapter-item expanded "><a href="for-contributors/release-schedule.html"><strong aria-hidden="true">16.</strong> Release Schedule</a></li><li class="chapter-item expanded "><a href="for-contributors/building-from-source.html"><strong aria-hidden="true">17.</strong> Building From Source</a></li><li class="chapter-item expanded "><a href="for-contributors/system-dependencies.html"><strong aria-hidden="true">18.</strong> System Dependencies</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">19.</strong> A: Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Fuel Indexer Service</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/fuel-indexer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- markdownlint-disable MD033 -->
<h1 id="-fuel-indexer"><a class="header" href="#-fuel-indexer">üóÉ Fuel Indexer</a></h1>
<p>The Fuel indexer is a standalone service that can be used to index various components of the blockchain. These indexable components include blocks, transactions, receipts, and state within the Fuel network, allowing for high-performance read-only access to the blockchain for advanced dApp use-cases.</p>
<p>By using a combination of Fuel-flavored GraphQL schema, a SQL backend, and indexers written in Rust, users of the Fuel indexer can get started creating production-ready backends for their dApps, meant to go fast üöóüí®.</p>
<p>For those wanting to build dApp backends right away, feel free to check out the <a href="./getting-started/quickstart.html">Quickstart</a>. And for those willing to contribute to the Fuel indexer project, please feel free to read <a href="https://github.com/FuelLabs/fuel-indexer/blob/develop/docs/CONTRIBUTING.md">our contributor guidelines</a> as well as the <a href="for-contributors/index.html">For Contributors</a> chapter of the book.</p>
<!-- KEEP THIS IN CASE WE WANT TO MAKE DIAGRAM CHANGES [![fo](https://mermaid.ink/img/pako:eNp9kWFrwjAQhv_KcZ8U9A-UIajZhrDBZkUYjR9uzamFNqlpAhbrf1-6TFCY5r6EN-9zb7g7YW4UY4I7S_UeVkJqCGeavXguYW4sb2A8nnTrd0gdOe5gNvh9WmjFR7bD6J9l12JEXvuOn2-wamtuOhADQY6-qeE_Zn7DwMU-_VhEPi12msrmTuIjGp56fskHz437L1pkF2EThefsy3h7-_-tsTkUvQKK69K03aNQqa8LR1ixrahQYbSnPkOi23PFEpNwVbwlXzqJUp-DlbwzaatzTJz1PEJfqzBqUVBYShXF8w9dz4xz?type=png)](https://mermaid.live/edit#pako:eNp9kWFrwjAQhv_KcZ8U9A-UIajZhrDBZkUYjR9uzamFNqlpAhbrf1-6TFCY5r6EN-9zb7g7YW4UY4I7S_UeVkJqCGeavXguYW4sb2A8nnTrd0gdOe5gNvh9WmjFR7bD6J9l12JEXvuOn2-wamtuOhADQY6-qeE_Zn7DwMU-_VhEPi12msrmTuIjGp56fskHz437L1pkF2EThefsy3h7-_-tsTkUvQKK69K03aNQqa8LR1ixrahQYbSnPkOi23PFEpNwVbwlXzqJUp-DlbwzaatzTJz1PEJfqzBqUVBYShXF8w9dz4xz) -->
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<!-- Using an <img> so we can size it -->
<img src="https://i.imgur.com/8K14p9h.png" alt="diagram" width="500"/>
<p>The Fuel indexer is meant to run alongside a Fuel node and a database. Generally, the typical flow of information through the indexer is as follows:</p>
<ol>
<li>A Sway smart contract emits receipts during its execution on the Fuel node.</li>
<li>Blocks, transactions, and receipts from the node are monitored by the Fuel indexer service and checked for specific user-defined event types.</li>
<li>When a specific event type is found, an indexer executes the corresponding handler from its module.</li>
<li>The handler processes the event and stores the indexed information in the database.</li>
<li>A dApp queries for blockchain data by using the indexer's GraphQL API endpoint, which fetches the desired information from the corresponding index in the database and returns it to the user.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<blockquote>
<p>This guide covers some of the basics with regard to installing dependencies for the Fuel indexer service. However, note that this guide is meant to be a general overview for most platforms and by no means covers all platforms.</p>
<p>If you're having trouble with dependencies on your system, we recommend that you use <code>docker</code>.</p>
</blockquote>
<p>To run the Fuel indexer, you'll need to install a few dependencies on your system:</p>
<ol>
<li>The <a href="https://docs.fuel.network/guides/installation">Fuel toolchain</a></li>
<li>A <a href="getting-started/dependencies.html#postgresql">PostgreSQL</a> server backend</li>
<li>The <a href="getting-started/dependencies.html#web-assembly-wasm"><code>wasm32-unknown-unknown</code></a> <code>rustup</code> target</li>
<li><a href="getting-started/dependencies.html#web-assembly-wasm"><code>wasm-snip</code></a>, a utility for stripping symbols from WebAssembly binaries.</li>
</ol>
<blockquote>
<p>If you don't want to install a database directly onto your system, you can use Docker to run a database in an isolated container. You can install Docker by following its <a href="https://docs.docker.com/get-docker/">installation instructions</a>.</p>
<p>For reference purposes, we provide a <a href="https://github.com/FuelLabs/fuel-indexer/blob/develop/scripts/docker-compose.yaml"><code>docker compose</code> file</a> that comes with a PostgreSQL server and a Fuel indexer service.</p>
</blockquote>
<h2 id="the-fuel-toolchain"><a class="header" href="#the-fuel-toolchain">The <code>Fuel</code> toolchain</a></h2>
<p>Please visit the Fuel <a href="https://docs.fuel.network/guides/installation">installation guide</a> to install the Fuel toolchain,  which includes binaries for the Fuel indexer.</p>
<h2 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h2>
<p>The Fuel indexer requires the use of a database. We currently support <a href="https://www.postgresql.org/docs/">PostgreSQL</a>.</p>
<blockquote>
<p>IMPORTANT: Fuel Indexer users on most platforms don't need to explicitly install PostgreSQL software via a package manager. When starting the indexer service via <code>forc index start</code> simply pass the <code>--embedded-database</code> flag in order to have the indexer service download and start an embedded PostgreSQL instance via <a href="getting-started/../forc-postgres/index.html"><code>forc index postgres</code></a>.</p>
<p>However note that this <code>--embedded-database</code> functionality can be a bit brittle or flaky on some platforms, so alternative methods of installing or using PostgreSQL are briefly mentioned below.</p>
</blockquote>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>On macOS systems, you can install PostgreSQL through Homebrew. If it isn't present on your system, you can install it according to the <a href="https://brew.sh/">instructions</a>.</p>
<p>Once installed, you can add PostgreSQL to your system by running <code>brew install postgresql</code>.</p>
<h2 id="web-assembly-wasm"><a class="header" href="#web-assembly-wasm">Web Assembly (WASM)</a></h2>
<p>Two additional cargo components will be required to build your indexers: <code>wasm-snip</code> and the <code>wasm32-unknown-unknown</code> target.</p>
<blockquote>
<p>As of this writing, there is a small bug in newly built Fuel indexer WASM modules that produces a WASM runtime error due an errant upstream dependency. For now, you can use <code>wasm-snip</code> to remove the errant symbols from the WASM module, and prevent this issue from happening. An example can be found in the related script <a href="https://github.com/FuelLabs/fuel-indexer/blob/develop/scripts/stripper.bash">here</a>.</p>
<p>Note that since <code>wasm-snip</code> strips Web Assembly related symbols, users will temporarily not be allowed to include other WASM-friendly crates (e.g., <a href="https://docs.rs/chrono/latest/chrono/"><code>chrono</code></a>) in their indexers.</p>
</blockquote>
<h3 id="wasm-snip"><a class="header" href="#wasm-snip"><code>wasm-snip</code></a></h3>
<p>To install the <code>wasm-snip</code>:</p>
<pre><code class="language-bash">cargo install wasm-snip
</code></pre>
<h3 id="wasm32-target"><a class="header" href="#wasm32-target"><code>wasm32</code> target</a></h3>
<p>To install the <code>wasm32-unknown-unknown</code> target via <code>rustup</code>:</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<blockquote>
<p>IMPORTANT: Users on Apple Silicon macOS systems may experience trouble when trying to build WASM modules due to its <code>clang</code> binary not supporting WASM targets. If encountered, you can install a binary with better support from Homebrew (<code>brew install llvm</code>) and instruct <code>rustc</code> to leverage it by setting the following environment variables:</p>
<ul>
<li><code>AR=/opt/homebrew/opt/llvm/bin/llvm-ar</code></li>
<li><code>CC=/opt/homebrew/opt/llvm/bin/clang</code></li>
</ul>
<p>Additionally, on some systems you need to explicitly link <code>clang</code> to <code>llvm</code>.</p>
<ul>
<li><code>LIBCLANG_PATH=&quot;/opt/homebrew/opt/llvm/lib&quot;</code></li>
<li><code>LDFLAGS=&quot;-L/opt/homebrew/opt/llvm/lib&quot;</code></li>
<li><code>CPPFLAGS=&quot;-I/opt/homebrew/opt/llvm/include&quot;</code></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexer-service-infrastructure"><a class="header" href="#indexer-service-infrastructure">Indexer Service Infrastructure</a></h1>
<ul>
<li><a href="getting-started/indexer-service-infrastructure.html#components">Service Components</a></li>
<li><a href="getting-started/indexer-service-infrastructure.html#fuel-indexer-service">Fuel Indexer Service</a>
<ul>
<li><a href="getting-started/indexer-service-infrastructure.html#using-cli-options-indexer-service">Starting the service via CLI options</a></li>
<li><a href="getting-started/indexer-service-infrastructure.html#using-a-configuration-file-indexer-service">Starting the service via a config file</a></li>
</ul>
</li>
<li><a href="getting-started/indexer-service-infrastructure.html#web-api-server">Fuel Indexer Web Server</a>
<ul>
<li><a href="getting-started/indexer-service-infrastructure.html#using-cli-options-web-server">Starting the service via CLI options</a></li>
<li><a href="getting-started/indexer-service-infrastructure.html#using-a-configuration-file-web-server">Starting the service via a config file</a></li>
</ul>
</li>
</ul>
<p>A Fuel indexer service instance requires just three components:</p>
<ul>
<li>
<p>a <strong>Fuel Node</strong>: Custom indexers monitor incoming blocks via a Fuel GraphQL server and extract information about the state of the Fuel blockchain.</p>
</li>
<li>
<p>a <strong>PostgreSQL database server</strong>: Extracted information is saved into a database.</p>
</li>
<li>
<p>a <strong>Web Server</strong>: dApps can query indexers for up-to-date information and operators can deploy/remove indexers as needed.</p>
</li>
</ul>
<hr />
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Default Host</th><th>Default Port</th><th>CLI Argument</th><th>Environment Variable</th></tr></thead><tbody>
<tr><td>Fuel Node</td><td>localhost</td><td>4000</td><td><code>--fuel-node-{host,port}</code></td><td>$FUEL_NODE_{HOST,PORT}</td></tr>
<tr><td>Database Server</td><td>localhost</td><td>5432</td><td><code>--postgres-{username,database,password,host,port}</code></td><td>$POSTGRES_{USERNAME,DATABASE,PASSWORD,HOST,PORT}</td></tr>
<tr><td>Indexer Service Web API</td><td>localhost</td><td>29987</td><td><code>--web-api-{host,port}</code></td><td>$WEB_API_{HOST,PORT}</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="fuel-indexer-service"><a class="header" href="#fuel-indexer-service">Fuel Indexer Service</a></h2>
<p>The Fuel indexer service will connect to any Fuel GraphQL server, which means you can run your own node or use a node provided by Fuel. The indexer service web server is included with the Fuel indexer; it's available as soon as the indexer is started through <code>fuel-indexer run</code>. The only component that isn't provided for you is a Postgres database server. You should set up a server according to your own needs and specifications.</p>
<blockquote>
<p>You can start the indexer service with an array of CLI options. Note that most (if not all) of these options include sensible defaults.</p>
</blockquote>
<h3 id="using-cli-options-indexer-service"><a class="header" href="#using-cli-options-indexer-service">Using CLI options (Indexer Service)</a></h3>
<pre><code class="language-bash">fuel-indexer run --help
</code></pre>
<pre><code class="language-text">Standalone binary for the fuel indexer service.

USAGE:
    fuel-indexer run [OPTIONS]

OPTIONS:
        --accept-sql-queries
            Allow the web server to accept raw SQL queries.

        --allow-non-sequential-blocks
            Allow missing blocks or non-sequential block processing.

        --auth-enabled
            Require users to authenticate for some operations.

        --auth-strategy &lt;AUTH_STRATEGY&gt;
            Authentication scheme used.

        --block-page-size &lt;BLOCK_PAGE_SIZE&gt;
            Amount of blocks to return in a request to a Fuel node. [default: 20]

    -c, --config &lt;FILE&gt;
            Indexer service config file.

        --client-request-delay &lt;CLIENT_REQUEST_DELAY&gt;
            Make the service wait for the given duration between block requests to a Fuel client.

        --database &lt;DATABASE&gt;
            Database type. [default: postgres] [possible values: postgres]

        --disable-toolchain-version-check
            By default, Fuel Indexer will only accept WASM indexer modules compiled with the same
            toolchain version as the version of Fuel Indexer.

        --embedded-database
            Automatically create and start database using provided options or defaults.

        --fuel-node-host &lt;FUEL_NODE_HOST&gt;
            Host of the running Fuel node. [default: localhost]

        --fuel-node-port &lt;FUEL_NODE_PORT&gt;
            Listening port of the running Fuel node. [default: 4000]

    -h, --help
            Print help information

        --indexer-net-config
            Allow network configuration via indexer manifests.

        --jwt-expiry &lt;JWT_EXPIRY&gt;
            Amount of time (seconds) before expiring token (if JWT scheme is specified).

        --jwt-issuer &lt;JWT_ISSUER&gt;
            Issuer of JWT claims (if JWT scheme is specified).

        --jwt-secret &lt;JWT_SECRET&gt;
            Secret used for JWT scheme (if JWT scheme is specified).

        --local-fuel-node
            Start a local Fuel node.

        --log-level &lt;LOG_LEVEL&gt;
            Log level passed to the Fuel Indexer service. [default: info] [possible values: info,
            debug, error, warn]

    -m, --manifest &lt;FILE&gt;
            Indexer config file.

        --max-body-size &lt;MAX_BODY_SIZE&gt;
            Max body size for web server requests. [default: 5242880]

        --metering-points &lt;METERING_POINTS&gt;
            The number of WASM opcodes after which the indexer's event handler will stop execution.
            [default: 30000000000]

        --metrics
            Use Prometheus metrics reporting.

        --network &lt;NETWORK&gt;
            Use a network alias when connecting to a Fuel client. [possible values: beta-3, beta-5,
            beta-5]

        --postgres-database &lt;POSTGRES_DATABASE&gt;
            Postgres database.

        --postgres-host &lt;POSTGRES_HOST&gt;
            Postgres host.

        --postgres-password &lt;POSTGRES_PASSWORD&gt;
            Postgres password.

        --postgres-port &lt;POSTGRES_PORT&gt;
            Postgres port.

        --postgres-user &lt;POSTGRES_USER&gt;
            Postgres username.

        --rate-limit
            Enable rate limiting.

        --rate-limit-request-count &lt;RATE_LIMIT_REQUEST_COUNT&gt;
            Maximum number of requests to allow over --rate-limit-window..

        --rate-limit-window-size &lt;RATE_LIMIT_WINDOW_SIZE&gt;
            Number of seconds over which to allow --rate-limit-rps.

        --remove-data
            When replacing an indexer, also remove the indexed data.

        --replace-indexer
            Whether to allow replacing an existing indexer. If not specified, an attempt to deploy
            over an existing indexer results in an error.

        --run-migrations
            Run database migrations before starting service.

        --stop-idle-indexers
            Prevent indexers from running without handling any blocks.

    -v, --verbose
            Enable verbose logging.

    -V, --version
            Print version information

        --web-api-host &lt;WEB_API_HOST&gt;
            Web API host. [default: localhost]

        --web-api-port &lt;WEB_API_PORT&gt;
            Web API port. [default: 29987]
</code></pre>
<h3 id="using-a-configuration-file-indexer-service"><a class="header" href="#using-a-configuration-file-indexer-service">Using a configuration file (Indexer Service)</a></h3>
<pre><code class="language-yaml"># The following is an example Fuel indexer configuration file.
#
# This configuration spec is intended to be used for a single instance
# of a Fuel indexer node or service.
#
# For more info on how the Fuel indexer works, read the docs: https://docs.fuel.network/docs/indexer/
# or specifically read up on these configuration options: https://docs.fuel.network/docs/indexer/getting-started/indexer-service-infrastructure/

# Whether to allow replacing an indexer.
#
# If this is disabled, then an HTTP 409 Conflict will be returned if an indexer with the same name already exists.
replace_indexer: false

# Log level passed to the Fuel Indexer service.
log_level: info

# Use Prometheus metrics reporting.
metrics: true

# Prevent indexers from running without handling any blocks.
stop_idle_indexers: false

# Run database migrations before starting service.
run_migrations: true

# Enable verbose logging.
verbose: false

# Start a local Fuel node.
local_fuel_node: false

# Allow network configuration via indexer manifests.
indexer_net_config: false

# The number of WASM opcodes after which the indexer will stop execution.
metering_points: 30000000000

# Allow the web server to accept raw SQL queries.
accept_sql_queries: false

# Amount of blocks to return in a request to a Fuel node.
block_page_size: 20

# Make the service wait for the given duration between block requests to a Fuel client
client_request_delay: ~

# ***********************
# Fuel Node configuration
# ************************

fuel_node:

  # Host of the running Fuel node.
  host: localhost

  # Listening port of the running Fuel node.
  port: 4000

  # Use a network alias when connecting to a Fuel client.
  network: ~

# *************************
# Web API configuration
# *************************

web_api:
  # Web API host.
  host: localhost

  # Web API port.
  port: 29987

  # Max body size for web server requests.
  max_body_size: &quot;5242880&quot;

# ******************************
# Database configuration options
# ******************************

database:

  postgres:
    # Postgres username.
    user: postgres

    # Postgres database.
    database: postgres

    # Postgres password.
    password: postgres

    # Postgres host.
    host: localhost

    # Postgres port.
    port: 5432

# ******************************
# Indexer service authentication
# ******************************

authentication:
  # Require users to authenticate for some operations.
  enabled: false

  # Which authentication scheme to use.
  strategy: jwt

  # Secret used if JWT authentication is specified.
  jwt_secret: abcdefghijklmnopqrstuvwxyz1234567890

  # JWT issuer if JWT authentication is specified.
  jwt_issuer: FuelLabs

  # Amount of time (seconds) before expiring token if JWT authentication is specified.
  jwt_expiry: 2592000

# ********************************
# Rate limit configuration options
# ********************************

rate_limit:
  # Enable rate limiting.
  enabled: false

  # Maximum number of requests to allow over --rate-limit-window..
  request_count: 10

  # Number of seconds over which to allow --rate-limit-rps.
  window_size: 5

</code></pre>
<hr />
<h2 id="web-api-server"><a class="header" href="#web-api-server">Web API Server</a></h2>
<p>The <code>fuel-indexer-api-server</code> crate of the Fuel indexer contains a standalone web server that acts as a queryable endpoint on top of the database. Note that the main <code>fuel-indexer</code> binary of the indexer project also contains the same web server endpoint.</p>
<blockquote>
<p>The <code>fuel-indexer-api-server</code> crate offers a <em>standalone</em> web server endpoint, whereas the API endpoint offered in <code>fuel-indexer</code> is bundled with other Fuel indexer functionality (e.g., execution, handling, data-layer construction, etc). Offering the API server as a separate piece allows users to separate components and run them on different systems, if desired.</p>
</blockquote>
<h3 id="using-cli-options-web-server"><a class="header" href="#using-cli-options-web-server">Using CLI Options (Web Server)</a></h3>
<blockquote>
<p>You can start the indexer service with an array of CLI options. Note that most (if not all) of these options include sensible defaults.</p>
</blockquote>
<pre><code class="language-bash">fuel-indexer-api-server run --help
</code></pre>
<pre><code class="language-text">Fuel indexer web server

USAGE:
    fuel-indexer-api-server run [OPTIONS]

OPTIONS:
        --accept-sql-queries
            Allow the web server to accept raw SQL queries.

        --auth-enabled
            Require users to authenticate for some operations.

        --auth-strategy &lt;AUTH_STRATEGY&gt;
            Authentication scheme used. [possible values: jwt]

    -c, --config &lt;CONFIG&gt;
            API server config file.

        --database &lt;DATABASE&gt;
            Database type. [default: postgres] [possible values: postgres]

        --disable-toolchain-version-check
            By default, Fuel Indexer will only accept WASM indexer modules compiled with the same
            toolchain version as the version of Fuel Indexer.

        --fuel-node-host &lt;FUEL_NODE_HOST&gt;
            Host of the running Fuel node. [default: localhost]

        --fuel-node-port &lt;FUEL_NODE_PORT&gt;
            Listening port of the running Fuel node. [default: 4000]

    -h, --help
            Print help information

        --jwt-expiry &lt;JWT_EXPIRY&gt;
            Amount of time (seconds) before expiring token (if JWT scheme is specified).

        --jwt-issuer &lt;JWT_ISSUER&gt;
            Issuer of JWT claims (if JWT scheme is specified).

        --jwt-secret &lt;JWT_SECRET&gt;
            Secret used for JWT scheme (if JWT scheme is specified).

        --log-level &lt;LOG_LEVEL&gt;
            Log level passed to the Fuel Indexer service. [default: info] [possible values: info,
            debug, error, warn]

        --max-body-size &lt;MAX_BODY_SIZE&gt;
            Max body size for web requests. [default: 5242880]

        --metrics
            Use Prometheus metrics reporting.

        --network &lt;NETWORK&gt;
            Use a network alias when connecting to a Fuel client. [possible values: beta-3, beta-5,
            beta-5]

        --postgres-database &lt;POSTGRES_DATABASE&gt;
            Postgres database.

        --postgres-host &lt;POSTGRES_HOST&gt;
            Postgres host.

        --postgres-password &lt;POSTGRES_PASSWORD&gt;
            Postgres password.

        --postgres-port &lt;POSTGRES_PORT&gt;
            Postgres port.

        --postgres-user &lt;POSTGRES_USER&gt;
            Postgres username.

        --rate-limit
            Enable rate limiting.

        --rate-limit-request-count &lt;RATE_LIMIT_REQUEST_COUNT&gt;
            Maximum number of requests to allow over --rate-limit-window..

        --rate-limit-window-size &lt;RATE_LIMIT_WINDOW_SIZE&gt;
            Number of seconds over which to allow --rate-limit-rps.

        --run-migrations
            Run database migrations before starting service.

    -v, --verbose
            Enable verbose logging.

    -V, --version
            Print version information

        --web-api-host &lt;WEB_API_HOST&gt;
            Web API host. [default: localhost]

        --web-api-port &lt;WEB_API_PORT&gt;
            Web API port. [default: 29987]
</code></pre>
<h3 id="using-a-configuration-file-web-server"><a class="header" href="#using-a-configuration-file-web-server">Using A Configuration File (Web Server)</a></h3>
<p>To run the standalone Fuel indexer web server server using a configuration file:</p>
<pre><code class="language-bash">fuel-indexer-api-server run --config config.yaml
</code></pre>
<p>In the above example, <code>config.yaml</code> is based on <a href="https://github.com/FuelLabs/fuel-indexer/blob/develop/config.yaml">the default service configuration file</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-it-compares"><a class="header" href="#how-it-compares">How it Compares</a></h1>
<p>Since many users may be familiar with indexing by using a solution like The Graph, it may be helpful to provide a comparison between The Graph and the Fuel indexer.</p>
<h2 id="differential-value"><a class="header" href="#differential-value">Differential Value</a></h2>
<p>Generally, the biggest conceptual differences between Fuel's indexer service and other indexer services (such as The Graph) are indexing speed, general ease of use, and indexable data types.</p>
<h3 id="speed-of-indexing"><a class="header" href="#speed-of-indexing">Speed of indexing</a></h3>
<p>Using Fuel's indexers, users can index about 30 blocks per second on a standard Macbook Pro on an M1 chip. This type of indexing speed is a boon to smart contract authors who need to iterate quickly while building dApps.</p>
<h3 id="general-usability"><a class="header" href="#general-usability">General usability</a></h3>
<p>Unlike other indexing services, users can use the forc index CLI tool to create, deploy, update, re-deploy, remove, and check the status of their indexers. The ability to completely manage, maintain, and improve remote indexers without having to open any files, or edit any source code completely sets Fuel's indexer apart from other services in the space.</p>
<h3 id="what-you-can-index"><a class="header" href="#what-you-can-index">What you can index</a></h3>
<p>The Fuel indexer is tailored for compatibility with the FuelVM. This means that instead of being limited to the primitives of the Ethereum virtual machine (EVM), users of the Fuel indexer gain access to a much richer set of indexable abstractions provided by the FuelVM (e.g. predicates, transaction receipts, etc).</p>
<p>Legend:</p>
<ul>
<li>üü© : Supported</li>
<li>üü• : Not supported</li>
<li>üü® : Planned</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Feature</th><th style="text-align: center">The Graph</th><th style="text-align: center">Fuel Indexer</th><th style="text-align: center">Notes</th></tr></thead><tbody>
<tr><td style="text-align: center">Hosted Indexers</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">WASM Execution</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Handlers</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center">see <a href="getting-started/../indexing-fuel-types/index.html">Indexing Fuel Types</a> and <a href="getting-started/../indexing-custom-types/index.html">Indexing Custom Types</a></td></tr>
<tr><td style="text-align: center">Updatable Schemas</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">API Authentication</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Starting Block Configuration</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Native Unit Testing Framework</td><td style="text-align: center">üü©</td><td style="text-align: center">üü•</td><td style="text-align: center">Users are able to use <code>cargo test</code></td></tr>
<tr><td style="text-align: center">GraphQL: Sorting, Pagination, Filtering</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Schema: Enum, Object, and Union types</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Schema: One-to-one, one-to-many, many-to-many relationships</td><td style="text-align: center">üü©</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">AssemblyScript Support</td><td style="text-align: center">üü©</td><td style="text-align: center">üü•</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Admin Portal UI</td><td style="text-align: center">üü©</td><td style="text-align: center">üü•</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Stop, Remove, Re-deploy indexers without smart contract changes</td><td style="text-align: center">üü•</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Update &amp; redeploy indexers with 0 downtime</td><td style="text-align: center">üü•</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Use third party dependencies in your indexers</td><td style="text-align: center">üü•</td><td style="text-align: center">üü©</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>In this tutorial you will:</p>
<ol>
<li>Bootstrap your development environment.</li>
<li>Create, build, and deploy an indexer to an indexer service hooked up to Fuel's <code>beta-5</code> testnet.</li>
<li>Query your indexer's newly created index for data using GraphQL.</li>
</ol>
<hr />
<h2 id="1-setting-up-your-environment"><a class="header" href="#1-setting-up-your-environment">1. Setting up your environment</a></h2>
<p>In this Quickstart, we'll use Fuel's toolchain manager <a href="https://github.com/FuelLabs/fuelup"><code>fuelup</code></a> in order to install the <code>forc-index</code> component that we'll use to develop our indexer.</p>
<h3 id="11-install-fuelup"><a class="header" href="#11-install-fuelup">1.1 Install <code>fuelup</code></a></h3>
<p>To install fuelup with the default features/options, use the following command to download the fuelup installation script and run it interactively.</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://install.fuel.network/fuelup-init.sh | sh
</code></pre>
<blockquote>
<p>If you require a non-default <code>fuelup</code> installation, please <a href="https://github.com/FuelLabs/fuelup">read the <code>fuelup</code> installation docs.</a></p>
</blockquote>
<h3 id="12-webassembly-wasm-setup"><a class="header" href="#12-webassembly-wasm-setup">1.2 WebAssembly (WASM) Setup</a></h3>
<p>Indexers are typically compiled to WASM so you'll need to have the proper WASM compilation target available on your system. You can install this target using <code>rustup</code>:</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<p>Additionally, you'll need the <code>wasm-snip</code> utility in order to remove errant symbols from your compiled WASM binary. You can install this tool using <code>cargo</code>:</p>
<pre><code class="language-bash">cargo install wasm-snip
</code></pre>
<hr />
<h2 id="2-using-the-forc-index-plugin"><a class="header" href="#2-using-the-forc-index-plugin">2. Using the <code>forc-index</code> plugin</a></h2>
<p>The primary means of interfacing with the Fuel indexer for indexer development is the <a href="https://crates.io/crates/forc-index"><code>forc-index</code> CLI tool</a>. <code>forc-index</code> is a <a href="https://github.com/FuelLabs/sway/tree/master/forc"><code>forc</code></a> plugin specifically created to interface with the Fuel indexer service. Since we already installed <code>fuelup</code> in a previous step <sup><a href="getting-started/quickstart.html#11-install-fuelup">1.1</a></sup>, we should be able to check that our <code>forc-index</code> binary was successfully installed and added to our <code>PATH</code>.</p>
<pre><code class="language-bash">which forc-index
</code></pre>
<pre><code class="language-text">/Users/me/.fuelup/bin/forc-index
</code></pre>
<blockquote>
<p>IMPORTANT: <code>fuelup</code> will install several binaries from the Fuel ecosystem and add them into your <code>PATH</code>, including the <code>fuel-indexer</code> binary. The <code>fuel-indexer</code> binary is the primary binary that users can use to spin up a Fuel indexer service.</p>
</blockquote>
<pre><code class="language-bash">which fuel-indexer
</code></pre>
<pre><code class="language-text">/Users/me/.fuelup/bin/fuel-indexer
</code></pre>
<h3 id="21-check-for-components"><a class="header" href="#21-check-for-components">2.1 Check for components</a></h3>
<p>Once the <code>forc-index</code> plugin is installed, let's go ahead and see what indexer components we have installed.</p>
<blockquote>
<p>Many of these components are required for development work (e.g., <code>fuel-core</code>, <code>psql</code>) but some are even required for non-development usage as well (e.g., <code>wasm-snip</code>, <code>fuelup</code>).</p>
</blockquote>
<pre><code class="language-bash">forc index check
</code></pre>
<pre><code class="language-text">+--------+------------------------+---------------------------------------------------------+
| Status |       Component        |                         Details                         |
+--------+------------------------+---------------------------------------------------------+
|   ‚õîÔ∏è   | fuel-indexer binary    |  Can't locate fuel-indexer.                             |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | fuel-indexer service   |  Local service found: PID(63967) | Port(29987).         |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | psql                   |  /usr/local/bin/psql                                    |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | fuel-core              |  /Users/me/.cargo/bin/fuel-core                         |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | docker                 |  /usr/local/bin/docker                                  |
+--------+------------------------+---------------------------------------------------------+
|   ‚õîÔ∏è   | fuelup                 |  Can't locate fuelup.                                   |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | wasm-snip              |  /Users/me/.cargo/bin/wasm-snip                         |
+--------+------------------------+---------------------------------------------------------+
|   ‚õîÔ∏è   | forc-postgres          |  Can't locate fuelup.                                   |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | rustc                  |  /Users/me/.cargo/bin/rustc                             |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | forc-wallet            |  /Users/me/.cargo/bin/forc-wallet                       |
+--------+------------------------+---------------------------------------------------------+
</code></pre>
<h3 id="22-setup-a-database-and-start-the-indexer-service"><a class="header" href="#22-setup-a-database-and-start-the-indexer-service">2.2 Setup a Database and Start the Indexer Service</a></h3>
<p>To quickly setup and bootstrap the PostgreSQL database that we'll need, we'll use <code>forc index</code>.</p>
<p>We can quickly create a bootstrapped database and start the Fuel indexer service by running the following command:</p>
<blockquote>
<p>IMPORTANT: Below we're specifying our Postgres <code>hostname</code> as <code>--postgres-host postgresql</code>, but you might need to change this based on your own Postgres instance details (see <code>forc index start --help</code> for more details).</p>
<p>Additionally, you can try using the <code>--embedded-database</code> flag in order to quickly use an embedded instance of Postgres, but this flag can be flaky, and its ease of use often depends on what platform you're using.</p>
<p>If you find that <code>--embedded-database</code> isn't working on your machine (for whatever reason), we strongly recommend that you simply used the Dockerized Fuel indexer components included in the project by using the <code>docker compose</code> script <a href="https://github.com/FuelLabs/fuel-indexer/blob/develop/scripts/docker-compose.yaml">included in the project</a>.</p>
</blockquote>
<pre><code class="language-bash">forc index start --network beta-5 --run-migrations --postgres-host postgresql
</code></pre>
<p>You should see output indicating the successful creation of a database and start of the indexer service; there may be much more content in your session, but it should generally contain output similar to the following lines:</p>
<pre><code class="language-text">‚úÖ Successfully started the indexer service at PID 39407

2023-07-31T15:57:28.942954Z  INFO fuel_indexer::commands::run: 109: Configuration: IndexerConfig { metering_points: Some(30000000000), log_level: &quot;info&quot;, verbose: false, local_fuel_node: false, indexer_net_config: false, fuel_node: FuelClientConfig { host: &quot;beta-5.fuel.network&quot;, port: &quot;80&quot; }, web_api: WebApiConfig { host: &quot;localhost&quot;, port: &quot;29987&quot;, max_body_size: 5242880 }, database: PostgresConfig { user: &quot;postgres&quot;, password: &quot;XXXX&quot;, host: &quot;localhost&quot;, port: &quot;5432&quot;, database: &quot;postgres&quot;, verbose: &quot;false&quot; }, metrics: false, stop_idle_indexers: false, run_migrations: true, authentication: AuthenticationConfig { enabled: false, strategy: None, jwt_secret: &quot;XXXX&quot;, jwt_issuer: None, jwt_expiry: None }, rate_limit: RateLimitConfig { enabled: false, request_count: None, window_size: None }, replace_indexer: false, accept_sql_queries: false }
2023-07-31T15:57:28.948657Z  INFO sqlx::postgres::notice: 157: relation &quot;_sqlx_migrations&quot; already exists, skipping
2023-07-31T15:57:28.976258Z  INFO fuel_indexer::service: 378: Resuming Indexer(fuel.indexer_test) from block 81188
2023-07-31T15:57:29.077928Z  INFO fuel_indexer::database: 187: Loading schema for Indexer(fuel.indexer_test) with Version(2738d221cf1e926d28e62bc93604a96ec6f7c5093e766f45a4555ed06e437b7f).
2023-07-31T15:57:29.081302Z  WARN fuel_indexer::executor: 87: No end_block specified in manifest. Indexer will run forever.
2023-07-31T15:57:29.081311Z  INFO fuel_indexer::executor: 109: Indexer(fuel.indexer_test) subscribing to Fuel node at beta-5.fuel.network:80
2023-07-31T15:57:29.081424Z  INFO fuel_indexer::service: 194: Registered Indexer(fuel.indexer_test)
2023-07-31T15:57:29.082150Z  INFO fuel_indexer_lib::utils: 132: Parsed SocketAddr '127.0.0.1:29987' from 'localhost:29987
</code></pre>
<h3 id="23-creating-a-new-indexer"><a class="header" href="#23-creating-a-new-indexer">2.3 Creating a new indexer</a></h3>
<p>Now that we have our development environment set up, the next step is to create an indexer.</p>
<pre><code class="language-bash">forc index new hello-indexer --namespace fuellabs &amp;&amp; cd hello-indexer
</code></pre>
<blockquote>
<p>The <code>namespace</code> of your project is a required option. You can think of a <code>namespace</code> as your organization name or company name. Your project might contain one or many indexers all under the same <code>namespace</code>. For a complete list of options passed to <code>forc index new</code>, see <a href="getting-started/../forc-index/new.html">here</a>.</p>
</blockquote>
<pre><code class="language-text">forc index new hello-indexer --namespace FuelLabs

‚úÖ Successfully created indexer


‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó         ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù   ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù


An easy-to-use, flexible indexing service built to go fast. üöóüí®


----

Read the Docs:
- Fuel Indexer: https://github.com/FuelLabs/fuel-indexer
- Fuel Indexer Book: https://docs.fuel.network/docs/indexer/
- Sway Book: https://docs.fuel.network/docs/sway/
- Rust SDK Book: https://rust.fuel.network


Join the Community:
- Follow us @Fuel: https://twitter.com/fuel_network
- Ask questions in dev-chat on Discord: https://discord.com/invite/xfpK4Pe

Report Bugs:
- Fuel Indexer Issues: https://github.com/FuelLabs/fuel-indexer/issues/new

Take a quick tour.

`forc index auth`
    Authenticate against an indexer service.
`forc index build`
    Build an indexer.
`forc index check`
    List indexer components.
`forc index deploy`
    Deploy an indexer.
`forc index kill`
    Kill a running Fuel indexer process on a given port.
`forc index new`
    Create a new indexer.
`forc index remove`
    Stop a running indexer.
`forc index start`
    Start a local indexer service.
`forc index status`
    Check the status of an indexer.
</code></pre>
<h3 id="24-deploying-our-indexer"><a class="header" href="#24-deploying-our-indexer">2.4 Deploying our indexer</a></h3>
<p>At this point, we have a brand new indexer that will index some blocks and transactions. And with both our database and Fuel indexer services up and running, all that's left to do is to build and deploy the indexer in order to see it in action. Let's build and deploy our indexer:</p>
<pre><code class="language-bash">forc index deploy
</code></pre>
<blockquote>
<p>IMPORTANT: <code>forc index deploy</code> by defaults runs <code>forc index build</code> prior to deploying the indexer. The same result can be produced by running <code>forc index build</code> then subsequently running <code>forc index deploy</code>. For more info, checkout the <a href="getting-started/./../forc-index/deploy.html"><code>forc index deploy</code></a> command.</p>
</blockquote>
<p>If all goes well, you should see the following:</p>
<pre><code class="language-text">‚ñπ‚ñπ‚ñπ‚ñπ‚ñπ ‚è∞ Building...                         Finished dev [unoptimized + debuginfo] target(s) in 0.96s
‚ñ™‚ñ™‚ñ™‚ñ™‚ñ™ ‚úÖ Build succeeded.                    Deploying indexer
‚ñ™‚ñ™‚ñ™‚ñ™‚ñ™ ‚úÖ Successfully deployed indexer.
</code></pre>
<p>And we can check the status of our newly deployed indexer using:</p>
<pre><code class="language-bash">forc index status
</code></pre>
<p>Which should show:</p>
<pre><code class="language-text">‚úÖ Successfully fetched service health:

client status: OK
database status: OK
uptime: 1m 30s

Indexers:

‚îÄ fuellabs
   ‚îî‚îÄ hello_world
      ‚Ä¢ id: 1
      ‚Ä¢ created at: 2023-11-08 15:09:49.205698 UTC (52s ago)
      ‚Ä¢ status: running
      ‚Ä¢ status message:
          Indexed 5440 blocks
</code></pre>
<blockquote>
<h4 id="what-is-a-deployment-exactly"><a class="header" href="#what-is-a-deployment-exactly">What is a &quot;deployment&quot; exactly?</a></h4>
<p>A <em>deployment</em> within the context of Fuel's indexer is a series of steps taken to get your indexer project running in the wild.</p>
<p>This series of steps involves compiling your indexer project to a <code>wasm32-unknown-unknown</code> target and uploading the indexer to a running Fuel indexer service. The service will then register an executor and build database tables for this indexer. Once this series of steps has completed, your indexer is considered to be <a href="https://en.wikipedia.org/wiki/Software_deployment">&quot;deployed&quot;</a>.</p>
<p>Users will often find that they're simply deploying their indexers to a Fuel indexer service running on their local machine; this is just one valid use-case described in <a href="getting-started/./indexer-service-infrastructure.html">our infrastructure docs</a>. Keep in mind that the intended use of a Fuel indexer service is as a standalone remote service that may run many different indexers at any given time.</p>
</blockquote>
<h2 id="3-querying-for-data"><a class="header" href="#3-querying-for-data">3. Querying for data</a></h2>
<p>With our indexer deployed, we should be able to query for newly indexed data after a few seconds.</p>
<p>Below, we write a simple GraphQL query that returns a few fields from all transactions that we've indexed.</p>
<p>You can open your GraphQL query playground at <code>http://127.0.0.1:29987/api/playground/fuellabs/hello_indexer</code> and submit the following GraphQL query.</p>
<pre><code class="language-graphql">query {
  transaction {
    id,
    hash,
    block {
      id
    }
  }
}
</code></pre>
<p>The response you get should resemble:</p>
<pre><code class="language-json">[
  {
    &quot;block&quot;: {
      &quot;id&quot;: &quot;24002b29ef4331f5ee75a38bf6381f2c8e8d2d5b4d78470706dde7ab0b8d54c0&quot;
    },
    &quot;hash&quot;: &quot;82b36dce26d926921b8e79597899d8712fdabf2553f28b45ef3851a968efb4b9&quot;,
    &quot;id&quot;: &quot;eb7e14822e18e71ba7c92c266b0976acda2344dfbef7a60099d400cc243394fb&quot;
  },
  {
    &quot;block&quot;: {
      &quot;id&quot;: &quot;1309ee2cb0846b1a7e45313e1c39b2a24ffd552a381f2f627225256f725a93e3&quot;
    },
    &quot;hash&quot;: &quot;f0c7c778faa6eb2a8bf03c9c47bb3f836bd4fe37e69c18e30f853ff146522dcb&quot;,
    &quot;id&quot;: &quot;182b6343bbbca2fcecf97020ea3f3767b8f5c370a6b853d2add46853e542a113&quot;
  },
  {
    &quot;block&quot;: {
      &quot;id&quot;: &quot;95588e20296969a76576d519d301c6cabe1e009675e430da93e18ba2a0d38a49&quot;
    },
    &quot;hash&quot;: &quot;e729045198ee10dcf49e431f50c2ffe8c37129cbe47e003a59aff81a88b03b50&quot;,
    &quot;id&quot;: &quot;6910ebc30a1037b83336c956c95f7fc470c4b76750a93f6a1f6d19a21d058b19&quot;
  }
]
</code></pre>
<h3 id="finished-"><a class="header" href="#finished-">Finished! ü•≥</a></h3>
<p>Congrats, you just created, built, and deployed your first indexer on the world's fastest execution layer.</p>
<p>For more info on how indexers work, please checkout the <a href="getting-started/./../project-components/index.html">reference guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD024 -->
<h1 id="a-fuel-indexer-project"><a class="header" href="#a-fuel-indexer-project">A Fuel Indexer Project</a></h1>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>The Fuel indexer project can currently be used in a number of different ways:</p>
<ul>
<li>as tooling to interact with indexers</li>
<li>as a standalone service</li>
<li>as a part of a larger Fuel project, alongside other components of the Fuel ecosystem (e.g. <a href="https://docs.fuel.network/docs/sway/">Sway smart contracts</a>)</li>
</ul>
<p>We'll describe these three different use cases below.</p>
<h3 id="as-tooling-to-interact-with-indexers"><a class="header" href="#as-tooling-to-interact-with-indexers">As tooling to interact with indexers</a></h3>
<p>The Fuel indexer provides functionality to make it easy to build and compile arbitrary indexers by using the <a href="project-components/../forc-index/index.html"><code>forc index</code></a> CLI tool. Using <code>forc index</code>, users can create, build, deploy, and remove indexers, as well as authenticate against a running indexer service, and check the status of running indexers.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>Create, deploy, and check the status of a new indexer.</p>
<pre><code class="language-bash">forc index new fuel &amp;&amp; \
    cd fuel &amp;&amp; forc index deploy --url http://indexer.fuel.network &amp;&amp; \
        forc index status --url http://indexer.fuel.network --auth $MY_TOKEN
</code></pre>
<h3 id="as-a-standalone-service"><a class="header" href="#as-a-standalone-service">As a standalone service</a></h3>
<p>You can also start the Fuel indexer as a standalone service that connects to a Fuel node in order to monitor the Fuel blockchain for new blocks and transactions. To do so, run the requisite database migrations, adjust the configuration to connect to a Fuel node, and start the service.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<p>Create, deploy, and check the status of a new indexer.</p>
<pre><code class="language-bash">fuel-indexer run \
    --network beta-5 \
    --run-migrations \
    --accept-sql-queries \
    --replace-indexer
</code></pre>
<h3 id="as-part-of-a-fuel-project"><a class="header" href="#as-part-of-a-fuel-project">As part of a Fuel project</a></h3>
<p>Finally, you can run the Fuel indexer as part of a project that uses other components of the Fuel ecosystem, such as Sway. The convention for a Fuel project layout including an indexer is as follows:</p>
<pre><code class="language-text">.
‚îú‚îÄ‚îÄ contracts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hello-contract
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ Forc.toml
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ src
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ main.sw
‚îú‚îÄ‚îÄ frontend
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ indexer
    ‚îî‚îÄ‚îÄ hello-indexer
        ‚îú‚îÄ‚îÄ Cargo.toml
        ‚îú‚îÄ‚îÄ hello_indexer.manifest.yaml
        ‚îú‚îÄ‚îÄ schema
        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hello_indexer.schema.graphql
        ‚îî‚îÄ‚îÄ src
            ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
<hr />
<h2 id="an-indexer-project-at-a-glance"><a class="header" href="#an-indexer-project-at-a-glance">An Indexer Project at a Glance</a></h2>
<p>Every Fuel indexer project requires three components:</p>
<ul>
<li>a <a href="project-components/./manifest.html">Manifest</a> describing how the indexer should work</li>
<li>a <a href="project-components/./schema.html">Schema</a> containing data models for the data that is to be indexed</li>
<li>a <a href="project-components/./module.html">Module</a> which contains the logic for how data coming from the FuelVM should be saved into an index</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">Manifest</a></h1>
<p>A manifest is a YAML configuration file that specifies various aspects of how an indexer should function: Where should the indexer start? Where should the indexer end? What contract should the indexer subscribe to?</p>
<p>Below is a sample indexer manifest file</p>
<pre><code class="language-yaml">namespace: fuellabs
identifier: order_book_v1
fuel_client: beta-5.fuel.network:80
abi: path/to/my/contract-abi.json
contract_id: &quot;fuels0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;
graphql_schema: path/to/my/schema.graphql
start_block: 1564
end_block: 310000
module:
  wasm: path/to/my/wasm_module.wasm
</code></pre>
<h2 id="namespace"><a class="header" href="#namespace"><code>namespace</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>namespace</code> is the topmost organizational level of an indexer. You can think of different namespaces as separate and distinct collections comprised of indexers. A namespace is unique to a given indexer operator -- i.e., indexer operators will not be able to support more than one namespace of the same name.</p>
<h2 id="identifier"><a class="header" href="#identifier"><code>identifier</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>identifier</code> field is used to (quite literally) identify the given indexer. If a namespace describes a collection of indexers, then an identifier describes a unique indexer inside that collection. As an example, if a provided <code>namespace</code> is <code>&quot;fuel&quot;</code> and a provided <code>identifier</code> is <code>&quot;index1&quot;</code>, then the full identifier for the given indexer will be <code>fuel.index1</code>.</p>
<h2 id="fuel_client"><a class="header" href="#fuel_client"><code>fuel_client</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>fuel_client</code> denotes the address (host, port combination) of the running Fuel client that you would like your indexer to index events from. In order to use this per-indexer <code>fuel_client</code> option, the indexer service at which your indexer is deployed will have to run with the <code>--indexer_net_config</code> option.</p>
<h2 id="abi"><a class="header" href="#abi"><code>abi</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>abi</code> option is used to provide a link to the Sway JSON application binary interface (ABI) that is generated when you build your Sway project. This generated ABI contains all types, type IDs, logged types, and message types used in your Sway contract.</p>
<h2 id="contract_id"><a class="header" href="#contract_id"><code>contract_id</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>contract_id</code> specifies the particular contract to which you would like an indexer to subscribe. Setting this field to an empty string will index events from any contract that is currently executing on the network. This field accepts either a single string, or a list of strings. The indexer will index events from all IDs if a list is passed.</p>
<blockquote>
<p>Important: Contract IDs are unique to the content of a contract. If you are subscribing to a certain contract and then the contract itself is changed or updated, you will need to change the <code>contract_id</code> field of the manifest to the new ID.
Note: This parameter supports both <code>Bech32</code> contract IDs and non-<code>Bech32</code> contract IDs</p>
</blockquote>
<h2 id="graphql_schema"><a class="header" href="#graphql_schema"><code>graphql_schema</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>graphql_schema</code> field contains the file path pointing to the corresponding GraphQL schema for a given indexer. This schema file holds the structures of the data that will eventually reside in your database. You can read more about the format of the schema file <a href="project-components/./schema.html">here</a>.</p>
<blockquote>
<p>Important: The objects defined in your GraphQL schema are called 'entities'. These entities are what will be eventually be stored in the database.</p>
</blockquote>
<h2 id="start_block"><a class="header" href="#start_block"><code>start_block</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>start_block</code> field indicates the block height after which you'd like your indexer to start indexing events.</p>
<h2 id="end_block"><a class="header" href="#end_block"><code>end_block</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>end_block</code> field indicates the block height after which the indexer should stop indexing blocks.</p>
<blockquote>
<p>Important: If no <code>end_block</code> is added the indexer will keep listening to new blocks indefinitely.</p>
</blockquote>
<h2 id="module"><a class="header" href="#module"><code>module</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>module</code> field contains a file path that points to code that will be run as an <em>executor</em> inside of the indexer.</p>
<h2 id="resumable"><a class="header" href="#resumable"><code>resumable</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>resumable</code> field contains a boolean value and specifies whether the indexer should synchronise with the latest block if it has fallen out of sync.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-schema"><a class="header" href="#graphql-schema">GraphQL Schema</a></h1>
<p>The GraphQL schema is a required component of the Fuel indexer. When data is indexed into the database, the actual values that are persisted to the database will be values created using the data structures defined in the GraphQL schema.</p>
<p>Below is a sample GraphQL schema for a Fuel indexer.</p>
<pre><code class="language-graphql">type Metadata @entity(virtual: true) {
    imageUrl: String!
    data: Bytes
}

type Account @entity {
    id: ID!
    address: Address!
    index: U64!
    metadata: Metadata
}

type Wallet @entity {
    id: ID!
    name: String!
    accounts: [Account!]!
}
</code></pre>
<p>For a complete list of all scalars that can be used in a Fuel indexer, please see the <a href="project-components/../designing-a-schema/scalars.html">GraphQL Scalars</a> section.</p>
<p>Further, for a complete list of how Sway data types, GraphQL scalar types, and Fuel indexer database types map to each other, please see the <a href="project-components/../storing-records/index.html">Database Types</a> section.</p>
<p>Finally, for a more in-depth explanation on the schema being used above üëÜüèΩ, please read the <a href="project-components/./../designing-a-schema/index.html">GraphQL</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexer-modules"><a class="header" href="#indexer-modules">Indexer modules</a></h1>
<p>Indexer modules are compiled binaries that process data from the Fuel blockchain into entity types defined in your schema so that the data can be stored in a database. The Fuel indexer supports both WebAssembly (WASM) and native binaries; however, we <strong>strongly</strong> recommend using WASM binaries.</p>
<p>This document describes the process of creating an indexer module.</p>
<h2 id="creating-handlers"><a class="header" href="#creating-handlers">Creating Handlers</a></h2>
<p>Prior to creating a module for an indexer, both the manifest and schema should be created. At compile time, information will be extracted from both of those assets and combined it with your defined logic to create handlers that save data to storage. Let's look at the following example of a module that will be compiled to WASM:</p>
<pre><code class="language-rust  ignore">use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {

    // This `log_the_greeting` function will be called, when we find
    // a `Greeting` in a block.
    fn log_the_greeting(greeting: Greeting) {
        info!(&quot;The greeting is: {greeting:?}&quot;);
    }
}</code></pre>
<h2 id="whats-going-on-here"><a class="header" href="#whats-going-on-here">What's going on here?</a></h2>
<ul>
<li>
<p>The first line imports the <a href="https://docs.rs/fuel-indexer-utils/latest/fuel_indexer_utils/prelude/index.html">prelude</a> from <code>fuel_indexer_utils</code>; this allows you to quickly bootstrap an indexer by using common types and traits. Then, we have a module decorated with the <code>#[indexer]</code> macro.</p>
<ul>
<li>This macro processes a manifest at the supplied file path, parses your schema and Sway contract ABI (if supplied), and generates code that is combined with handler functions in order to create a complete indexer module.</li>
</ul>
</li>
<li>
<p>Finally, we have an example handler function. You can define which functions handle different events by using the function parameters. If you add a function parameter of a certain type <code>T</code>, the function will be triggered whenever that type is found as part of a block, transaction, or receipt.</p>
<ul>
<li>In this example, let's say that you have a Sway contract with a function that logs a <code>Greeting</code> struct. When that function executes as part of a transaction, the logged struct will be included in the data that is processed from the Fuel blockchain. Your indexer module will see the struct and execute <code>log_the_greeting</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>You can learn more about what data can be indexed and find example handlers in the <a href="project-components/../indexing-fuel-types/index.html">Indexing Fuel Types</a> and <a href="project-components/../indexing-custom-types/index.html">Indexing Custom Types</a> sections.</p>
</blockquote>
<hr />
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To compile your indexer code to WASM, you'll first need to install the <code>wasm32-unknown-unknown</code> target platform through <code>rustup</code>, if you haven't done so already.</p>
<pre><code class="language-bash">rustup add target wasm32-unknown-unknown
</code></pre>
<p>After that, you can conveniently use the <a href="project-components/./../forc-index/index.html"><code>forc index</code></a> plugin to manager your indexers. Simply use <code>forc index build</code> to build your indexer or checkout the <a href="project-components/./../forc-index/build.html"><code>forc index build</code></a> docs for more options.</p>
<blockquote>
<h2 id="notes-on-web-assembly-modules"><a class="header" href="#notes-on-web-assembly-modules">Notes on Web Assembly modules</a></h2>
<p>There are a few points that Fuel indexer users should know when using WASM:</p>
<ol>
<li>
<p>WASM modules are only used if the execution mode specified in your manifest file is <code>wasm</code>.</p>
</li>
<li>
<p>Developers should be aware of what things may not work off-the-shelf in a module: file I/O, thread spawning, and anything that depends on system libraries or makes system calls. This is due to the technological limitations of WASM as a whole; more information can be found <a href="https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html">here</a>.</p>
</li>
<li>
<p>As of this writing, there is a small bug in newly built Fuel indexer WASM modules that produces a WASM runtime error due to an errant upstream dependency. For now, a quick workaround requires the use of <code>wasm-snip</code> to remove the errant symbols from the WASM module. More info can be found in the related script <a href="https://github.com/FuelLabs/fuel-indexer/blob/develop/scripts/stripper.bash">here</a>.</p>
</li>
<li>
<p>Users on Apple Silicon macOS systems may experience trouble when trying to build WASM modules due to its <code>clang</code> binary not supporting WASM targets. If encountered, you can install a binary with better support from Homebrew (<code>brew install llvm</code>) and instruct <code>rustc</code> to leverage it by setting the following environment variables:</p>
</li>
</ol>
<ul>
<li><code>AR=/opt/homebrew/opt/llvm/bin/llvm-ar</code></li>
<li><code>CC=/opt/homebrew/opt/llvm/bin/clang</code></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="designing-a-schema"><a class="header" href="#designing-a-schema">Designing a Schema</a></h1>
<p>The Fuel indexer uses GraphQL in order to allow users to query for indexed data. In this chapter, you can find information on how to leverage our supported features to efficiently get the data you want.</p>
<blockquote>
<p>‚ö†Ô∏è Please note that the Fuel indexer does not support the full GraphQL specification; however, we do our best to reasonably support as much as we can.</p>
</blockquote>
<ul>
<li><a href="designing-a-schema/./types.html">Types</a></li>
<li><a href="designing-a-schema/./scalars.html">Scalars</a></li>
<li><a href="designing-a-schema/./directives.html">Directives</a></li>
<li><a href="designing-a-schema/./relationships.html">Relationships</a></li>
</ul>
<h2 id="supported-functionality"><a class="header" href="#supported-functionality">Supported Functionality</a></h2>
<p>While we do our best to maintain compliance with the GraphQL specification and parity with other implementations, there are a few things that are under development or will not be implemented. Here's a table describing our GraphQL functionality:</p>
<p>Legend:</p>
<ul>
<li>üü© : Functionally complete</li>
<li>üü® : Partially complete</li>
<li>üü• : Planned but incomplete</li>
<li>‚õî : Not planned</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Functionality</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Arguments</td><td>üü©</td><td><a href="designing-a-schema/../querying/search-and-filtering.html">read the Search and Filtering section</a></td></tr>
<tr><td>Aliases</td><td>üü©</td><td></td></tr>
<tr><td>Fragments</td><td>üü®</td><td>inline fragments are currently not supported</td></tr>
<tr><td>Introspection</td><td>üü©</td><td></td></tr>
<tr><td>GraphQL Playground</td><td>üü©</td><td><a href="designing-a-schema/../querying/playground.html">read the Playground section</a></td></tr>
<tr><td>Pagination</td><td>üü®</td><td><a href="designing-a-schema/../querying/pagination.html">read the Pagination section</a></td></tr>
<tr><td>Directives</td><td>üü®</td><td><a href="designing-a-schema/./directives.html">read the Directives section</a></td></tr>
<tr><td>List Types</td><td>üü®</td><td></td></tr>
<tr><td>Union Types</td><td>üü®</td><td></td></tr>
<tr><td>Federation</td><td>‚õî</td><td></td></tr>
<tr><td>Variables</td><td>‚õî</td><td></td></tr>
<tr><td>Mutations</td><td>‚õî</td><td></td></tr>
<tr><td>Enums</td><td>üü®</td><td></td></tr>
<tr><td>Interfaces</td><td>‚õî</td><td></td></tr>
<tr><td>Input Types</td><td>‚õî</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<h2 id="objects"><a class="header" href="#objects">Objects</a></h2>
<p>Object types are the most commonly used type in indexer GraphQL schema. Each object type marked with an <code>@entity</code> directive will be converted into a SQL table.</p>
<pre><code class="language-graphql">type Account @entity {
    id: ID!
    address: Address!
    balance: U64!
}
</code></pre>
<p>This <code>Account</code> object type from the GraphQL schema, might be used in an indexer module like so:</p>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_event(event: Event) {
        let address = Address::default();
        let balance = 0;
        let account = Account::new(address, balance);
        account.save();
    }
}</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enum types are simply implemented as String types.</p>
<pre><code class="language-graphql">enum SignatureLabel {
    Multi
    Single
}
</code></pre>
<blockquote>
<p>Enum types in relation to Fuel indexer's implementation are just <code>String</code> types used primarily to label object types. There is no other way that <code>enum</code> types should be used at this time.
This <code>SignatureLabel</code> object type from the GraphQL schema, might be used in an indexer module like so:</p>
</blockquote>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_event(event: Event) {
        let label = SignatureLabel::Multi;
        assert_eq!(label.to_string(), &quot;SignatureLabel::Multi&quot;.to_string());
    }
}</code></pre>
<h2 id="unions"><a class="header" href="#unions">Unions</a></h2>
<p>Union types are unique in that any type marked as a <code>union</code> will be converted into an Object type, who's fields are the unique set of fields over all members of the union.</p>
<pre><code class="language-graphql">enum TransactionLabel {
    Create
    Script
    Mint
}

type CreateTransaction @entity {
    id: ID!
    bytecode_length: U64!
    contract_id: ContractId!
    label: TransactionLabel!
}

type ScriptTransaction @entity {
    id: ID!
    maturity: U64!
    label: TransactionLabel!
}

type MintTransaction @entity {
    id: ID!
    metadata: Json
    label: TransactionLabel!
}

union Transaction = CreateTransaction | ScriptTransaction | MintTransaction
</code></pre>
<p>The <code>Transaction</code> union type above, will internally produce the following object type:</p>
<pre><code class="language-graphql">type Transaction @entity {
    id: ID!
    bytecode_length: U64!
    contract_id: ContractId!
    label: TransactionLabel!
    maturity: U64!
    metadata: Json
}
</code></pre>
<blockquote>
<p>IMPORTANT: Note the order of the fields in the derived <code>Transaction</code> object type: the fields are ordered according to the unique set of fields from each of the union's members.</p>
<p>The <code>id</code>, <code>bytecode_length</code>, <code>contract_id</code>, and <code>label</code> fields come first, from the <code>CreateTransaction</code> object type. Next comes the <code>maturity</code> field from the <code>ScriptTransaction</code> object - because the <code>ScriptTransaction</code>'s <code>id</code> and <code>label</code> fields are already a part of the derived <code>Transaction</code> object, courtesy of the <code>CreateTransaction</code> object type. Finally, comes the <code>metadata</code> field, as part of the <code>MintTransaction</code> object type.
This <code>Transaction</code> union type from the GraphQL schema, might be used in an indexer module like so:</p>
</blockquote>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_event(event: Event) {
        let bytecode_length = 1024;
        let contract_id = ContractId::default();
        let label = TransactionLabel::Create;
        let maturity = 10000000;
        let metadata = None;
        let transaction = Transaction::new(bytecode_length, contract_id, label, maturity, metadata);
        transaction.save();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scalars"><a class="header" href="#scalars">Scalars</a></h1>
<p>The Fuel indexer has a collection of GraphQL scalars that cover virtually any value type in use on the Fuel network. The following list contains each GraphQL scalar type along with its equivalent Rust type.</p>
<div class="table-wrapper"><table><thead><tr><th>GraphQL Scalar</th><th>Rust Type</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>Address</code></td><td><code>u8[32]</code></td><td></td></tr>
<tr><td><code>AssetId</code></td><td><code>u8[32]</code></td><td></td></tr>
<tr><td><code>Boolean</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>Bytes</code></td><td><code>Vec&lt;u8&gt;</code></td><td>Byte blob of arbitrary size</td></tr>
<tr><td><code>Bytes32</code></td><td><code>u8[32]</code></td><td></td></tr>
<tr><td><code>Bytes4</code></td><td><code>u8[4]</code></td><td></td></tr>
<tr><td><code>Bytes64</code></td><td><code>u8[64]</code></td><td></td></tr>
<tr><td><code>Bytes8</code></td><td><code>u8[8]</code></td><td></td></tr>
<tr><td><code>ContractId</code></td><td><code>u8[32]</code></td><td></td></tr>
<tr><td><code>HexString</code></td><td><code>Vec&lt;u8&gt;</code></td><td>Byte blob of arbitrary size</td></tr>
<tr><td><code>I128</code></td><td><code>i128</code></td><td></td></tr>
<tr><td><code>I16</code></td><td><code>i16</code></td><td></td></tr>
<tr><td><code>I32</code></td><td><code>i32</code></td><td></td></tr>
<tr><td><code>I64</code></td><td><code>i64</code></td><td></td></tr>
<tr><td><code>I8</code></td><td><code>i8</code></td><td></td></tr>
<tr><td><code>ID</code></td><td><code>SizedAsciiString&lt;64&gt;</code></td><td>Alias of <code>UID</code></td></tr>
<tr><td><code>Json</code></td><td><code>String</code></td><td>JSON string of arbitrary size</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>String of arbitrary size</td></tr>
<tr><td><code>U128</code></td><td><code>u128</code></td><td></td></tr>
<tr><td><code>U16</code></td><td><code>u16</code></td><td></td></tr>
<tr><td><code>U32</code></td><td><code>u32</code></td><td></td></tr>
<tr><td><code>U64</code></td><td><code>u64</code></td><td></td></tr>
<tr><td><code>U8</code></td><td><code>u8</code></td><td></td></tr>
<tr><td><code>UID</code></td><td><code>SizedAsciiString&lt;64&gt;</code></td><td>32-byte unique ID</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="directives"><a class="header" href="#directives">Directives</a></h1>
<blockquote>
<p>Per GraphQL: A directive is a keyword preceded by a @ character (optionally followed by a list of named arguments) which can appear after almost any form of syntax in the GraphQL query or schema languages.</p>
</blockquote>
<p>As of this writing, the list of supported Fuel GraphQL schema directives includes:</p>
<ul>
<li><code>@indexed</code>: Denotes that a field should include a B-tree index in the database.</li>
<li><code>@unique</code>: Denotes that field should include a unique index in the database.</li>
<li><code>@join</code>: Denotes that a field has a &quot;relationship&quot; to another object type.</li>
</ul>
<h2 id="indexed"><a class="header" href="#indexed"><code>@indexed</code></a></h2>
<p>The <code>@indexed</code> directive adds a <a href="https://www.postgresql.org/docs/current/indexes-intro.html">database index</a> to the underlying column for the indicated field of that type. Generally, a database index is a data structure that allows you to quickly locate data without having to search each row in a database table.</p>
<pre><code class="language-graphql">type Book @entity {
    id: ID!
    name: Bytes8! @indexed
}

type Library @entity {
    id: ID!
    book: Book!
}
</code></pre>
<p>In this example, a single <code>BTREE INDEX</code> constraint will be created on the <code>book</code> table's <code>name</code> column, which allows for faster lookups on that field.</p>
<blockquote>
<p>Important: At the moment, database index constraint support is limited to <code>BTREE</code> in Postgres with <code>ON DELETE</code>, and <code>ON UPDATE</code> actions not being supported.</p>
</blockquote>
<h2 id="unique"><a class="header" href="#unique"><code>@unique</code></a></h2>
<p>The <code>@unique</code> directive adds a <code>UNIQUE</code> database constraint to the underlying database column for the indicated field of that type. A constraint specifies a rule for the data in a table and can be used to limit the type of data that can be placed in the table. In the case of a column with a <code>UNIQUE</code> constraint, all values in the column must be different.</p>
<pre><code class="language-graphql">type Book @entity {
    id: ID!
    name: Bytes8! @unique
}

type Library @entity {
    id: ID!
    book: Book!
}
</code></pre>
<p>A <code>UNIQUE</code> constraint will be created on the <code>book</code> table's <code>name</code> column, ensuring that no books can share the same name.</p>
<blockquote>
<p>Important: When using explicit or implicit foreign keys, it is required that the reference column name in your foreign key relationship be unique. <code>ID</code> types are by default unique, but all other types will have to be explicitly specified as being unique via the <code>@unique</code> directive.</p>
</blockquote>
<h2 id="join"><a class="header" href="#join"><code>@join</code></a></h2>
<p>The <code>@join</code> directive is used to relate a field in one type to others by referencing fields in another type. You can think of it as a link between two tables in your database. The field in the referenced type is called a <em>foreign key</em> and it is <strong>required</strong> to be unique.</p>
<pre><code class="language-graphql">type Book @entity {
    id: ID!
    name: String! @unique
}

type Library @entity {
    id: ID!
    book: Book! @join(on:name)
}
</code></pre>
<p>A foreign key constraint will be created on <code>library.book</code> that references <code>book.name</code>, which relates the <code>Book</code>s in a <code>Library</code> to the underlying <code>Book</code> table. For more info on what exactly is happening here, please see the <a href="designing-a-schema/./relationships.html">Relationships</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationships"><a class="header" href="#relationships">Relationships</a></h1>
<p>The Fuel indexer service supports foreign key relationships and constraints. There are two types of relationship specifications: <em>implicit</em> and <em>explicit</em>.</p>
<blockquote>
<p>IMPORTANT:</p>
<p>Implicit foreign keys do not require a <code>@join</code> directive. When using implicit foreign key references, merely add the referenced object as a field type (shown below). A lookup will automatically be done to add a foreign key constraint using this object's' <code>id</code> field.</p>
<p>Note that implicit foreign key relationships <em>only</em> use the <code>id</code> field on the referenced table. If you plan to use implicit foreign keys, the object being referenced <em>must</em> have an <code>id</code> field.</p>
<p>In contrast, explicit foreign keys <em>do</em> require a <code>@join</code> directive. Explicit foreign key references work similarly to implicit foreign keys; however, when using explicit foreign key references, you must add a <code>@join</code> directive after your object type. This <code>@join</code> directive includes the field in your foreign object that you would like to reference (shown below).</p>
</blockquote>
<p>Let's learn how to use each foreign key type by looking at some GraphQL schema examples.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="implicit-foreign-keys"><a class="header" href="#implicit-foreign-keys">Implicit foreign keys</a></h3>
<pre><code class="language-graphql">type Library @entity {
    id: ID!
    name: String!
}

type Book @entity {
    id: ID!
    library: Library!
}
</code></pre>
<p>Given the above schema, two entities will be created: a <code>Book</code> entity, and a <code>Library</code> entity. As you can see, we add the <code>Book</code> entity as an attribute on the <code>Library</code> entity, thus conveying that we want a one-to-many or one-to-one relationship between <code>Library</code> and <code>Book</code>. This means that for a given <code>Book</code>, we may also fetch the associated <code>Library</code> entity. It also means that the field <code>Book.library</code> will be an <code>ID</code> scalar type that references <code>Library.id</code>.</p>
<h3 id="explicit-foreign-keys"><a class="header" href="#explicit-foreign-keys">Explicit foreign keys</a></h3>
<pre><code class="language-graphql">type Library @entity {
    id: ID!
    name: String! @unique
}

type Book @entity {
    id: ID!
    library: Library! join(on:name)
}
</code></pre>
<p>For the most part, this works the same way as implicit foreign key usage. However, as you can see, instead of implicitly using <code>Library.id</code> as the reference column for our <code>Library</code> field type on the <code>Book</code> object, we're <em>explicitly</em> specifying that we want <code>Library.name</code> to serve as our foreign key for the <code>Book.library</code> field. Also, please note that since we're using <code>Library.name</code> in our foreign key constraint, that column is required to be unique (via the <code>@unique</code> directive).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexing-fuel-types"><a class="header" href="#indexing-fuel-types">Indexing Fuel Types</a></h1>
<p>This document provides information about Fuel-specific types and provides examples on how to index each type.</p>
<ul>
<li><a href="indexing-fuel-types/./blocks.html">Blocks</a></li>
<li><a href="indexing-fuel-types/./transactions.html">Transactions</a></li>
<li><a href="indexing-fuel-types/./receipts.html">Receipts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockdata"><a class="header" href="#blockdata"><code>BlockData</code></a></h1>
<blockquote>
<p>The <code>BlockData</code> struct is how blocks are represented in the Fuel indexer. It contains metadata such as the ID, height, and time, as well as a list of the transactions it contains (represented by <code>TransactionData</code>). It also contains the public key hash of the block producer, if present.</p>
</blockquote>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<pre><code class="language-rust ignore">pub struct BlockData {
    pub height: u32,
    pub id: Bytes32,
    pub header: Header,
    pub producer: Option&lt;Bytes32&gt;,
    pub time: i64,
    pub consensus: Consensus,
    pub transactions: Vec&lt;TransactionData&gt;,
}</code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-rust ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_block(block_data: BlockData) {
        let height = block_data.header.height;
        info!(&quot;This block #{height}&quot;);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD024 -->
<h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<h2 id="transactiondata"><a class="header" href="#transactiondata"><code>TransactionData</code></a></h2>
<p>The <code>TransactionData</code> struct contains important information about a transaction in the Fuel network. The <code>id</code> field is the transaction hash, which is a 32-byte string. The <code>receipts</code> field contains a list of <code>Receipts</code>, which are generated by a Fuel node during the execution of a Sway smart contract; you can find more information in the <a href="indexing-fuel-types/./receipts.html">Receipts</a> section.</p>
<h3 id="definition-1"><a class="header" href="#definition-1">Definition</a></h3>
<pre><code class="language-rust ignore">pub struct TransactionData {
    pub transaction: Transaction,
    pub status: TransactionStatus,
    pub receipts: Vec&lt;Receipt&gt;,
    pub id: TxId,
}</code></pre>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre><code class="language-rust ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_transaction(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            info!(
                &quot;Transaction {} in block at height {} has {} receipts&quot;,
                transaction.id,
                block_data.header.height,
                transaction.receipts.len()
            );
        }
    }
}</code></pre>
<h2 id="transactionstatus"><a class="header" href="#transactionstatus"><code>TransactionStatus</code></a></h2>
<p><code>TransactionStatus</code> refers to the status of a <code>Transaction</code> in the Fuel network.</p>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<pre><code class="language-rust ignore">pub enum TransactionStatus {
    Failure {
        block_id: String,
        time: DateTime&lt;Utc&gt;,
        reason: String,
    },
    SqueezedOut {
        reason: String,
    },
    Submitted {
        submitted_at: DateTime&lt;Utc&gt;,
    },
    Success {
        block_id: String,
        time: DateTime&lt;Utc&gt;,
    },
}</code></pre>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre><code class="language-rust ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_transaction(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            match transaction.transaction {
                fuel::Transaction::Script(tx) =&gt; match tx.status {
                    fuel::TransactionStatus::Success { block_id, time } =&gt; {
                        info!(
                            &quot;Transaction {} in block {} was successful at {}&quot;,
                            tx.id, block_id, time
                        );
                    }
                },
                _ =&gt; {
                    info!(&quot;We don't care about this transaction type&quot;);
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receipts"><a class="header" href="#receipts">Receipts</a></h1>
<p>Every transaction in the Fuel network contains a list of receipts with information about that transaction, including what contract function was called, logged data, data returned from a function, etc.</p>
<p>There are several types of receipts that can be attached to a transaction and indexed. You can learn more about each of these in the sections below.</p>
<ul>
<li><a href="indexing-fuel-types/receipts.html#burn"><strong><code>Burn</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#call"><strong><code>Call</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#log"><strong><code>Log</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#logdata"><strong><code>LogData</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#messageout"><strong><code>MessageOut</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#mint"><strong><code>Mint</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#panic"><strong><code>Panic</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#return"><strong><code>Return</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#returndata"><strong><code>ReturnData</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#revert"><strong><code>Revert</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#scriptresult"><strong><code>ScriptResult</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#transfer"><strong><code>Transfer</code></strong></a></li>
<li><a href="indexing-fuel-types/receipts.html#transferout"><strong><code>TransferOut</code></strong></a></li>
</ul>
<h2 id="burn"><a class="header" href="#burn"><code>Burn</code></a></h2>
<p>A <code>Burn</code> receipt is generated whenever an asset is burned in a Sway contract. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#burn-receipt">Read more about <code>Burn</code> in the Fuel protocol ABI spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::{AssetId, ContractId};
pub struct Burn {
    pub sub_id: AssetId,
    pub contract_id: ContractId,
    pub val: u64,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<pre><code class="language-rust  ignore">mod indexer_mod {
    fn handle_burn_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Burn { contract_id, .. } =&gt; {
                        info!(&quot;Found burn receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="call"><a class="header" href="#call"><code>Call</code></a></h2>
<p>A <code>Call</code> receipt is generated whenever a function is called in a Sway contract. The <code>fn_name</code> field contains the name of the called function from the aforementioned contract. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#call-receipt">Read more about <code>Call</code> in the Fuel protocol ABI spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::{AssetId, ContractId};
pub struct Call {
    pub contract_id: ContractId,
    pub to: ContractId,
    pub amount: u64,
    pub asset_id: AssetId,
    pub gas: u64,
    pub fn_name: String,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_call_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Call { contract_id, .. } =&gt; {
                        info!(&quot;Found call receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="log"><a class="header" href="#log"><code>Log</code></a></h2>
<p>A <code>Log</code> receipt is generated when calling <code>log()</code> on a non-reference types in a Sway contracts - specifically <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>. The <code>ra</code> field includes the value being logged while <code>rb</code> may include a non-zero value representing a unique ID for the <code>log</code> instance. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#log-receipt">Read more about <code>Log</code> in the Fuel protocol ABI spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Log {
    pub contract_id: ContractId,
    pub ra: u64,
    pub rb: u64,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_log_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Log { contract_id, .. } =&gt; {
                        info!(&quot;Found log receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="logdata"><a class="header" href="#logdata"><code>LogData</code></a></h2>
<p>A <code>LogData</code> receipt is generated when calling <code>log()</code> in a Sway contract on a reference type; this includes all types <em>except</em> non-reference types. The <code>data</code> field will include the logged value as a hexadecimal. The <code>rb</code> field will contain a unique ID that can be used to look up the logged data type. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#logdata-receipt">Read more about <code>LogData</code> in the Fuel protocol ABI spec</a>.
&gt;</p>
<pre><code class="language-rust ignore">use fuel_types::ContractId;
pub struct LogData {
    pub contract_id: ContractId,
    pub data: Vec&lt;u8&gt;,
    pub rb: u64,
    pub len: u64,
    pub ptr: u64,
}</code></pre>
<blockquote>
<p>Note: the example below will run both when the type <code>MyEvent</code> is logged as well as when <code>MyEvent</code> is returned from a function.</p>
</blockquote>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_log_data(event: MyEvent) {
        info!(&quot;Event {event:?} was logged in the contract&quot;);
    }
}</code></pre>
<h2 id="messageout"><a class="header" href="#messageout"><code>MessageOut</code></a></h2>
<p>A <code>MessageOut</code> receipt is generated as a result of the <code>send_typed_message()</code> Sway method in which a message is sent to a recipient address along with a certain amount of coins. The <code>data</code> field supports data of an arbitrary type <code>T</code> and will be decoded by the indexer upon receipt. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#messageout-receipt">Read more about <code>MessageOut</code> in the Fuel protocol ABI spec</a>.</p>
<pre><code class="language-rust ignore">use fuel_types::{MessageId, Bytes32, Address};
pub struct MessageOut {
    pub message_id: MessageId,
    pub sender: Address,
    pub recipient: Address,
    pub amount: u64,
    pub nonce: Bytes32,
    pub len: u64,
    pub digest: Bytes32,
    pub data: Vec&lt;u8&gt;,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_message_out(event: MyEvent) {
        info!(&quot;Event {event:?} was logged in the contract&quot;);
    }
}</code></pre>
<h2 id="mint"><a class="header" href="#mint"><code>Mint</code></a></h2>
<p>A <code>Mint</code> receipt is generated whenever an asset is burned in a Sway contract. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#mint-receipt">Read more about <code>Mint</code> in the Fuel protocol ABI spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::{AssetId, ContractId};
pub struct Mint {
    pub sub_id: AssetId,
    pub contract_id: ContractId,
    pub val: u64,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_mint_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Mint { contract_id, .. } =&gt; {
                        info!(&quot;Found mint receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="panic"><a class="header" href="#panic"><code>Panic</code></a></h2>
<p>A <code>Panic</code> receipt is produced when a Sway smart contract call fails for a reason that doesn't produce a revert. The reason field records the reason for the panic, which is represented by a number between 0 and 255. You can find the mapping between the values and their meanings here in the FuelVM <a href="https://github.com/FuelLabs/fuel-vm/blob/master/fuel-asm/src/panic_reason.rs">source code</a>. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#mint-receipt">Read more about <code>Panic</code> in the Fuel protocol spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Panic {
    pub contract_id: ContractId, 
    pub reason: u32, 
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_panic_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Panic { contract_id, .. } =&gt; {
                        info!(&quot;Found panic receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="return"><a class="header" href="#return"><code>Return</code></a></h2>
<p>A <code>Return</code> receipt is generated when returning a non-reference type in a Sway contract, specifically <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>. The <code>val</code> field includes the value being returned. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#return-receipt">Read more about <code>Return</code> in the Fuel protocol spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Return {
    pub contract_id: ContractId,
    pub val: u64,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<p>You can handle functions that produce a <code>Return</code> receipt type by adding a parameter with the type <code>Return</code>.</p>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_return_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Return { contract_id, .. } =&gt; {
                        info!(&quot;Found return receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="returndata"><a class="header" href="#returndata"><code>ReturnData</code></a></h2>
<p>A <code>ReturnData</code> receipt is generated when returning a reference type in a Sway contract; this includes all types <em>except</em> non-reference types. The <code>data</code> field will include the returned value as a hexadecimal. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#returndata-receipt">Read more about <code>ReturnData</code> in the Fuel protocol ABI spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct ReturnData {
    id: ContractId,
    data: Vec&lt;u8&gt;,
}</code></pre>
<blockquote>
<p>Note: the example below will run both when the type <code>MyStruct</code> is logged as well as when <code>MyStruct</code> is returned from a function.</p>
</blockquote>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_return_data(event: MyStruct) {
        info!(&quot;MyStruct is: {event:#}&quot;);
    }
}</code></pre>
<h2 id="revert"><a class="header" href="#revert"><code>Revert</code></a></h2>
<p>A <code>Revert</code> receipt is produced when a Sway smart contract function call fails. The table below lists possible reasons for the failure and their values. The <code>error_val</code> field records these values, enabling your indexer to identify the specific cause of the reversion. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#revert-receipt">Read more about <code>Revert</code> in the Fuel protocol spec</a>.</p>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Revert {
    pub contract_id: ContractId,
    pub error_val: u64,
}</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Reason</th><th>Value</th></tr></thead><tbody>
<tr><td><code>FailedRequire</code></td><td>0</td></tr>
<tr><td><code>FailedTransferToAddress</code></td><td>1</td></tr>
<tr><td><code>FailedSendMessage</code></td><td>2</td></tr>
<tr><td><code>FailedAssertEq</code></td><td>3</td></tr>
<tr><td><code>FailedAssert</code></td><td>4</td></tr>
</tbody></table>
</div>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_revert_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Revert { contract_id, .. } =&gt; {
                        info!(&quot;Found return receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="scriptresult"><a class="header" href="#scriptresult"><code>ScriptResult</code></a></h2>
<p>A <code>ScriptResult</code> receipt is generated when a contract call resolves; that is, it's generated as a result of the <code>RET</code>, <code>RETD</code>, and <code>RVRT</code> instructions. The <code>result</code> field will contain a <code>0</code> for success, and a non-zero value otherwise. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#scriptresult-receipt">Read more about <code>ScriptResult</code> in the Fuel protocol spec</a>.</p>
<pre><code class="language-rust ignore">pub struct ScriptResult {
    pub result: u64,
    pub gas_used: u64,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_script_result_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::ScriptResult { result, .. } =&gt; {
                        info!(&quot;Result from script: {result:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="transfer"><a class="header" href="#transfer"><code>Transfer</code></a></h2>
<p>A <code>Transfer</code> receipt is generated when coins are transferred to a contract as part of a Sway contract. The <code>asset_id</code> field contains the asset ID of the transferred coins, as the FuelVM has built-in support for working with multiple assets. The <code>pc</code> and <code>is</code> fields aren't currently used for anything, but are included for completeness. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#transfer-receipt">Read more about <code>Transfer</code> in the Fuel protocol spec</a>.</p>
<pre><code class="language-rust ignore">use fuel_types::{ContractId, AssetId};
pub struct Transfer {
    pub contract_id: ContractId,
    pub to: ContractId,
    pub amount: u64,
    pub asset_id: AssetId,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_transfer_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::Transfer { contract_id, .. } =&gt; {
                        info!(&quot;Found transfer receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<h2 id="transferout"><a class="header" href="#transferout"><code>TransferOut</code></a></h2>
<p>A <code>TransferOut</code> receipt is generated when coins are transferred to an address rather than a contract. Every other field of the receipt works the same way as it does in the <code>Transfer</code> receipt. <a href="https://docs.fuel.network/docs/specs/abi/receipts/#transferout-receipt">Read more about <code>TransferOut</code> in the Fuel protocol spec</a>.</p>
<pre><code class="language-rust ignore">use fuel_types::{ContractId, AssetId, Address};
pub struct TransferOut {
    pub contract_id: ContractId,
    pub to: Address,
    pub amount: u64,
    pub asset_id: AssetId,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<pre><code class="language-rust  ignore">extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn handle_transfer_out_receipt(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            for receipt in transaction.receipts {
                match receipt {
                    fuel::Receipt::TransferOut { contract_id, .. } =&gt; {
                        info!(&quot;Found transfer_out receipt from contract {contract_id:?}&quot;);
                    }
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<ol>
<li><a href="indexing-custom-types/index.html#1-contract">Contract</a></li>
<li><a href="indexing-custom-types/index.html#2-schema">Schema</a></li>
<li><a href="indexing-custom-types/index.html#3-manifest">Manifest</a></li>
<li><a href="indexing-custom-types/index.html#4-handler-logic">Writing a handler</a></li>
</ol>
<blockquote>
<p>In addition to Fuel-specific types, you can also index custom types triggered in your Sway smart contract.</p>
</blockquote>
<p>To index custom types from a Sway smart contract, you'll need that specific contract's ABI in JSON format; the JSON ABI is generated as a result of running <code>forc build</code> to build your contract. After that, the process is similar to <a href="indexing-custom-types/../indexing-fuel-types/index.html">indexing Fuel types</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Let's cover some of these concepts in an example below.</p>
<h3 id="1-contract"><a class="header" href="#1-contract">1. Contract</a></h3>
<p>First, let's create a Sway contract with some simple types.</p>
<pre><code class="language-sway">contract;

use std::logging::log;

struct Addition {
    added_value: u64,
    updated_total: u64,
}

struct Subtraction {
    subtracted_value: u64,
    updated_total: u64,
}

abi ValueStore {
    #[storage(read, write)]
    fn add(value: u64);

    #[storage(read, write)]
    fn subtract(value: u64) -&gt; Subtraction;
}

storage {
    total: u64 = 1000,
}

impl ValueStore for Contract {
    #[storage(read, write)]
    fn add(value: u64) {
        let updated_total = storage.total.read() + value;
        storage.total.write(updated_total);
        log(
            Addition {
                added_value: value,
                updated_total
            }
        )
    }

    #[storage(read, write)]
    fn subtract(value: u64) -&gt; Subtraction {
        let updated_total = storage.total.read() - value;
        storage.total.write(updated_total);

        Subtraction {
            subtracted_value: value,
            updated_total
        }
    }
}
</code></pre>
<ul>
<li>In this contract, we have two types: <code>Addition</code> and <code>Subtraction</code>. As we'll soon see, indexers can process custom types that are logged or returned as part of a function.</li>
<li>To begin creating an indexer for this contract, let's build the contract and generate a JSON ABI file.
<ul>
<li>Running <code>forc build</code> generates a JSON ABI similar to the lightly-edited one below:</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;types&quot;: [
    {
      &quot;typeId&quot;: 0,
      &quot;type&quot;: &quot;()&quot;,
      &quot;components&quot;: [],
      &quot;typeParameters&quot;: null
    },
    {
      &quot;typeId&quot;: 1,
      &quot;type&quot;: &quot;struct Addition&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;added_value&quot;,
          &quot;type&quot;: 3,
          &quot;typeArguments&quot;: null
        },
        {
          &quot;name&quot;: &quot;updated_total&quot;,
          &quot;type&quot;: 3,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;typeParameters&quot;: null
    },
    {
      &quot;typeId&quot;: 2,
      &quot;type&quot;: &quot;struct Subtraction&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;subtracted_value&quot;,
          &quot;type&quot;: 3,
          &quot;typeArguments&quot;: null
        },
        {
          &quot;name&quot;: &quot;updated_total&quot;,
          &quot;type&quot;: 3,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;typeParameters&quot;: null
    },
    {
      &quot;typeId&quot;: 3,
      &quot;type&quot;: &quot;u64&quot;,
      &quot;components&quot;: null,
      &quot;typeParameters&quot;: null
    }
  ],
  &quot;functions&quot;: [...],
  &quot;loggedTypes&quot;: [
    {
      &quot;logId&quot;: 0,
      &quot;loggedType&quot;: {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: 1,
        &quot;typeArguments&quot;: []
      }
    }
  ],
  &quot;messagesTypes&quot;: [...],
  &quot;configurables&quot;: [...]
}

</code></pre>
<h2 id="2-schema"><a class="header" href="#2-schema">2. Schema</a></h2>
<p>Now that we've discussed how to generate the JSON ABI for our Sway smart contract, let's now cover how to create an associated GraphQL schema.</p>
<p>To index the contracts and store information about our Sway types in the database, we should create a schema. Let's design a schema that has an entity for each Sway type:</p>
<pre><code class="language-graphql">type AddEntity @entity {
  id: ID!
  value: U64!
  updated_total: U64!
}

type SubtractEntity @entity {
  id: ID!
  value: U64!
  updated_total: U64!
}
</code></pre>
<blockquote>
<p>Note how the types used here, match the types used in our Sway smart contract. For a detailed mapping of these types, please see the <a href="indexing-custom-types/./../storing-records/index.html">Storing Records</a> section.</p>
</blockquote>
<h2 id="3-manifest"><a class="header" href="#3-manifest">3. Manifest</a></h2>
<p>So far we've covered how to (1) write your Sway smart contract and generate its JSON ABI, and (2) create types in your GraphQL schema that align with your Sway types.</p>
<p>Next, we'll cover how to write the manifest file for your indexer.</p>
<p>Before writing any of the handler code for your indexer, we need to make sure that our indexer manifest contains the necessary information to allow for the compiler to parse our contract types.</p>
<p>Specifically, we should ensure that the <code>contract_abi</code> and <code>graphql_schema</code> fields point to the correct locations, respectively.</p>
<pre><code class="language-yaml"># A namespace is a logical grouping of declared names. Think of the namespace
# as an organization identifier
namespace: fuellabs

# The identifier field is used to identify the given index.
identifier: custom_types_example

# The abi option is used to provide a link to the Sway JSON ABI that is generated when you
# build your project.
abi: path/to/custom/type/example/contract-abi.json

# The particular start block after which you'd like your indexer to start indexing events.
start_block: ~

# The particular end block after which you'd like your indexer to stop indexing events.
end_block: ~

# The `fuel_client` denotes the address (host, port combination) of the running Fuel client
# that you would like your indexer to index events from. In order to use this per-indexer
# `fuel_client` option, the indexer service at which your indexer is deployed will have to run
# with the `--indexer_net_config` option.
fuel_client: ~

# The contract_id specifies which particular contract you would like your index to subscribe to.
contract_id: ~

# The graphql_schema field contains the file path that points to the GraphQL schema for the
# given index.
graphql_schema: path/to/custom/type/example/indexer.schema.graphql

# The module field contains a file path that points to code that will be run as an executor inside
# of the indexer.
# Important: At this time, wasm is the preferred method of execution.
module:
  wasm: ~

# The resumable field contains a boolean that specifies whether or not the indexer should, synchronise
# with the latest block if it has fallen out of sync.
resumable: true
</code></pre>
<h2 id="4-handler-logic"><a class="header" href="#4-handler-logic">4. Handler Logic</a></h2>
<p>Finally, we can create handlers to index these particular types and store them in the database. Let's look at the following example:</p>
<pre><code class="language-rust  ignore">use fuel_indexer_utils::prelude::*;

#[indexer(manifest = &quot;indexer.manifest.yaml&quot;)]
mod indexer_mod {
    fn index_addition(addition_event: Addition) {
        let addition = AddEntity {
          id: 123,
          value: addition_event.added_value,
          updated_total: addition_event.updated_total
        };
        addition.save();
    }

    fn index_subtraction(subtraction_event: Subtraction) {
        let subtraction = SubtractEntity {
          id: 123,
          value: subtraction_event.subtracted_value,
          updated_total: subtraction_event.updated_total
        };
        subtraction.save();
    }
}</code></pre>
<p>Regardless of whether a custom type was logged (e.g. <code>Addition</code>) or returned (e.g. <code>Subtraction</code>), the type will be available for you to use in your functions. Just include the type(s) you want your function to use in the parameters, and the function will be executed whenever each of the parameters have been satisfied by an instance of the type(s).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storing-info-in-a-database"><a class="header" href="#storing-info-in-a-database">Storing Info in a Database</a></h1>
<p>The Fuel indexer uses <a href="https://github.com/docker-library/postgres/blob/2f6878ca854713264ebb27c1ba8530c884bcbca5/14/bullseye/Dockerfile">PostgreSQL</a> as the primary database.</p>
<blockquote>
<p>üí° We're open to supporting other storage solutions in the future.</p>
</blockquote>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>Below is a mapping of GraphQL schema types to their Sway and database equivalents. Note that an empty cell denotes that there is no direct equivalent for the type in the corresponding domain.</p>
<div class="table-wrapper"><table><thead><tr><th>GraphQL Scalar</th><th>Sway Type</th><th>Postgres Type</th></tr></thead><tbody>
<tr><td><code>Address</code></td><td><code>b256</code></td><td><code>varchar(64)</code></td></tr>
<tr><td><code>AssetId</code></td><td><code>u8[32]</code></td><td><code>varchar(64)</code></td></tr>
<tr><td><code>Boolean</code></td><td><code>bool</code></td><td><code>boolean</code></td></tr>
<tr><td><code>Bytes</code></td><td><code>str[]</code></td><td><code>varchar(10485760)</code></td></tr>
<tr><td><code>Bytes32</code></td><td><code>str[32]</code></td><td><code>varchar(64)</code></td></tr>
<tr><td><code>Bytes4</code></td><td><code>str[4]</code></td><td><code>varchar(8)</code></td></tr>
<tr><td><code>Bytes64</code></td><td><code>str[64]</code></td><td><code>varchar(128)</code></td></tr>
<tr><td><code>Bytes8</code></td><td><code>str[8]</code></td><td><code>varchar(16)</code></td></tr>
<tr><td><code>ContractId</code></td><td><code>b256</code></td><td><code>varchar(64)</code></td></tr>
<tr><td><code>I128</code></td><td></td><td><code>numeric(39,0)</code></td></tr>
<tr><td><code>I32</code></td><td><code>u32</code></td><td><code>integer</code></td></tr>
<tr><td><code>I64</code></td><td><code>u64</code></td><td><code>bigint</code></td></tr>
<tr><td><code>I8</code></td><td><code>u8</code></td><td><code>integer</code></td></tr>
<tr><td><code>ID</code></td><td></td><td><code>varchar(64) primary key</code></td></tr>
<tr><td><code>Json</code></td><td><code>str[]</code></td><td><code>json</code></td></tr>
<tr><td><code>U128</code></td><td></td><td><code>numeric(39, 0)</code></td></tr>
<tr><td><code>U32</code></td><td><code>u32</code></td><td><code>integer</code></td></tr>
<tr><td><code>U64</code></td><td><code>u64</code></td><td><code>numeric(20, 0)</code></td></tr>
<tr><td><code>U8</code></td><td><code>u8</code></td><td><code>integer</code></td></tr>
<tr><td><code>UID</code></td><td></td><td><code>varchar(64)</code></td></tr>
<tr><td><code>String</code></td><td><code>str[]</code></td><td><code>varchar(255)</code></td></tr>
</tbody></table>
</div>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>Let's define an <code>Event</code> struct in a Sway contract:</p>
<pre><code class="language-sway">struct Event {
    id: u64,
    address: Address,
    block_height: u64,
}
</code></pre>
<p>The corresponding GraphQL schema to mirror this <code>Event</code> struct would resemble:</p>
<pre><code class="language-graphql">type Event @entity {
    id: ID!
    account: Address!
    block_height: U64!
}
</code></pre>
<p>And finally, this GraphQL schema will generate the following Postgres schema:</p>
<pre><code class="language-text">                                           Table &quot;schema.event&quot;
    Column   |     Type    | Collation | Nullable | Default | Storage  | Compression | Stats target | Description
--------------+-------------+-----------+----------+---------+----------+-------------+--------------+-------------
 id           |    bigint   |           | not null |         | plain    |             |              |
 block_height |    bigint   |           | not null |         | plain    |             |              |
 address      | varchar(64) |           | not null |         | plain    |             |              |
 object       |    bytea    |           | not null |         | extended |             |              |
Indexes:
    &quot;event_pkey&quot; PRIMARY KEY, btree (id)
Access method: heap
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<ul>
<li><a href="querying/./basic-queries.html">Basic Queries</a></li>
<li><a href="querying/./pagination.html">Pagination</a></li>
<li><a href="querying/./search-and-filtering.html">Search &amp; Filtering</a></li>
<li><a href="querying/./full-example.html">Full Example</a></li>
<li><a href="querying/./playground.html">The GraphQL Playground</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries-1"><a class="header" href="#queries-1">Queries</a></h1>
<p>Once data has been persisted into your storage backend, you can retrieve it by querying the <a href="querying/../getting-started/indexer-service-infrastructure.html#web-api-server">GraphQL API server</a>. By default, the API server can be reached at <code>http://localhost:29987/api/graph/:namespace/:identifier</code>, where <code>:namespace</code> and <code>:identifier</code> are the values for the respective fields in your indexer's manifest. If you've changed the <code>WEB_API_HOST</code> or <code>WEB_API_PORT</code> values of your configuration, then you'll need to adjust the URL accordingly.</p>
<h2 id="basic-query"><a class="header" href="#basic-query">Basic Query</a></h2>
<p>A basic query has the following form:</p>
<pre><code class="language-graphql">query {
    entity {
        field_1
        field_2
        ...
    }
    ...
}
</code></pre>
<p>The <code>entity</code> field corresponds to the name of an entity defined in your <a href="querying/../project-components/schema.html">schema</a> and the sub-fields are the fields defined on that entity type; entities and fields are stored in the database using the names defined in the schema, so make sure that your query uses those same names as well.</p>
<pre><code class="language-txt">query {
    block {
        id
        height
        timestamp
    }
}
</code></pre>
<p>We're requesting the ID, height, and timestamp for each block stored in the backend. If successful, the API server will return a response similar to the following:</p>
<pre><code class="language-json">[
   {
      &quot;height&quot; : 1,
      &quot;id&quot; : &quot;f169a30cfcbf1eebd97a07b19de98e4b38a4367b03d1819943be41744339d38a&quot;,
      &quot;timestamp&quot; : 1668710162
   },
   {
      &quot;height&quot; : 2,
      &quot;id&quot; : &quot;a8c554758f78fe73054405d38099f5ad21a90c05206b5c6137424985c8fd10c7&quot;,
      &quot;timestamp&quot; : 1668710163
   },
   {
      &quot;height&quot; : 3,
      &quot;id&quot; : &quot;850ab156ddd9ac9502768f779936710fd3d792e9ea79bc0e4082de96450b5174&quot;,
      &quot;timestamp&quot; : 1668710312
   },
   {
      &quot;height&quot; : 4,
      &quot;id&quot; : &quot;19e19807c6988164b916a6877fe049d403d55a07324fa883cb7fa5cdb33438e2&quot;,
      &quot;timestamp&quot; : 1668710313
   },
   {
      &quot;height&quot; : 5,
      &quot;id&quot; : &quot;363af43cfd2a6d8af166ee46c15276b24b130fc6a89ce7b3c8737d29d6d0e1bb&quot;,
      &quot;timestamp&quot; : 1668710314
   }
]
</code></pre>
<h2 id="nested-query"><a class="header" href="#nested-query">Nested Query</a></h2>
<p>The Fuel indexer supports <a href="querying/../designing-a-schema/relationships.html">foreign keys</a> on entity types; thus, you can also ask for information about a referenced entity inside of your query. A nested query has the following general structure:</p>
<pre><code class="language-graphql">query {
    entityA {
        field_A1
        field_A2
        referenced_entityB {
            field_B1
            field_B2
            ...
        }
        ...
    }
    ...
}
</code></pre>
<p>Essentially, it's the same as the basic query example with an added sub-block to request information about the reference entity. The response from the API server will be returned in the same general structure as the query. Let's look at another example to illustrate how it works in practice.</p>
<blockquote>
<p>Important: There is no limit to how deeply nested your entities and queries can be. However, every nested reference <em><strong>will</strong></em> add computation and latency to your query as the information will have to be retrieved from different tables in your storage backend. Please exercise caution in your entity design and try to minimize nesting as much as possible.</p>
</blockquote>
<p>We'll start with the following example schema:</p>
<pre><code class="language-graphql">type City @entity {
    id: ID!
    name: String!
}

type Library @entity {
    id: ID!
    name: String!
    city: City!
}

type Book @entity {
    id: ID!
    title: String!
    library: Library!
}

type Character @entity {
    id: ID!
    name: String!
    book: Book!
}
</code></pre>
<p>This schema uses implicit foreign keys to reference other entities; for more information on implicit and explicit foreign keys, please refer to the <a href="querying/../designing-a-schema/relationships.html">Relationships</a> section of the book. In this contrived example, we're storing information about characters that are found in books which are stored in libraries that can be found in cities. This will be the query that we use to retrieve the aforementioned data:</p>
<pre><code class="language-graphql">query {
    character {
        name
        book {
            title
            library {
                name
                city {
                    name
                }
            }
        }
    }
}
</code></pre>
<p>Let's assume that we've created an indexer for this data and the indexed data has been stored in the database. If we send the query, we'll get the following response:</p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;Lil Ind X&quot;,
    &quot;book&quot;: {
      &quot;title&quot;: &quot;Fuel Indexer&quot;,
      &quot;library&quot;: {
        &quot;name&quot;: &quot;Fuel Labs Library&quot;,
        &quot;city&quot;: {
          &quot;name&quot;: &quot;Fuel City&quot;
        }
      }
    }
  }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-playground"><a class="header" href="#graphql-playground">GraphQL Playground</a></h1>
<p>The Fuel indexer's GraphQL Playground is an interactive, in-browser GraphQL IDE that allows developers to easily explore and test the indexer's GraphQL API server. You can read more about the GraphQL playground in general <a href="https://github.com/graphql/graphql-playground">here</a>.</p>
<p>Every public indexer can access the GraphQL playground of the Fuel indexer node on which the given indexer runs, so users and developers can get to querying their data right away.</p>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<p>To use the GraphQL playground to explore your indices, <a href="querying/../getting-started/indexer-service-infrastructure.html">start your indexer service</a>, then open the following URL in your browser - where <code>namespace</code> and <code>identifier</code> correspond to the namespace and identifier of the index that you'd like to explore.</p>
<pre><code class="language-bash">http://localhost:29987/api/playground/:namespace/:identifier
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-and-filtering"><a class="header" href="#search-and-filtering">Search and Filtering</a></h1>
<p>The Fuel indexer currently supports the following search and filtering operations:</p>
<ul>
<li>ID selection</li>
<li>comparison</li>
<li>set membership</li>
<li>excluding null values</li>
</ul>
<p>Additionally, you can combine these operations using the <code>and</code> or <code>or</code> keywords, and invert operations by using the <code>not</code> keyword.</p>
<blockquote>
<p>You should practice sensible database design when filtering records. Apply database indices to the underlying columns in order to make search operations more efficient; however, be advised that an overuse of database indices will lead to degraded performance.</p>
</blockquote>
<h2 id="id-selection"><a class="header" href="#id-selection">ID Selection</a></h2>
<p>You can query for a particular instance of an object by passing an ID value to with the <code>id</code> key. For example, let's say that you are storing blocks and you want details about a certain block, you would pass the corresponding ID:</p>
<pre><code class="language-graphql">query {
  block(id: 4121419699470229811) {
    id
    hash
    height
    producer
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;hash&quot;: &quot;aff5eb785f2d24ae62858fa673296e957abea518858e2f08bb47df2dbb9c8ca1&quot;,
      &quot;height&quot;: 8209,
      &quot;id&quot;: 4121419699470229811,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    }
  ]
}
</code></pre>
<blockquote>
<p>Note: Remember that IDs currently must be of type <code>u64</code>, and as such, the ID selection operation will only allow for a <code>u64</code> value. We're open to changing this in the future.</p>
</blockquote>
<h2 id="excluding-null-values"><a class="header" href="#excluding-null-values">Excluding Null Values</a></h2>
<p>You can store null values in your records if the corresponding entity fields are configured to allow for it. You can exclude records that contain null values in a particular column or set of columns by using the <code>has</code> operator inside of a <code>filter</code> object.</p>
<pre><code class="language-graphql">query {
  block(filter: { has: [producer] } ) {
    id
    hash
    height
    producer
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;hash&quot;: &quot;d0d663e0bf499aca19d3ecb9b0b291234dc3769d2b46512016eca7244ca0ef22&quot;,
      &quot;height&quot;: 411,
      &quot;id&quot;: 3775485677453992400,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;7ff79bf3793143c557225f37b7e7d8a2b9d2e544b839d62cc367b8c5b079d478&quot;,
      &quot;height&quot;: 412,
      &quot;id&quot;: 3919088689958184000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    }
  ]
}
</code></pre>
<h2 id="set-membership"><a class="header" href="#set-membership">Set Membership</a></h2>
<p>Additionally, you can exclude records in which a particular column's value does not contain any elements in a given set by using the <code>in</code> operator as part of a <code>filter</code> object.</p>
<pre><code class="language-graphql">query {
  block(filter: { height: { in: [1, 2, 3] } } ) {
    id
    hash
    height
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;hash&quot;: &quot;d77632f85669dd44737abf36b32f479ae518e07a9174c8571377ebb81563bb9a&quot;,
      &quot;height&quot;: 1,
      &quot;id&quot;: 3618468784755926500
    },
    {
      &quot;hash&quot;: &quot;7cb9542b624d88b3d66c6c9a1835f66fecba8892a87ffab9c17251c456ca5dcd&quot;,
      &quot;height&quot;: 2,
      &quot;id&quot;: 4122538829619016000
    },
    {
      &quot;hash&quot;: &quot;24f9611115f7ecb4a393751933a9f89329812cf08bdbe483c071b3401d06c8d6&quot;,
      &quot;height&quot;: 3,
      &quot;id&quot;: 3762867646901937000
    }
  ]
}
</code></pre>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>Finally, you can filter records by comparing the values of certain fields to a particular value of your choosing by using one of the comparison operators inside of a <code>filter</code> object.</p>
<h3 id="less-greater-and-equals"><a class="header" href="#less-greater-and-equals">Less, Greater, and Equals</a></h3>
<p>You can do simple value comparisons using any of the following operators:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>equals</td><td><code>equals</code></td></tr>
<tr><td>greater than</td><td><code>gt</code></td></tr>
<tr><td>greater than or equal to</td><td><code>gte</code></td></tr>
<tr><td>less than</td><td><code>lt</code></td></tr>
<tr><td>less than or equal to</td><td><code>lte</code></td></tr>
</tbody></table>
</div>
<p>Here's an example:</p>
<pre><code class="language-graphql">query {
  block(filter: { height: { lte: 5 } } ) {
    id
    hash
    height
    producer
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;hash&quot;: &quot;d77632f85669dd44737abf36b32f479ae518e07a9174c8571377ebb81563bb9a&quot;,
      &quot;height&quot;: 1,
      &quot;id&quot;: 3618468784755926500,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;7cb9542b624d88b3d66c6c9a1835f66fecba8892a87ffab9c17251c456ca5dcd&quot;,
      &quot;height&quot;: 2,
      &quot;id&quot;: 4122538829619016000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;24f9611115f7ecb4a393751933a9f89329812cf08bdbe483c071b3401d06c8d6&quot;,
      &quot;height&quot;: 3,
      &quot;id&quot;: 3762867646901937000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;616566afdc141ecd2b60fdc56aae4f3d04b3f6db9e65a3c21d0105a08cc1b349&quot;,
      &quot;height&quot;: 4,
      &quot;id&quot;: 3833467323683451000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;1dca838d492f29b7a3afa7755ac8741c99db992da47673cd27be86f9b0620118&quot;,
      &quot;height&quot;: 5,
      &quot;id&quot;: 3991987200693004000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    }
  ]
}
</code></pre>
<h3 id="between"><a class="header" href="#between">Between</a></h3>
<p>You can also filter for records that are contained in the range of two values by using the <code>between</code> operator. To do so, you'd set the lower bound using the <code>min</code> keyword and the upper bound by using <code>max</code>.</p>
<pre><code class="language-graphql">query {
  block(filter: { height: { between: { min: 101, max: 103 } } } ) {
    id
    hash
    height
    producer
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;hash&quot;: &quot;3b85fbed2d933d0334d54776612a5af72a513e875d06fa9152f6d41d0e50e417&quot;,
      &quot;height&quot;: 101,
      &quot;id&quot;: 3763145849079675000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;deea78034c2f0fcd7ef2d2d2d203d19fcd63f1b1846fac089c51c2aa7b5c8149&quot;,
      &quot;height&quot;: 102,
      &quot;id&quot;: 7365137137742930000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;a405d5688fdf41817868361217a09812349cc6fe0fe2bf9329fcd23e338e9444&quot;,
      &quot;height&quot;: 103,
      &quot;id&quot;: 7292000934927820000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    }
  ]
}
</code></pre>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<p>As previously stated, you can combine or invert operations to filter for your desired results even further.</p>
<h3 id="andor"><a class="header" href="#andor">And/Or</a></h3>
<p>Let's look at an example query in which we combine two filters together.</p>
<pre><code class="language-graphql">query {
  block(filter: { 
    producer: { equals: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot; },
    and: { height: { lt: 4 } }
  } ) {
    id
    hash
    height
    producer
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;hash&quot;: &quot;d77632f85669dd44737abf36b32f479ae518e07a9174c8571377ebb81563bb9a&quot;,
      &quot;height&quot;: 1,
      &quot;id&quot;: 3618468784755926500,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;7cb9542b624d88b3d66c6c9a1835f66fecba8892a87ffab9c17251c456ca5dcd&quot;,
      &quot;height&quot;: 2,
      &quot;id&quot;: 4122538829619016000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    },
    {
      &quot;hash&quot;: &quot;24f9611115f7ecb4a393751933a9f89329812cf08bdbe483c071b3401d06c8d6&quot;,
      &quot;height&quot;: 3,
      &quot;id&quot;: 3762867646901937000,
      &quot;producer&quot;: &quot;f65d6448a273b531ee942c133bb91a6f904c7d7f3104cdaf6b9f7f50d3518871&quot;
    }
  ]
}
</code></pre>
<h3 id="not"><a class="header" href="#not">Not</a></h3>
<p>You can also use the <code>not</code> operator in order to invert the operation of a particular filter. For example, the following query returns contracts that we've seen on the network.</p>
<pre><code class="language-graphql">query {
  contract {
    id
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;id&quot;: &quot;1072ca8fcab43048a5b31c1ea204748c2cb5acca6b90f3b1a02ef7a2d92386d9&quot;
    },
    {
      &quot;id&quot;: &quot;9b8b258e0d64b9e8a022e3f38a751ad5a1b36e4dfdcc25a6fb8308e044250b8c&quot;
    },
    {
      &quot;id&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
    },
    {
      &quot;id&quot;: &quot;8fe8ce43603c1a48274aac7532da56707901d9606a2b05de801993f48ea6bfe7&quot;
    }
  ]
}
</code></pre>
<p>Let's ignore the base asset contract by inverting the <code>in</code> operator:</p>
<pre><code class="language-graphql">query {
  contract(filter: {not: { id: { equals: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;}}}) {
    id
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [
    {
      &quot;id&quot;: &quot;1072ca8fcab43048a5b31c1ea204748c2cb5acca6b90f3b1a02ef7a2d92386d9&quot;
    },
    {
      &quot;id&quot;: &quot;9b8b258e0d64b9e8a022e3f38a751ad5a1b36e4dfdcc25a6fb8308e044250b8c&quot;
    },
    {
      &quot;id&quot;: &quot;8fe8ce43603c1a48274aac7532da56707901d9606a2b05de801993f48ea6bfe7&quot;
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagination"><a class="header" href="#pagination">Pagination</a></h1>
<p>The Fuel indexer currently supports offset-based pagination in order to allow users to selectively request parts of a set of results.</p>
<p>A paginated query can be made using three keywords:</p>
<ul>
<li><code>order</code> - sort order (required)</li>
<li><code>first</code> - limit on number of results (required)</li>
<li><code>offset</code> - the amount of records to skip before returning results (optional)</li>
</ul>
<pre><code class="language-graphql">query {
  blocks: block(order: { height: asc }, first: 5) {
    hash
    height
    timestamp
  }
}
</code></pre>
<p>In this query, we're requesting details about the first five blocks in ascending order of block height. You can also see that we've added a <code>blocks</code> alias; this is completely optional and all it does is change the key for the list of results in the JSON response.</p>
<p>With this query, we receive the following response:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;blocks&quot;: [
      {
        &quot;hash&quot;: &quot;d77632f85669dd44737abf36b32f479ae518e07a9174c8571377ebb81563bb9a&quot;,
        &quot;height&quot;: 1,
        &quot;timestamp&quot;: 1678483351
      },
      {
        &quot;hash&quot;: &quot;7cb9542b624d88b3d66c6c9a1835f66fecba8892a87ffab9c17251c456ca5dcd&quot;,
        &quot;height&quot;: 2,
        &quot;timestamp&quot;: 1678483471
      },
      {
        &quot;hash&quot;: &quot;24f9611115f7ecb4a393751933a9f89329812cf08bdbe483c071b3401d06c8d6&quot;,
        &quot;height&quot;: 3,
        &quot;timestamp&quot;: 1678483591
      },
      {
        &quot;hash&quot;: &quot;616566afdc141ecd2b60fdc56aae4f3d04b3f6db9e65a3c21d0105a08cc1b349&quot;,
        &quot;height&quot;: 4,
        &quot;timestamp&quot;: 1678483711
      },
      {
        &quot;hash&quot;: &quot;1dca838d492f29b7a3afa7755ac8741c99db992da47673cd27be86f9b0620118&quot;,
        &quot;height&quot;: 5,
        &quot;timestamp&quot;: 1678483831
      }
    ],
    &quot;page_info&quot;: {
      &quot;has_next_page&quot;: true,
      &quot;limit&quot;: 5,
      &quot;offset&quot;: 0,
      &quot;pages&quot;: 80,
      &quot;total_count&quot;: 400
    }
  }
}
</code></pre>
<p>As you can see, we get the requested amount of blocks and the corresponding fields. However, there's also a <code>page_info</code> object included in the response. This object tells us if there's another page available to request along with information that we can use to construct our next response. To get the next page, we'll add an <code>offset</code> to our original query:</p>
<pre><code class="language-graphql">query {
  blocks: block(
    order: { height: asc },
    first: 5,
    offset: 5
  ) {
    hash
    height
    timestamp
  }
}
</code></pre>
<p>The response contains the next five blocks <em>after</em> our requested offset, and the <code>page_info</code> object lets us know what offset we used in the query.</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;blocks&quot;: [
      {
        &quot;hash&quot;: &quot;c93ffc9178d526a836d707137de08b0f743fabce79ecec77c419bfb7e6be8863&quot;,
        &quot;height&quot;: 6,
        &quot;timestamp&quot;: 1678483951
      },
      {
        &quot;hash&quot;: &quot;4f0c81a42c86c718c0ae90ba838d6f1bdfc9a757cbf07c946fb3280b44257b46&quot;,
        &quot;height&quot;: 7,
        &quot;timestamp&quot;: 1678484071
      },
      {
        &quot;hash&quot;: &quot;659b486cc2c3bd1133df9245645648b6a09b35e16c7f71bb05449cea0e83611c&quot;,
        &quot;height&quot;: 8,
        &quot;timestamp&quot;: 1678484191
      },
      {
        &quot;hash&quot;: &quot;4bf61bd8f88b7fb40e842a6497d686bc2f63839ec3ca1eedb4e81a0935adaeb6&quot;,
        &quot;height&quot;: 9,
        &quot;timestamp&quot;: 1678484311
      },
      {
        &quot;hash&quot;: &quot;b090634788ddd0461cba4d0833a3f15b8e2f51e672fb1527fc8c78cd8f80dc1a&quot;,
        &quot;height&quot;: 10,
        &quot;timestamp&quot;: 1678484431
      }
    ],
    &quot;page_info&quot;: {
      &quot;has_next_page&quot;: true,
      &quot;limit&quot;: 5,
      &quot;offset&quot;: 5,
      &quot;pages&quot;: 80,
      &quot;total_count&quot;: 400
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-full-example"><a class="header" href="#a-full-example">A Full Example</a></h1>
<p>Finally, let's combine nested entities, filtering, and pagination into one complete example.</p>
<p>Sticking with the same block explorer example, let's say that we are looking for a particular transaction and its containing block, but we don't remember either of the hashes. All we know is that the total value of the transaction is greater than zero, it was sometime after the start of the <code>beta-5</code> testnet, and it was included as part of the first fifty blocks. Additionally, we don't want to parse through all the results at once, so we only want to look at two records at a time. Finally, we think that it may have been on the more recent side, so we want to check them in reverse chronological order.</p>
<p>Putting all of that together, we get the following query:</p>
<pre><code class="language-graphql">query {
  transactions: tx(
    order: { timestamp: desc },
    filter: { value: { gt: 0 } },
    first: 2,
    offset: 0
  ) {
    id
    hash
    timestamp
    value
    block (
      filter: { 
        height: { between: { min: 0, max: 50 } }, 
        and: { 
          timestamp: { gt: 1678410000 } 
        }
      } 
    ) {
      id
      hash
      height
      timestamp
    }
  }
}
</code></pre>
<p>The Fuel indexer's GraphQL API allows you to add filters on multiple entity fields and even nested entities! In the query above, we're asking for the two most recent transactions with a value greater than zero. Also, we're applying two filters to the nested <code>block</code> entity by using the <code>and</code> operator in order to help us narrow down the set of results.</p>
<p>The response returns the results in the expected format and includes additional information that informs us about how many total results satisfy the criteria.</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;page_info&quot;: {
      &quot;has_next_page&quot;: true,
      &quot;limit&quot;: 2,
      &quot;offset&quot;: 0,
      &quot;pages&quot;: 2,
      &quot;total_count&quot;: 4
    },
    &quot;transactions&quot;: [
      {
        &quot;block&quot;: {
          &quot;hash&quot;: &quot;f40297895086e66c0947c213dd29e90f596b860d10316ab806064608dd2580cd&quot;,
          &quot;height&quot;: 45,
          &quot;id&quot;: 7306026486395921000,
          &quot;timestamp&quot;: 1678486898
        },
        &quot;hash&quot;: &quot;85acfa181ebfa3b48c10d3181217918dd377b875d07dabc72d6d1081e4c52713&quot;,
        &quot;id&quot;: 3919319574514776000,
        &quot;timestamp&quot;: 1678486898,
        &quot;value&quot;: 10000000000
      },
      {
        &quot;block&quot;: {
          &quot;hash&quot;: &quot;e3e0860a358c0d044669748cffff82b4b0073baaca53a128ddc8ce3757ae3988&quot;,
          &quot;height&quot;: 41,
          &quot;id&quot;: 7018409465212200000,
          &quot;timestamp&quot;: 1678486633
        },
        &quot;hash&quot;: &quot;42f3fd7ffa073975a0eca993044a867d8c87a8d39f5a88032a3b9aba213f6102&quot;,
        &quot;id&quot;: 7364622549171910000,
        &quot;timestamp&quot;: 1678486633,
        &quot;value&quot;: 10000000000
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>The Fuel indexer's authentication functionality offers users a range of options for verifying their identity. The system supports any arbitrary authentication scheme (in theory); however, in practice the service defaults to JWT authentication due to its stateless nature and popularity.</p>
<p>To authenticate using JWT, users ask an indexer operator for a nonce, sign that nonce with their wallet, then send both the nonce and signature to the indexer operator for verification. Once the signature is verified on the backend, a valid JWT is produced and returned to the user, thus authenticating the user.</p>
<p>It is important to note that authentication is disabled by default. However, if authentication is enabled, users will need to authenticate before performing operations that involve modifying the state of the service, such as uploading indexers.</p>
<p>The new authentication functionality offers a flexible and secure way for users to authenticate and perform operations that affect the service's state.</p>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<p>Below is a demonstration of basic JWT authentication using an indexer operator at &quot;https://beta-5-indexer.fuel.network&quot;</p>
<pre><code class="language-bash">forc index auth --url https://beta-5-indexer.fuel.network:29987
</code></pre>
<p>You will first be prompted for the password for your wallet:</p>
<pre><code class="language-text">Please enter your wallet password:
</code></pre>
<p>After successfully entering your wallet password you should be presented with your new JWT token.</p>
<pre><code class="language-text">‚úÖ Successfully authenticated at https://beta-5-indexer.fuel.network:29987/api/auth/signature.

Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiODNlNjhiOTFmNDhjYWM4M....
</code></pre>
<p>Use this token in your <code>Authorization</code> headers when making requests for operations such as uploading indexers, stopping indexers, and other operations that mutate state in this way.</p>
<p>Users can just pass this JWT token value to the <code>--auth</code> flag, if using <code>forc index</code> commands that support authentication (e.g., <code>forc index deploy --auth $MY_JWT_TOKEN</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index"><a class="header" href="#forc-index">forc index</a></h1>
<p><code>forc index</code> is the recommended method for end users to interact with the Fuel indexer. After you have installed <code>fuelup</code>, you can run the <code>forc index help</code> command in your terminal to view the available commands.</p>
<pre><code class="language-text ignore">&lt;!-- markdownlint-disable MD033 --&gt;
&lt;!-- markdownlint-disable MD025 --&gt;
&lt;!-- markdownlint-disable MD041 --&gt;
&lt;p align=&quot;center&quot;&gt;
    &lt;picture&gt;
        &lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;./img/fuel-indexer-logo-dark.png&quot;&gt;
        &lt;img alt=&quot;Fuel Indexer logo&quot; width=&quot;400px&quot; src=&quot;./img/fuel-indexer-logo-light.png&quot;&gt;
    &lt;/picture&gt;

&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://github.com/FuelLabs/fuel-indexer/actions/workflows/ci.yml&quot; alt=&quot;CI&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/github/actions/workflow/status/FuelLabs/fuel-indexer/ci.yml?event=release&quot; /&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://docs.rs/fuel-indexer/&quot; alt=&quot;docs.rs&quot;&gt;
      &lt;img src=&quot;https://docs.rs/fuel-indexer/badge.svg&quot; /&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://crates.io/crates/fuel-indexer&quot; alt=&quot;crates.io&quot;&gt;
        &lt;img src=&quot;https://img.shields.io/crates/v/fuel-indexer?label=latest&quot; /&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://crates.io/crates/fuel-indexer&quot; alt=&quot;img-shields&quot;&gt;
      &lt;img alt=&quot;GitHub commits since latest release (by date including pre-releases)&quot; src=&quot;https://img.shields.io/github/commits-since/FuelLabs/fuel-indexer/latest?include_prereleases&quot;&gt;
    &lt;/a&gt;
    &lt;a href=&quot;https://discord.gg/xfpK4Pe&quot; alt=&quot;Discord&quot;&gt;
      &lt;img src=&quot;https://img.shields.io/badge/chat%20on-discord-orange?&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8&amp;labelColor=6A7EC2&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;

### [‚û°Ô∏è Read the Quickstart! ‚û°Ô∏è](https://docs.fuel.network/docs/indexer/getting-started/quickstart/)

## What is the Fuel indexer?

The Fuel indexer is a standalone service that can be used to index various components of the blockchain. These indexable components include blocks, transactions, receipts, and state within the Fuel network, allowing for high-performance read-only access to the blockchain for advanced dApp use-cases.

&gt; TLDR: It's Infrastructure as a service (IaaS) for Web3 dApp backends.

## Install

Fuel's indexer supports Linux (x64 &amp; arm64) and macOS (x64 &amp; Apple Silicon).

&gt; If you don't want to deal with dependency issues we recommend just using Fuel's indexer with Docker, [via the included docker-compose file](https://github.com/FuelLabs/fuel-indexer/blob/develop/scripts/docker-compose.yaml).

Install Fuel's toolchain manager - fuelup.

```bash
curl --proto '=https' --tlsv1.2 -sSf https://install.fuel.network/fuelup-init.sh | sh
</code></pre>
<blockquote>
<p>The <code>fuel-indexer</code> and <code>forc-index</code> binaries should now be available in your <code>$PATH</code></p>
</blockquote>
<h2 id="usage-7"><a class="header" href="#usage-7">Usage</a></h2>
<p>For development, users will primarily use the <code>forc index</code> command line utility made available after installing fuelup.</p>
<pre><code class="language-bash">forc index --help
</code></pre>
<pre><code class="language-text">forc index 0.0.0
Fuel Indexer Orchestrator

USAGE:
    forc-index &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    auth          Authenticate against an indexer service
    build         Build an indexer
    check         Check for Fuel indexer components
    deploy        Deploy an indexer to an indexer service
    help          Print this message or the help of the given subcommand(s)
    kill          Kill the indexer process. Note that this command will kill any process
                      listening on the default indexer port or the port specified by the `--port`
                      flag
    new           Create a new indexer project in a new directory
    postgres      Fuel Postgres Orchestrator
    remove        Stop and remove a running indexer
    start         Standalone binary for the Fuel indexer service
    status        Check the status of a registered indexer
</code></pre>
<h4 id="-for-more-details-on-how-to-build-fuel-indexers-read-the-docs-"><a class="header" href="#-for-more-details-on-how-to-build-fuel-indexers-read-the-docs-"><a href="https://docs.fuel.network/docs/indexer/">‚û°Ô∏è For more details on how to build Fuel indexers, read the docs! ‚û°Ô∏è</a></a></h4>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>If you're interested in contributing PRs to make the Fuel indexer a better project, feel free to read <a href="forc-index/./CONTRIBUTING.html">our contributors document</a>.</p>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-auth"><a class="header" href="#forc-index-auth"><code>forc index auth</code></a></h1>
<p>Authenticate against an indexer operator.</p>
<blockquote>
<p>IMPORTANT: There must be an indexer service running at <code>--url</code> in order for this to work.</p>
</blockquote>
<pre><code class="language-bash">forc index auth --account 0
</code></pre>
<pre><code class="language-text">Authenticate against an indexer service

USAGE:
    forc-index auth [OPTIONS]

OPTIONS:
        --account &lt;ACCOUNT&gt;    Index of account to use for signing. [default: 0]
    -h, --help                 Print help information
        --url &lt;URL&gt;            URL at which to deploy indexer assets. [default:
                               http://127.0.0.1:29987]
    -v, --verbose              Verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-build"><a class="header" href="#forc-index-build"><code>forc index build</code></a></h1>
<p>Build an indexer.</p>
<pre><code class="language-bash">forc index build
</code></pre>
<pre><code class="language-text">Build an indexer

USAGE:
    forc-index build [OPTIONS]

OPTIONS:
    -d, --debug                  Build artifacts with the debug profile.
    -h, --help                   Print help information
        --locked                 Ensure that the Cargo.lock file is up-to-date.
    -m, --manifest &lt;MANIFEST&gt;    Manifest file name of indexer being built.
    -p, --path &lt;PATH&gt;            Path to the indexer project.
    -v, --verbose                Enable verbose output.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-check"><a class="header" href="#forc-index-check"><code>forc index check</code></a></h1>
<p>Check to see which indexer components you have installed.</p>
<pre><code class="language-bash">forc index check
</code></pre>
<pre><code class="language-text">Check for Fuel indexer components

USAGE:
    forc-index check

OPTIONS:
    -h, --help    Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-deploy"><a class="header" href="#forc-index-deploy"><code>forc index deploy</code></a></h1>
<p>Deploy an indexer to an indexer service.</p>
<pre><code class="language-bash">forc index deploy --url https://beta-5-indexer.fuel.network
</code></pre>
<pre><code class="language-text">Deploy an indexer to an indexer service

USAGE:
    forc-index deploy [OPTIONS]

OPTIONS:
        --auth &lt;AUTH&gt;            Authentication header value.
    -d, --debug                  Build optimized artifacts with the debug profile.
    -h, --help                   Print help information
        --locked                 Ensure that the Cargo.lock file is up-to-date.
    -m, --manifest &lt;MANIFEST&gt;    Path to the manifest of indexer project being deployed.
    -p, --path &lt;PATH&gt;            Path to the indexer project.
        --remove-data            Remove all indexed data when replacing an existing indexer.
        --replace-indexer        If an indexer with the same UID exists, remove it.
        --skip-build             Do not build before deploying.
        --url &lt;URL&gt;              URL at which to deploy indexer assets. [default:
                                 http://127.0.0.1:29987]
    -v, --verbose                Enable verbose logging.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-kill"><a class="header" href="#forc-index-kill"><code>forc index kill</code></a></h1>
<p>Kill the indexer process. Note that this command will kill any process listening on the default indexer port or the port specified by the <code>--port</code> flag.</p>
<pre><code class="language-bash">forc index kill --port 29987
</code></pre>
<pre><code class="language-text">Kill the indexer process. Note that this command will kill any process listening on the default
indexer port or the port specified by the `--port` flag

USAGE:
    forc-index kill [OPTIONS]

OPTIONS:
    -9                   Terminate or kill
    -h, --help           Print help information
        --port &lt;PORT&gt;    Port at which to detect indexer service API is running. [default: 29987]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-new"><a class="header" href="#forc-index-new"><code>forc index new</code></a></h1>
<p>Create a new indexer project in a new directory.</p>
<pre><code class="language-bash">forc index new --namespace fuel /home/fuel/projects/example_indexer
</code></pre>
<pre><code class="language-text">Create a new indexer project in a new directory

USAGE:
    forc-index new [OPTIONS] &lt;PATH&gt;

ARGS:
    &lt;PATH&gt;    Path at which to create indexer

OPTIONS:
        --absolute-paths           Resolve indexer asset filepaths using absolute paths.
    -h, --help                     Print help information
        --name &lt;NAME&gt;              Name of indexer.
        --namespace &lt;NAMESPACE&gt;    Namespace to which indexer belongs.
    -v, --verbose                  Enable verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-remove"><a class="header" href="#forc-index-remove"><code>forc index remove</code></a></h1>
<p>Stop and remove a running indexer.</p>
<pre><code class="language-bash">forc index remove --url https://beta-5-indexer.fuel.network
</code></pre>
<pre><code class="language-text">Stop and remove a running indexer

USAGE:
    forc-index remove [OPTIONS]

OPTIONS:
        --auth &lt;AUTH&gt;            Authentication header value.
    -h, --help                   Print help information
    -m, --manifest &lt;MANIFEST&gt;    Path to the manifest of the indexer project being removed.
    -p, --path &lt;PATH&gt;            Path to the indexer project.
        --url &lt;URL&gt;              URL at which indexer is deployed. [default: http://127.0.0.1:29987]
    -v, --verbose                Enable verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-start"><a class="header" href="#forc-index-start"><code>forc index start</code></a></h1>
<p>Start a local Fuel Indexer service.</p>
<pre><code class="language-bash">forc index start
</code></pre>
<pre><code class="language-text">Standalone binary for the Fuel indexer service

USAGE:
    forc-index start [OPTIONS]

OPTIONS:
        --accept-sql-queries
            Allow the web server to accept raw SQL queries.

        --allow-non-sequential-blocks
            Allow missing blocks or non-sequential block processing.

        --auth-enabled
            Require users to authenticate for some operations.

        --auth-strategy &lt;AUTH_STRATEGY&gt;
            Authentication scheme used.

        --block-page-size &lt;BLOCK_PAGE_SIZE&gt;
            Amount of blocks to return in a request to a Fuel node. [default: 20]

    -c, --config &lt;FILE&gt;
            Indexer service config file.

        --client-request-delay &lt;CLIENT_REQUEST_DELAY&gt;
            Make the service wait for the given duration between block requests to a Fuel client.

        --database &lt;DATABASE&gt;
            Database type. [default: postgres] [possible values: postgres]

        --disable-toolchain-version-check
            By default, Fuel Indexer will only accept WASM indexer modules compiled with the same
            toolchain version as the version of Fuel Indexer.

        --embedded-database
            Automatically create and start database using provided options or defaults.

        --fuel-node-host &lt;FUEL_NODE_HOST&gt;
            Host of the running Fuel node. [default: localhost]

        --fuel-node-port &lt;FUEL_NODE_PORT&gt;
            Listening port of the running Fuel node. [default: 4000]

    -h, --help
            Print help information

        --indexer-net-config
            Allow network configuration via indexer manifests.

        --jwt-expiry &lt;JWT_EXPIRY&gt;
            Amount of time (seconds) before expiring token (if JWT scheme is specified).

        --jwt-issuer &lt;JWT_ISSUER&gt;
            Issuer of JWT claims (if JWT scheme is specified).

        --jwt-secret &lt;JWT_SECRET&gt;
            Secret used for JWT scheme (if JWT scheme is specified).

        --local-fuel-node
            Start a local Fuel node.

        --log-level &lt;LOG_LEVEL&gt;
            Log level passed to the Fuel Indexer service. [default: info] [possible values: info,
            debug, error, warn]

    -m, --manifest &lt;FILE&gt;
            Indexer config file.

        --max-body-size &lt;MAX_BODY_SIZE&gt;
            Max body size for web server requests. [default: 5242880]

        --metering-points &lt;METERING_POINTS&gt;
            The number of WASM opcodes after which the indexer's event handler will stop execution.
            [default: 30000000000]

        --metrics
            Use Prometheus metrics reporting.

        --network &lt;NETWORK&gt;
            Use a network alias when connecting to a Fuel client. [default: beta-3 beta-5 beta-5]

        --postgres-database &lt;POSTGRES_DATABASE&gt;
            Postgres database.

        --postgres-host &lt;POSTGRES_HOST&gt;
            Postgres host.

        --postgres-password &lt;POSTGRES_PASSWORD&gt;
            Postgres password.

        --postgres-port &lt;POSTGRES_PORT&gt;
            Postgres port.

        --postgres-user &lt;POSTGRES_USER&gt;
            Postgres username.

        --rate-limit
            Enable rate limiting.

        --rate-limit-request-count &lt;RATE_LIMIT_REQUEST_COUNT&gt;
            Maximum number of requests to allow over --rate-limit-window..

        --rate-limit-window-size &lt;RATE_LIMIT_WINDOW_SIZE&gt;
            Number of seconds over which to allow --rate-limit-rps.

        --remove-data
            When replacing an indexer, also remove the indexed data.

        --replace-indexer
            Whether to allow replacing an existing indexer. If not specified, an attempt to deploy
            over an existing indexer results in an error.

        --run-migrations
            Run database migrations before starting service.

        --stop-idle-indexers
            Prevent indexers from running without handling any blocks.

    -v, --verbose
            Enable verbose logging.

    -V, --version
            Print version information

        --web-api-host &lt;WEB_API_HOST&gt;
            Web API host. [default: localhost]

        --web-api-port &lt;WEB_API_PORT&gt;
            Web API port. [default: 29987]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-status"><a class="header" href="#forc-index-status"><code>forc index status</code></a></h1>
<p>Check the status of a registered indexer.</p>
<pre><code class="language-bash">forc index status --url https://beta-5-indexer.fuel.network
</code></pre>
<pre><code class="language-text">Check the status of a registered indexer

USAGE:
    forc-index status [OPTIONS]

OPTIONS:
        --auth &lt;AUTH&gt;    Authentication header value.
    -h, --help           Print help information
        --url &lt;URL&gt;      URL at which to find indexer service. [default: http://127.0.0.1:29987]
    -v, --verbose        Enable verbose logging.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres"><a class="header" href="#forc-index-postgres"><code>forc index postgres</code></a></h1>
<p><code>forc index postgres</code> is provided as a way to simplify the setup and management of an embedded Postgres database. After you have installed <code>fuelup</code>, you can run the <code>forc index postgres help</code> command in your terminal to view the available commands.</p>
<pre><code class="language-text">forc index postgres help
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    create    Create a new database
    drop      Drop a database
    help      Print this message or the help of the given subcommand(s)
    start     Start PostgreSQL with a database
    stop      Stop PostgreSQL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-create"><a class="header" href="#forc-index-postgres-create"><code>forc index postgres create</code></a></h1>
<p>Create a new database.</p>
<pre><code class="language-text">forc index postgres create example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres create [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
        --auth-method &lt;AUTH_METHOD&gt;
            Authentication method. [default: plain] [possible values: plain, md5, scram-sha-256]

    -c, --config &lt;CONFIG&gt;
            Fuel indexer configuration file.

        --database-dir &lt;DATABASE_DIR&gt;
            Where to store the PostgreSQL database.

    -h, --help
            Print help information

        --migration-dir &lt;MIGRATION_DIR&gt;
            The directory containing migration scripts.

    -p, --password &lt;PASSWORD&gt;
            Database password. [default: postgres]

    -p, --port &lt;PORT&gt;
            Port to use. [default: 5432]

        --persistent
            Do not clean up files and directories on database drop.

        --postgres-version &lt;POSTGRES_VERSION&gt;
            PostgreSQL version to use. [default: v14] [possible values: v15, v14, v13, v12, v11,
            v10, v9]

        --start
            Start the PostgreSQL instance after creation.

        --timeout &lt;TIMEOUT&gt;
            Duration to wait before terminating process execution for pg_ctl start/stop and initdb.

    -u, --user &lt;USER&gt;
            Database user. [default: postgres]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-drop"><a class="header" href="#forc-index-postgres-drop"><code>forc index postgres drop</code></a></h1>
<p>Drop a database.</p>
<pre><code class="language-text">forc index postgres drop example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres drop [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
    -c, --config &lt;CONFIG&gt;
            Fuel indexer configuration file.

        --database-dir &lt;DATABASE_DIR&gt;
            Where the PostgreSQL database is stored.

    -h, --help
            Print help information

        --remove-persisted
            Remove all database files that might have been persisted to disk.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-start"><a class="header" href="#forc-index-postgres-start"><code>forc index postgres start</code></a></h1>
<p>Start PostgreSQL with a database.</p>
<pre><code class="language-text">forc index postgres start example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres start [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
    -c, --config &lt;CONFIG&gt;                Fuel indexer configuration file.
        --database-dir &lt;DATABASE_DIR&gt;    Where the PostgreSQL database is stored.
    -h, --help                           Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-stop"><a class="header" href="#forc-index-postgres-stop"><code>forc index postgres stop</code></a></h1>
<p>Stop PostgreSQL.</p>
<pre><code class="language-text">forc index postgres stop example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres stop [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
    -c, --config &lt;CONFIG&gt;                Fuel indexer configuration file.
        --database-dir &lt;DATABASE_DIR&gt;    Where the PostgreSQL database is stored.
    -h, --help                           Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-contributors"><a class="header" href="#for-contributors">For Contributors</a></h1>
<p>Thanks for your interest in contributing to the Fuel indexer! Below we've compiled a list of sections that you may find useful as you work on a potential contribution:</p>
<ul>
<li><a href="for-contributors/index.html#dependencies">Dependencies</a>
<ul>
<li><a href="for-contributors/index.html#fuelup"><code>fuelup</code></a></li>
<li><a href="for-contributors/index.html#docker"><code>docker</code></a></li>
<li><a href="for-contributors/index.html#database">Database</a>
<ul>
<li><a href="for-contributors/index.html#postgresql">PostgreSQL</a></li>
</ul>
</li>
<li><a href="for-contributors/index.html#sqlx">SQLx</a></li>
</ul>
</li>
<li><a href="for-contributors/index.html#building-from-source">Building from source</a></li>
<li><a href="for-contributors/index.html#run-migrations">Run migrations</a></li>
<li><a href="for-contributors/index.html#start-the-service">Start the service</a></li>
<li><a href="for-contributors/index.html#testing">Testing</a>
<ul>
<li><a href="for-contributors/index.html#default-tests">Default tests</a></li>
<li><a href="for-contributors/index.html#end-to-end-tests">End-to-end tests</a></li>
<li><a href="for-contributors/index.html#trybuild-tests"><code>trybuild</code> tests</a></li>
</ul>
</li>
</ul>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<h3 id="fuelup"><a class="header" href="#fuelup"><code>fuelup</code></a></h3>
<p>We use fuelup in order to get the binaries produced by services in the Fuel ecosystem. Fuelup will install binaries related to the Fuel node, the Fuel indexer, the Fuel orchestrator (forc), and other components. <code>fuelup</code> can be downloaded <a href="https://github.com/FuelLabs/fuelup">here</a>.</p>
<h3 id="docker"><a class="header" href="#docker"><code>docker</code></a></h3>
<p>We use Docker to produce reproducible environments for users that may be concerned with installing components with large sets of dependencies (e.g. Postgres). Docker can be downloaded <a href="https://docs.docker.com/engine/install/">here</a>.</p>
<h3 id="database"><a class="header" href="#database">Database</a></h3>
<p>At this time, the Fuel indexer requires the use of a database. We currently support a single database option: Postgres. PostgreSQL is a database solution with a complex feature set and requires a database server.</p>
<h4 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h4>
<blockquote>
<p>Note: The following explanation is for demonstration purposes only. A production setup should use secure users, permissions, and passwords.</p>
</blockquote>
<p>On macOS systems, you can install PostgreSQL through Homebrew. If it isn't present on your system, you can install it according to the <a href="https://brew.sh/">instructions</a>. Once installed, you can add PostgreSQL to your system by running <code>brew install postgresql</code>. You can then start the service through <code>brew services start postgresql</code>. You'll need to create a database for your indexed data, which you can do by running <code>createdb [DATABASE_NAME]</code>. You may also need to create the <code>postgres</code> role; you can do so by running <code>createuser -s postgres</code>.</p>
<p>For Linux-based systems, the installation process is similar. First, you should install PostgreSQL according to your distribution's instructions. Once installed, there should be a new <code>postgres</code> user account; you can switch to that account by running <code>sudo -i -u postgres</code>. After you have switched accounts, you may need to create a <code>postgres</code> database role by running <code>createuser --interactive</code>. You will be asked a few questions; the name of the role should be <code>postgres</code> and you should elect for the new role to be a superuser. Finally, you can create a database by running <code>createdb [DATABASE_NAME]</code>.</p>
<p>In either case, your PostgreSQL database should now be accessible at <code>postgres://postgres@localhost:5432/[DATABASE_NAME]</code>.</p>
<h3 id="sqlx"><a class="header" href="#sqlx">SQLx</a></h3>
<p>After setting up your database, you should install <code>sqlx-cli</code> in order to run migrations for your indexer service. You can do so by running <code>cargo install sqlx-cli --features postgres</code>. Once installed, you can run the migrations by running the following command after changing <code>DATABASE_URL</code> to match your setup.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<h3 id="clone-repository"><a class="header" href="#clone-repository">Clone repository</a></h3>
<pre><code class="language-bash">git clone git@github.com:FuelLabs/fuel-indexer.git &amp;&amp; cd fuel-indexer/
</code></pre>
<h3 id="run-migrations"><a class="header" href="#run-migrations">Run migrations</a></h3>
<h4 id="postgres-migrations"><a class="header" href="#postgres-migrations">Postgres migrations</a></h4>
<pre><code class="language-sh">cd packages/fuel-indexer-database/postgres
DATABASE_URL=postgres://postgres@localhost sqlx migrate run
</code></pre>
<h3 id="start-the-service"><a class="header" href="#start-the-service">Start the service</a></h3>
<pre><code class="language-bash">cargo run --bin fuel-indexer run
</code></pre>
<p>You can also start the service with a fresh local node for development purposes:</p>
<pre><code class="language-bash">cargo run --features fuel-core-lib --bin fuel-indexer run
</code></pre>
<blockquote>
<p>If no configuration file or other options are passed, the service will default to a <code>postgres://postgres@localhost</code> database connection.</p>
</blockquote>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Fuel indexer tests are currently broken out by a database feature flag. In order to run tests with a Postgres backend, use <code>--features postgres</code>.</p>
<h3 id="default-tests"><a class="header" href="#default-tests">Default tests</a></h3>
<pre><code class="language-bash">cargo test --locked --workspace --all-targets
</code></pre>
<h3 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-end tests</a></h3>
<pre><code class="language-bash">cargo test --locked --workspace --all-targets --features postgres
</code></pre>
<h3 id="trybuild-tests"><a class="header" href="#trybuild-tests"><code>trybuild</code> tests</a></h3>
<p>For tests related to the meta-programming used in the Fuel indexer, we use <code>trybuild</code>.</p>
<pre><code class="language-bash">RUSTFLAGS='-D warnings' cargo test -p fuel-indexer-macros --locked
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-fuel-indexer"><a class="header" href="#contributing-to-fuel-indexer">Contributing to Fuel Indexer</a></h1>
<p>Thanks for your interest in contributing to Fuel Indexer! This document outlines some the conventions on building, running, and testing Fuel Indexer.</p>
<p>Fuel Indexer has many dependent repositories. If you need any help or mentoring getting started, understanding the codebase, or anything else, please ask on our <a href="https://discord.gg/xfpK4Pe">Discord</a>.</p>
<h2 id="code-standards"><a class="header" href="#code-standards">Code Standards</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
If you've added a new function, method, class or abstraction, please include <code>rustdoc</code> comments for the new code so others can better understand the change.</li>
<li><input disabled="" type="checkbox"/>
If your change is non-trivial and testable, please try to include at least one happy path test to ensure that your change works.
<ul>
<li>&quot;Trivial&quot; changes would be changes to docs, comments, or small style/syntactic changes</li>
</ul>
</li>
</ul>
<h3 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h3>
<blockquote>
<p>Future instructions assume you are in this repository</p>
</blockquote>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/fuel-indexer
cd fuel-indexer
</code></pre>
<h3 id="configuring-your-rust-toolchain"><a class="header" href="#configuring-your-rust-toolchain">Configuring your Rust toolchain</a></h3>
<p><code>rustup</code> is the official toolchain manager for Rust.</p>
<p>We use some additional components such as <code>clippy</code> and <code>rustfmt</code>, to install those:</p>
<pre><code class="language-sh">rustup component add clippy
rustup component add rustfmt
</code></pre>
<p>Fuel Indexer also uses a few other tools installed via <code>cargo</code></p>
<pre><code class="language-sh">cargo install sqlx-cli
cargo install wasm-snip
</code></pre>
<h3 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h3>
<p>Fuel Indexer's two primary crates are <code>fuel-indexer</code> and <code>fuel-indexer-api-server</code>.</p>
<p>You can build Fuel Indexer:</p>
<pre><code class="language-sh">cargo build -p fuel-indexer -p fuel-indexer-api-server --release --locked
</code></pre>
<p>Linting is done using <code>rustfmt</code> and <code>clippy</code>, which are each separate commands:</p>
<pre><code class="language-sh">cargo fmt --all --check
</code></pre>
<pre><code class="language-sh">cargo clippy --all-features --all-targets -- -D warnings
</code></pre>
<p>The test suite follows the Rust cargo standards.</p>
<p>Testing is simply done using Cargo:</p>
<pre><code class="language-sh">RUSTFLAGS='-D warnings' SQLX_OFFLINE=1 cargo test --locked --all-targets --all-features
</code></pre>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
We may discuss the problem and solution in the issue.
‚ö†Ô∏è <strong>DO NOT submit PRs that do not have an associated issue</strong> ‚ö†Ô∏è</li>
<li>Create a Git branch from where you want to base your work.
<ul>
<li>Most work is usually branched off of <code>develop</code></li>
<li>Give your branch a name related to the work you're doing
<ul>
<li>The convention for branch naming is usually <code>1234/short-description</code>, where <code>1234</code> is the number of the associated issue.</li>
</ul>
</li>
</ul>
</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>Your commit message should be formatted as <code>[commit type]: [short commit blurb]</code>
<ul>
<li>Examples:
<ul>
<li>If you fixed a bug, your message is <code>fix: database locking issue</code></li>
<li>If you added new functionality, your message would be <code>enhancement: i added something super cool</code></li>
<li>If you just did a chore your message is: <code>chore: i helped do the chores</code></li>
</ul>
</li>
<li>Keeping commit messages short and consistent helps users parse release notes</li>
</ul>
</li>
<li>Push up your branch to Github then (on the right hand side of the Github UI):
<ul>
<li>Assign yourself as the owner of the PR</li>
<li>Add any and all necessary labels to your PR</li>
<li>Link the issue your PR solves, to your PR</li>
</ul>
</li>
<li>If you are part of the FuelLabs Github org, please open a PR from the repository itself.</li>
<li>Otherwise, push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
<ul>
<li>Any changes to the branch will require a re-review.</li>
</ul>
</li>
</ul>
</li>
<li>Our CI (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<h3 id="commit-categories"><a class="header" href="#commit-categories">Commit categories</a></h3>
<ul>
<li><code>bug</code>: If fixing broken functionality</li>
<li><code>enhancement</code>: If adding new functionality</li>
<li><code>chore</code>: If finishing valuable work (that's no fun!)</li>
<li><code>testing</code>: If only updating/writing tests</li>
<li><code>docs</code>: If just updating docs</li>
<li><code>feat</code>: If adding a non-trivial new feature</li>
<li>There will be categories not covered in this doc - use your best judgement!</li>
</ul>
<p>Thanks for your contributions!</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>For beginners, we have prepared many suitable tasks for you. Checkout our <a href="https://github.com/FuelLabs/fuel-indexer/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Good First Issues</a> for a list.</p>
<p>If you are planning something that relates to multiple components or changes current behaviors, make sure to open an issue to discuss with us before continuing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-schedule"><a class="header" href="#release-schedule">Release Schedule</a></h1>
<p><a href="https://semver.org/">https://semver.org/</a></p>
<h2 id="major-releases"><a class="header" href="#major-releases">Major releases</a></h2>
<ul>
<li>E.g., <code>v2.0.0</code> -&gt; <code>v3.0.0</code></li>
<li>Major releases of large features and breaking changes.</li>
<li>Cadence: As needed.</li>
</ul>
<h2 id="minor-releases"><a class="header" href="#minor-releases">Minor releases</a></h2>
<ul>
<li>E.g., <code>v0.3.0</code> -&gt; <code>v0.4.0</code></li>
<li>General releases of new functionality, fixes, and some breaking changes.</li>
<li>Cadence: Roughly every two to three weeks.</li>
</ul>
<h2 id="patch-releases"><a class="header" href="#patch-releases">Patch releases</a></h2>
<ul>
<li>E.g., <code>v0.1.3</code> -&gt; <code>v0.1.4</code></li>
<li>Releases for bug fixes and time sensitive improvements.</li>
<li>Cadence: Ad-hoc as needed throughout the week.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-from-source-1"><a class="header" href="#building-from-source-1">Building from Source</a></h1>
<h2 id="clone-repository-1"><a class="header" href="#clone-repository-1">Clone repository</a></h2>
<pre><code class="language-bash">git clone git@github.com:FuelLabs/fuel-indexer.git
</code></pre>
<h2 id="run-migrations-1"><a class="header" href="#run-migrations-1">Run migrations</a></h2>
<pre><code class="language-bash">cd packages/fuel-indexer-database/postgres
DATABASE_URL=postgres://postgres@localhost sqlx migrate run
</code></pre>
<h2 id="start-the-service-1"><a class="header" href="#start-the-service-1">Start the service</a></h2>
<pre><code class="language-bash">cargo run --bin fuel-indexer
</code></pre>
<h2 id="run-tests"><a class="header" href="#run-tests">Run tests</a></h2>
<pre><code class="language-txt">cargo test --locked --workspace --all-features --all-targets
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h1>
<p>There are a few system requirements related to compilation, tooling, and SQL backends that you'll need to be able to contribute to the Fuel indexer.</p>
<h2 id="ubuntudebian"><a class="header" href="#ubuntudebian">Ubuntu/Debian</a></h2>
<pre><code class="language-bash">apt update &amp;&amp; apt install -y \
    cmake \
    pkg-config \
    git \
    gcc \
    build-essential \
    clang \
    libclang-dev \
    llvm \
    libpq-dev
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Dependency</th><th>Required For</th></tr></thead><tbody>
<tr><td><code>cmake</code></td><td>Manages the build process in an operating system and in a compiler-independent manner</td></tr>
<tr><td><code>pkg-config</code></td><td>Language-agnostic helper tool used when compiling applications and libraries</td></tr>
<tr><td><code>git</code></td><td>Version control system</td></tr>
<tr><td><code>gcc</code></td><td>Compiler tools required to build various Fuel indexer crates</td></tr>
<tr><td><code>clang</code>/<code>libclang-dev</code></td><td>Compiler tools required to build various Fuel indexer crates on Unix-like OSes</td></tr>
<tr><td><code>llvm</code></td><td>Required for building Fuel indexer crate dependencies</td></tr>
<tr><td><code>libpq-dev</code></td><td>Set of library function helping facilitate interaction with the PostgreSQL backend</td></tr>
</tbody></table>
</div>
<h2 id="macos-1"><a class="header" href="#macos-1">MacOS</a></h2>
<pre><code class="language-bash">brew update &amp;&amp; brew install \
    cmake \
    llvm \
    libpq \
    postgresql
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Dependency</th><th>Required For</th></tr></thead><tbody>
<tr><td><code>cmake</code></td><td>Manages the build process in an operating system and in a compiler-independent manner</td></tr>
<tr><td><code>llvm</code></td><td>Compiler infrastructure for building Fuel indexer crate dependencies</td></tr>
<tr><td><code>libpq</code></td><td>Postgres C API library</td></tr>
<tr><td><code>postgresql</code></td><td>Installs the command line console (<code>psql</code>) as well as a PostgreSQL server locally</td></tr>
</tbody></table>
</div>
<h2 id="arch"><a class="header" href="#arch">Arch</a></h2>
<pre><code class="language-bash">pacman -Syu --needed --noconfirm \
    cmake \
    gcc \
    pkgconf \
    git \
    clang \
    llvm11 \
    llvm11-libs \
    postgresql-libs
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Dependency</th><th>Required For</th></tr></thead><tbody>
<tr><td><code>cmake</code></td><td>Manages the build process in an operating system and in a compiler-independent manner</td></tr>
<tr><td><code>git</code></td><td>Version control system</td></tr>
<tr><td><code>gcc</code></td><td>Compiler tools required to build various Fuel indexer crates</td></tr>
<tr><td><code>llvm11</code></td><td>Compiler infrastructure for building Fuel indexer crate dependencies</td></tr>
<tr><td><code>llvm11-libs</code></td><td>Compiler infrastructure libraries for building Fuel indexer crate dependencies</td></tr>
<tr><td><code>pkgconf</code></td><td>System for configuring build dependency information</td></tr>
<tr><td><code>postgresql-libs</code></td><td>Provides the essential shared libraries for any PostgreSQL client program or interface</td></tr>
<tr><td><code>clang</code></td><td>Compiler required to build various Fuel indexer crates Unix-like OSes</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>Here is a list of terms and their definitions in order to help users properly understand certain concepts about the Fuel indexer.</p>
<ul>
<li><code>asset</code>: a component that is used to create and operate an indexer</li>
<li><code>executor</code>: an async task run by an indexer</li>
<li><code>index</code>/<code>indices</code>: data produced by an indexer</li>
<li><code>indexer service</code>: a service that runs one or more indexers</li>
<li><code>indexer</code>: an abstraction that takes data from Fuel virtual machine and produces indices</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
