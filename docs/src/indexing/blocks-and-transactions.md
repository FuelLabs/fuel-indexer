# Blocks and Transactions

You can use the `BlockData` and `TransactionData` data structures to index important information about the Fuel network for your dApp.

## `BlockData`

> The `BlockData` struct is how blocks are represented in the Fuel indexer. It contains metadata such as the ID, height, and time, as well as a list of the transactions it contains (represented by `TransactionData`). It also contains the public key hash of the block producer, if present.

### Definition

```rust,ignore
pub struct BlockData {
    pub height: u32,
    pub id: Bytes32,
    pub header: Header,
    pub producer: Option<Bytes32>,
    pub time: i64,
    pub consensus: Consensus,
    pub transactions: Vec<TransactionData>,
}
```

### Usage

```rust,ignore
extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = "my_indexer.manifest.yaml")]
mod my_indexer {
    fn handle_block(block_data: BlockData) {
        let height = block_data.header.height;
        info!("This block #{height}");
    }
}
```

---

## `TransactionData`

> The `TransactionData` struct contains important information about a transaction in the Fuel network. The `id` field is the transaction hash, which is a 32-byte string. The `receipts` field contains a list of `Receipts`, which are generated by a Fuel node during the execution of a Sway smart contract; you can find more information in the [Receipts](./receipts.md) section.

### Definition

```rust,ignore
pub struct TransactionData {
    pub transaction: Transaction,
    pub status: TransactionStatus,
    pub receipts: Vec<Receipt>,
    pub id: TxId,
}
```

### Usage

```rust,ignore
extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = "my_indexer.manifest.yaml")]
mod my_indexer {
    fn handle_transaction(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            info!("Transaction {} in block at height {} has {} receipts", transaction.id, block_data.header.height, transaction.receipts.len());
        }

    }
}
```

---

### `Transaction`

> `Transaction` refers to the Fuel transaction entity and can be one of three distinct types: `Script`, `Create`, or `Mint`. Explaining the differences between each of the types is out of scope for the Fuel indexer; however, you can find information about the `Transaction` type in the [Fuel specifications](https://specs.fuel.network/master/tx-format/transaction.html).

### Definition

```rust,ignore
pub enum Transaction {
    Script(Script),
    Create(Create),
    Mint(Mint),
}
```

### Usage

```rust,ignore
extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = "my_indexer.manifest.yaml")]
mod my_indexer {
    fn handle_transaction(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            match transaction.transaction {
                fuel::Transaction::Script(tx) => {
                    info!("We found a script transaction!");
                }
                fuel::Transaction::Create(tx) => {
                    info!("We found a create transaction!");
                }
                fuel::Transaction::Mint(tx) => {
                    info!("We found a mint transaction!");
                }
            }
        }

    }
}
```

---

### `TransactionStatus`

> `TransactionStatus` refers to the status of a `Transaction` in the Fuel network.

### Definition

```rust,ignore
pub enum TransactionStatus {
    Failure {
        block_id: String,
        time: DateTime<Utc>,
        reason: String,
    },
    SqueezedOut {
        reason: String,
    },
    Submitted {
        submitted_at: DateTime<Utc>,
    },
    Success {
        block_id: String,
        time: DateTime<Utc>,
    },
}
```

### Usage 

```rust,ignore
extern crate alloc;
use fuel_indexer_utils::prelude::*;

#[indexer(manifest = "my_indexer.manifest.yaml")]
mod my_indexer {
    fn handle_transaction(block_data: BlockData) {
        let height = block_data.header.height;
        if !block_data.transactions.is_empty() {
            let transaction = block_data.transactions[0];
            match transaction.transaction {
                fuel::Transaction::Script(tx) => {
                    match tx.status {
                        fuel::TransactionStatus::Success {
                            block_id, time
                        } => {
                            info!("Transaction {} in block {} was successful at {}", tx.id, block_id, time);
                        }
                    }
                }
                _ => {
                    info!("We don't care about this transaction type");
                }
            }
        }

    }
}
```
