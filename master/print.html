<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fuel Indexer Service</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="the-fuel-indexer.html">The Fuel Indexer</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="getting-started/dependencies/index.html"><strong aria-hidden="true">1.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/dependencies/fuelup.html"><strong aria-hidden="true">1.1.</strong> fuelup</a></li><li class="chapter-item expanded "><a href="getting-started/dependencies/database.html"><strong aria-hidden="true">1.2.</strong> Database</a></li><li class="chapter-item expanded "><a href="getting-started/dependencies/wasm.html"><strong aria-hidden="true">1.3.</strong> WASM</a></li></ol></li><li class="chapter-item expanded "><a href="quickstart/index.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="getting-started/starting-the-fuel-indexer.html"><strong aria-hidden="true">3.</strong> Starting the Fuel Indexer</a></li><li class="chapter-item expanded affix "><li class="part-title">Examples</li><li class="chapter-item expanded "><a href="examples/hello-world.html"><strong aria-hidden="true">4.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="examples/block-explorer.html"><strong aria-hidden="true">5.</strong> Block Explorer</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="reference-guide/components/fuel-indexer-project.html"><strong aria-hidden="true">6.</strong> A Fuel Indexer Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/components/assets/manifest.html"><strong aria-hidden="true">6.1.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="reference-guide/components/assets/schema.html"><strong aria-hidden="true">6.2.</strong> Schema</a></li><li class="chapter-item expanded "><a href="reference-guide/components/assets/module.html"><strong aria-hidden="true">6.3.</strong> Module</a></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/indexing/what-can-i-index.html"><strong aria-hidden="true">7.</strong> What Can I Index?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/indexing/blocks-and-transactions.html"><strong aria-hidden="true">7.1.</strong> Blocks and Transactions</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts.html"><strong aria-hidden="true">7.2.</strong> Receipts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/call.html"><strong aria-hidden="true">7.2.1.</strong> Call</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/log.html"><strong aria-hidden="true">7.2.2.</strong> Log</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/logdata.html"><strong aria-hidden="true">7.2.3.</strong> LogData</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/messageout.html"><strong aria-hidden="true">7.2.4.</strong> MessageOut</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/panic.html"><strong aria-hidden="true">7.2.5.</strong> Panic</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/return.html"><strong aria-hidden="true">7.2.6.</strong> Return</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/returndata.html"><strong aria-hidden="true">7.2.7.</strong> ReturnData</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/revert.html"><strong aria-hidden="true">7.2.8.</strong> Revert</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/scriptresult.html"><strong aria-hidden="true">7.2.9.</strong> ScriptResult</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/transfer.html"><strong aria-hidden="true">7.2.10.</strong> Transfer</a></li><li class="chapter-item expanded "><a href="reference-guide/indexing/receipts/transferout.html"><strong aria-hidden="true">7.2.11.</strong> TransferOut</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/data-types/types.html"><strong aria-hidden="true">8.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="reference-guide/components/graphql/index.html"><strong aria-hidden="true">9.</strong> GraphQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/components/graphql/schema.html"><strong aria-hidden="true">9.1.</strong> Schema</a></li><li class="chapter-item expanded "><a href="reference-guide/components/graphql/directives.html"><strong aria-hidden="true">9.2.</strong> Directives</a></li><li class="chapter-item expanded "><a href="reference-guide/components/graphql/api-server.html"><strong aria-hidden="true">9.3.</strong> API Server</a></li><li class="chapter-item expanded "><a href="reference-guide/components/graphql/playground.html"><strong aria-hidden="true">9.4.</strong> Playground</a></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/components/database/index.html"><strong aria-hidden="true">10.</strong> Database</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/components/database/foreign-keys.html"><strong aria-hidden="true">10.1.</strong> Foreign Keys</a></li><li class="chapter-item expanded "><a href="reference-guide/components/database/ids.html"><strong aria-hidden="true">10.2.</strong> ID Types</a></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/plugins/index.html"><strong aria-hidden="true">11.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/index.html"><strong aria-hidden="true">11.1.</strong> forc index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/init.html"><strong aria-hidden="true">11.1.1.</strong> init</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/new.html"><strong aria-hidden="true">11.1.2.</strong> new</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/check.html"><strong aria-hidden="true">11.1.3.</strong> check</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/build.html"><strong aria-hidden="true">11.1.4.</strong> build</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/start.html"><strong aria-hidden="true">11.1.5.</strong> start</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/deploy.html"><strong aria-hidden="true">11.1.6.</strong> deploy</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/remove.html"><strong aria-hidden="true">11.1.7.</strong> remove</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/auth.html"><strong aria-hidden="true">11.1.8.</strong> auth</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-index/revert.html"><strong aria-hidden="true">11.1.9.</strong> revert</a></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-postgres/index.html"><strong aria-hidden="true">11.2.</strong> forc index postgres</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-postgres/create.html"><strong aria-hidden="true">11.2.1.</strong> create</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-postgres/start.html"><strong aria-hidden="true">11.2.2.</strong> start</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-postgres/stop.html"><strong aria-hidden="true">11.2.3.</strong> stop</a></li><li class="chapter-item expanded "><a href="reference-guide/plugins/forc-postgres/drop.html"><strong aria-hidden="true">11.2.4.</strong> drop</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference-guide/authentication/index.html"><strong aria-hidden="true">12.</strong> Authentication</a></li><li class="chapter-item expanded affix "><li class="part-title">For Contributors</li><li class="chapter-item expanded "><a href="for-contributors/index.html"><strong aria-hidden="true">13.</strong> Environment Setup</a></li><li class="chapter-item expanded "><a href="for-contributors/contributing-standards.html"><strong aria-hidden="true">14.</strong> Contributing Standards</a></li><li class="chapter-item expanded "><a href="for-contributors/release-schedule.html"><strong aria-hidden="true">15.</strong> Release Schedule</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">16.</strong> A: Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Fuel Indexer Service</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/fuel-indexer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- markdownlint-disable MD033 -->
<h1 id="-fuel-indexer"><a class="header" href="#-fuel-indexer">üóÉ Fuel Indexer</a></h1>
<p>The Fuel indexer is a standalone service that can be used to index various components of the blockchain. These indexable components include blocks, transactions, receipts, and state within the Fuel network, allowing for high-performance read-only access to the blockchain for advanced dApp use-cases.</p>
<p>By using a combination of Fuel-flavored GraphQL schema, a SQL backend, and indexers written in Rust, users of the Fuel indexer can get started creating production-ready backends for their dApps, meant to go fast üöóüí®.</p>
<p>For those wanting to build dApp backends right away, feel free to check out the <a href="./quickstart/index.html">Quickstart</a>. And for those willing to contribute to the Fuel indexer project, please feel free to read <a href="https://github.com/FuelLabs/fuel-indexer/blob/master/docs/CONTRIBUTING.md">our contributor guidelines</a> as well as the <a href="for-contributors/index.html">For Contributors</a> chapter of the book.</p>
<!-- KEEP THIS IN CASE WE WANT TO MAKE DIAGRAM CHANGES [![fo](https://mermaid.ink/img/pako:eNp9kWFrwjAQhv_KcZ8U9A-UIajZhrDBZkUYjR9uzamFNqlpAhbrf1-6TFCY5r6EN-9zb7g7YW4UY4I7S_UeVkJqCGeavXguYW4sb2A8nnTrd0gdOe5gNvh9WmjFR7bD6J9l12JEXvuOn2-wamtuOhADQY6-qeE_Zn7DwMU-_VhEPi12msrmTuIjGp56fskHz437L1pkF2EThefsy3h7-_-tsTkUvQKK69K03aNQqa8LR1ixrahQYbSnPkOi23PFEpNwVbwlXzqJUp-DlbwzaatzTJz1PEJfqzBqUVBYShXF8w9dz4xz?type=png)](https://mermaid.live/edit#pako:eNp9kWFrwjAQhv_KcZ8U9A-UIajZhrDBZkUYjR9uzamFNqlpAhbrf1-6TFCY5r6EN-9zb7g7YW4UY4I7S_UeVkJqCGeavXguYW4sb2A8nnTrd0gdOe5gNvh9WmjFR7bD6J9l12JEXvuOn2-wamtuOhADQY6-qeE_Zn7DwMU-_VhEPi12msrmTuIjGp56fskHz437L1pkF2EThefsy3h7-_-tsTkUvQKK69K03aNQqa8LR1ixrahQYbSnPkOi23PFEpNwVbwlXzqJUp-DlbwzaatzTJz1PEJfqzBqUVBYShXF8w9dz4xz) -->
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<!-- Using an <img> so we can size it -->
<img src="https://i.imgur.com/8K14p9h.png" alt="diagram" width="500"/>
<p>The Fuel indexer is meant to run alongside a Fuel node and a database. Generally, the typical flow of information through the indexer is as follows:</p>
<ol>
<li>A Sway smart contract emits receipts during its execution on the Fuel node.</li>
<li>Blocks, transactions, and receipts from the node are monitored by the Fuel indexer service and checked for specific user-defined event types.</li>
<li>When a specific event type is found, an indexer executes the corresponding handler from its module.</li>
<li>The handler processes the event and stores the indexed information in the database.</li>
<li>A dApp queries for blockchain data by using the indexer's GraphQL API endpoint, which fetches the desired information from the corresponding index in the database and returns it to the user.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>To run the Fuel indexer, you'll need to install a few dependencies on your system:</p>
<ul>
<li><a href="getting-started/dependencies/./fuelup.html"><code>fuelup</code></a>, the Fuel toolchain manager</li>
<li>a supported <a href="getting-started/dependencies/./database.html">database</a>
<ul>
<li>We support Postgres at this time</li>
</ul>
</li>
<li>the <a href="getting-started/dependencies/./wasm.html"><code>wasm32-unknown-unknown</code></a> Rust compilation target</li>
<li><a href="getting-started/dependencies/./wasm.html"><code>wasm-snip</code></a>, a utility for trimming WebAssembly binaries</li>
</ul>
<p>If you don't want to install a database directly onto your system, you can use Docker to run it as an isolated container. You can install it by following the <a href="https://docs.docker.com/get-docker/">install instructions</a>. For reference purposes, we provide a <a href="https://github.com/FuelLabs/fuel-indexer/blob/master/scripts/docker-compose.yaml"><code>docker compose</code> file</a> that runs a Postgres database and the Fuel indexer service.</p>
<blockquote>
<p>Note for Apple Silicon macOS users: Using the Fuel indexer through Docker on Apple Silicon systems is currently not supported. We're working to bring support to these systems.</p>
</blockquote>
<p>Also, it's assumed that you have the Rust programming language installed on your system. If that is not the case, please refer to the <a href="https://www.rust-lang.org/tools/install">Rust installation instructions</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuelup"><a class="header" href="#fuelup"><code>fuelup</code></a></h1>
<p>We strongly recommend that you use the Fuel indexer through <a href="https://fuellabs.github.io/sway/master/forc/index.html"><code>forc</code>, the Fuel orchestrator</a>. You can get <code>forc</code> (and other Fuel components) by way of <a href="https://fuellabs.github.io/fuelup/latest"><code>fuelup</code>, the Fuel toolchain manager</a>. Install <code>fuelup</code> by running the following command, which downloads and runs the installation script.</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://install.fuel.network/fuelup-init.sh | sh
</code></pre>
<p>After <code>fuelup</code> has been installed, the <code>forc index</code> command and <code>fuel-indexer</code> binaries will be available on your system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>At this time, the Fuel indexer requires the use of a database. We currently support a single database option: PostgresSQL. PostgreSQL is a database solution with a complex feature set and requires a database server.</p>
<h2 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h2>
<blockquote>
<p>Note: The following explanation is for demonstration purposes only. For an even faster setup on some platforms, you can use the <a href="getting-started/dependencies/../../reference-guide/plugins/forc-postgres/index.html">forc index postgres</a> command. <em>A production setup should use secure users, permissions, and passwords.</em></p>
</blockquote>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>On macOS systems, you can install PostgreSQL through Homebrew. If it isn't present on your system, you can install it according to the <a href="https://brew.sh/">instructions</a>. Once installed, you can add PostgreSQL to your system by running <code>brew install postgresql</code>. You can then start the service through <code>brew services start postgresql</code>. You'll need to create a database for your index data, which you can do by running <code>createdb [DATABASE_NAME]</code>. You may also need to create the <code>postgres</code> role; you can do so by running <code>createuser -s postgres</code>.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>For Linux-based systems, the installation process is similar. First, you should install PostgreSQL according to your distribution's instructions. Once installed, there should be a new <code>postgres</code> user account; you can switch to that account by running <code>sudo -i -u postgres</code>. After you have switched accounts, you may need to create a <code>postgres</code> database role by running <code>createuser --interactive</code>. You will be asked a few questions; the name of the role should be <code>postgres</code> and you should elect for the new role to be a superuser. Finally, you can create a database by running <code>createdb [DATABASE_NAME]</code>.</p>
<p>In either case, your PostgreSQL database should now be accessible at <code>postgres://postgres@localhost:5432/[DATABASE_NAME]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm"><a class="header" href="#wasm">WASM</a></h1>
<p>Two additonal cargo components will be required to build your indexers: <code>wasm-snip</code> and the <code>wasm32-unknown-unknown</code> target.</p>
<blockquote>
<p>As of this writing, there is a small bug in newly built Fuel indexer WASM modules that produces a WASM runtime error due an errant upstream dependency. For now, you can use <code>wasm-snip</code> to remove the errant symbols from the WASM module. An example can be found in the related script <a href="https://github.com/FuelLabs/fuel-indexer/blob/master/scripts/stripper.bash">here</a>.</p>
</blockquote>
<h2 id="wasm-snip"><a class="header" href="#wasm-snip"><code>wasm-snip</code></a></h2>
<p>To install the <code>wasm-snip</code>:</p>
<pre><code class="language-bash">cargo install wasm-snip
</code></pre>
<h2 id="wasm32-target"><a class="header" href="#wasm32-target"><code>wasm32</code> target</a></h2>
<p>To install the <code>wasm32-unknown-unknown</code> target via <code>rustup</code>:</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<blockquote>
<p>Note for Apple Silicon macOS users: Due to the default architecture-specific libraries that are shipped with macOS, you may have trouble building WASM binaries. Please refer to <a href="getting-started/dependencies/../../reference-guide/components/assets/module.html#notes-on-wasm">this section</a> of the <em>Module</em> page for more information.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>In this tutorial you will:</p>
<ol>
<li>Bootstrap your development environment.</li>
<li>Create, build, and deploy an indexer to an indexer service hooked up to Fuel's <code>beta-3</code> testnet.</li>
<li>Query your newly created index for data using GraphQL.</li>
</ol>
<h2 id="1-setting-up-your-environment"><a class="header" href="#1-setting-up-your-environment">1. Setting up your environment</a></h2>
<p>In this Quickstart, we'll use Fuel's toolchain manager <a href="https://github.com/FuelLabs/fuelup"><code>fuelup</code></a> in order to install the <code>forc-index</code> component that we'll use to develop our indexer.</p>
<h3 id="11-install-fuelup"><a class="header" href="#11-install-fuelup">1.1 Install <code>fuelup</code></a></h3>
<p>To install fuelup with the default features/options, use the following command to download the fuelup installation script and run it interactively.</p>
<pre><code class="language-bash">curl \
  --proto '=https' \
  --tlsv1.2 -sSf https://fuellabs.github.io/fuelup/fuelup-init.sh | sh
</code></pre>
<blockquote>
<p>If you require a non-default <code>fuelup</code> installation, please <a href="https://github.com/FuelLabs/fuelup">read the <code>fuelup</code> installation docs.</a></p>
</blockquote>
<h3 id="12-webassembly-wasm-setup"><a class="header" href="#12-webassembly-wasm-setup">1.2 WebAssembly (WASM) Setup</a></h3>
<p>Indexers are typically compiled to WASM so you'll need to have the proper WASM compilation target available on your system. You can install this target using <code>rustup</code>:</p>
<pre><code>rustup target add wasm32-unknown-unknown
</code></pre>
<p>Additionally, you'll need the <code>wasm-snip</code> utility in order to remove errant symbols from your compiled WASM binary. You can install this tool using <code>cargo</code>:</p>
<pre><code>cargo install wasm-snip
</code></pre>
<h2 id="2-using-the-forc-index-plugin"><a class="header" href="#2-using-the-forc-index-plugin">2. Using the <code>forc-index</code> plugin</a></h2>
<p>The primary means of interfacing with the Fuel indexer for indexer development is the <a href="https://crates.io/crates/forc-index"><code>forc-index</code> CLI tool</a>. <code>forc-index</code> is a <a href="https://github.com/FuelLabs/sway/tree/master/forc"><code>forc</code></a> plugin specifically created to interface with the Fuel indexer service. Since we already installed <code>fuelup</code> in a previous step <sup><a href="quickstart/index.html#11-install-fuelup">1.1</a></sup>, we should be able to check that our <code>forc-index</code> binary was successfully installed and added to our <code>PATH</code>.</p>
<pre><code class="language-bash">which forc-index
</code></pre>
<pre><code class="language-text">/Users/me/.fuelup/bin/forc-index
</code></pre>
<blockquote>
<p>IMPORTANT: <code>fuelup</code> will install several binaries from the Fuel ecosystem and add them into your <code>PATH</code>, including the <code>fuel-indexer</code> binary. The <code>fuel-indexer</code> binary is the primary binary that users can use to spin up a Fuel indexer service.</p>
</blockquote>
<pre><code class="language-bash">which fuel-indexer
</code></pre>
<pre><code class="language-text">/Users/me/.fuelup/bin/fuel-indexer
</code></pre>
<h3 id="21-check-for-components"><a class="header" href="#21-check-for-components">2.1 Check for components</a></h3>
<p>Once the <code>forc-index</code> plugin is installed, let's go ahead and see what indexer components we have installed.</p>
<blockquote>
<p>Many of these components are required for development work (e.g., <code>fuel-core</code>, <code>psql</code>) but some are even required for non-development usage as well (e.g., <code>wasm-snip</code>, <code>fuelup</code>).</p>
</blockquote>
<pre><code class="language-bash">forc index check
</code></pre>
<pre><code class="language-text">+--------+------------------------+---------------------------------------------------------+
| Status |       Component        |                         Details                         |
+--------+------------------------+---------------------------------------------------------+
|   ‚õîÔ∏è   | fuel-indexer binary    |  Can't locate fuel-indexer.                             |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | fuel-indexer service   |  Local service found: PID(63967) | Port(29987).         |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | psql                   |  /usr/local/bin/psql                                    |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | fuel-core              |  /Users/me/.cargo/bin/fuel-core                         |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | docker                 |  /usr/local/bin/docker                                  |
+--------+------------------------+---------------------------------------------------------+
|   ‚õîÔ∏è   | fuelup                 |  Can't locate fuelup.                                   |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | wasm-snip              |  /Users/me/.cargo/bin/wasm-snip                         |
+--------+------------------------+---------------------------------------------------------+
|   ‚õîÔ∏è   | forc-postgres          |  Can't locate fuelup.                                   |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | rustc                  |  /Users/me/.cargo/bin/rustc                             |
+--------+------------------------+---------------------------------------------------------+
|   ‚úÖ   | forc-wallet            |  /Users/me/.cargo/bin/forc-wallet                       |
+--------+------------------------+---------------------------------------------------------+
</code></pre>
<h3 id="22-setup-a-database-and-start-the-indexer-service"><a class="header" href="#22-setup-a-database-and-start-the-indexer-service">2.2 Setup a Database and Start the Indexer Service</a></h3>
<p>To quickly setup and bootstrap the PostgreSQL database that we'll need, we'll use <code>forc index</code>.</p>
<p>We can quickly create a bootstrapped database and start the Fuel indexer service by running the following command:</p>
<blockquote>
<p>IMPORTANT: Ensure that any local PostgreSQL instance that is running on port <code>5432</code> is stopped.</p>
</blockquote>
<pre><code class="language-bash">forc index start \
    --embedded-database
    --fuel-node-host beta-3.fuel.network \
    --fuel-node-port 80 \
    --run-migrations
</code></pre>
<p>You should see output indicating the successful creation of a database and start of the indexer service; there may be much more content in your session, but it should generally contain output similar to the following lines:</p>
<pre><code class="language-text">üì¶ Downloading, unpacking, and bootstrapping database...

‚ñπ‚ñπ‚ñ∏‚ñπ‚ñπ ‚è±  Setting up database...

üí° Creating database at 'postgres://postgres:postgres@localhost:5432/postgres'

‚úÖ Successfully created database at 'postgres://postgres:postgres@localhost:5432/postgres'.

‚úÖ Successfully started database at 'postgres://postgres:postgres@localhost:5432/postgres'.

‚úÖ Successfully started the indexer service.
</code></pre>
<blockquote>
<p>You can <code>Ctrl+C</code> to exit the <code>forc index start</code> process, and your indexer service and database should still be running in the background.</p>
</blockquote>
<h3 id="23-creating-a-new-indexer"><a class="header" href="#23-creating-a-new-indexer">2.3 Creating a new indexer</a></h3>
<p>Now that we have our development environment set up, the next step is to create an indexer.</p>
<pre><code class="language-bash">forc index new hello-indexer --namespace my_project &amp;&amp; cd hello-indexer
</code></pre>
<blockquote>
<p>The <code>namespace</code> of your project is a required option. You can think of a <code>namespace</code> as your organization name or company name. Your project might contain one or many indexers all under the same <code>namespace</code>. For a complete list of options passed to <code>forc index new</code>, see <a href="quickstart/./src/reference-guide/plugins/forc-index/new.html">here</a></p>
</blockquote>
<pre><code class="language-text">forc index new hello-indexer --namespace my_project

‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó         ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù   ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù

An easy-to-use, flexible indexing service built to go fast. üöóüí®

----

Read the Docs:
- Fuel Indexer: https://github.com/FuelLabs/fuel-indexer
- Fuel Indexer Book: https://fuellabs.github.io/fuel-indexer/latest
- Sway Book: https://fuellabs.github.io/sway/latest
- Rust SDK Book: https://fuellabs.github.io/fuels-rs/latest

Join the Community:
- Follow us @SwayLang: https://twitter.com/fuellabs_
- Ask questions in dev-chat on Discord: https://discord.com/invite/xfpK4Pe

Report Bugs:
- Fuel Indexer Issues: https://github.com/FuelLabs/fuel-indexer/issues/new

Take a quick tour.
`forc index check`
    List indexer components.
`forc index new`
    Create a new indexer.
`forc index init`
    Create a new indexer in an existing directory.
`forc index start`
    Start a local indexer service.
`forc index build`
    Build your indexer.
`forc index deploy`
    Deploy your indexer.
`forc index remove`
    Stop a running indexer.
`forc index revert`
    Revert a deployed indexer.
`forc index auth`
    Authenticate against an indexer service.
</code></pre>
<h3 id="24-deploying-our-indexer"><a class="header" href="#24-deploying-our-indexer">2.4 Deploying our indexer</a></h3>
<p>At this point, we have a brand new indexer that will index some blocks and transactions. And with both our database and Fuel indexer services up and running, all that's left is to build and deploy the indexer in order to see it in action. Let's build and deploy our indexer:</p>
<pre><code class="language-bash">forc index deploy
</code></pre>
<blockquote>
<p>IMPORTANT: <code>forc index deploy</code> by defaults runs <code>forc index build</code> prior to deploying the indexer. The same result can be produced by running <code>forc index build</code> then subsequently running <code>forc index deploy</code>.</p>
</blockquote>
<p>If all goes well, you should see the following:</p>
<pre><code class="language-text">‚ñπ‚ñπ‚ñπ‚ñπ‚ñπ ‚è∞ Building...                         Finished dev [unoptimized + debuginfo] target(s) in 0.96s
‚ñ™‚ñ™‚ñ™‚ñ™‚ñ™ ‚úÖ Build succeeded.                    Deploying indexer
‚ñ™‚ñ™‚ñ™‚ñ™‚ñ™ ‚úÖ Successfully deployed indexer.
</code></pre>
<h2 id="3-querying-for-data"><a class="header" href="#3-querying-for-data">3. Querying for data</a></h2>
<p>With our indexer deployed, we should be able to query for newly indexed data after a few seconds.</p>
<p>Below, we write a simple GraphQL query that simply returns a few fields from all transactions that we've indexed.</p>
<pre><code class="language-bash">curl -X POST -H &quot;Content-Type: application/graphql&quot;
--data '{ &quot;query&quot;: &quot;query { tx { id, hash, block } }&quot; }'
http://127.0.0.1:29987/api/graph/my_project/hello_indexer
</code></pre>
<pre><code class="language-text">[
   {
      &quot;block&quot; : 7017844286925529648,
      &quot;hash&quot; : &quot;fb93ce9519866676813584eca79afe2d98466b3e2c8b787503b76b0b4718a565&quot;,
      &quot;id&quot; : 7292230935510476086,
   },
   {
      &quot;block&quot; : 3473793069188998756,
      &quot;hash&quot; : &quot;5ea2577727aaadc331d5ae1ffcbc11ec4c2ba503410f8edfb22fc0a72a1d01eb&quot;,
      &quot;id&quot; : 4136050720295695667,
   },
   {
      &quot;block&quot; : 7221293542007912803,
      &quot;hash&quot; : &quot;d2f638c26a313c681d75db2edfbc8081dbf5ecced87a41ec4199d221251b0578&quot;,
      &quot;id&quot; : 4049687577184449589,
   },
]
</code></pre>
<h3 id="31-using-the-playgrond"><a class="header" href="#31-using-the-playgrond">3.1 Using the playgrond</a></h3>
<p>As opposed to writing <code>curL</code> commands to query data, note that you can also explore your indexed data using the indexer's GraphQL playground. For more info on using the playground - <a href="quickstart/./src/reference-guide/components/graphql/playground.html">checkout the playground docs</a>.</p>
<h3 id="finished-"><a class="header" href="#finished-">Finished! ü•≥</a></h3>
<p>Congrats, you just created, built, and deployed your first indexer on the world's fastest execution layer. For more detailed info on how the Fuel indexer service works, make sure you <a href="https://fuellabs.github.io/fuel-indexer/master/"><strong>read the book</strong></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starting-the-fuel-indexer"><a class="header" href="#starting-the-fuel-indexer">Starting the Fuel Indexer</a></h1>
<h2 id="using-cli-options"><a class="header" href="#using-cli-options">Using CLI options</a></h2>
<pre><code class="language-text">Standalone binary for the fuel indexer service.

USAGE:
    fuel-indexer run [OPTIONS]

OPTIONS:
        --auth-enabled
            Require users to authenticate for some operations.

        --auth-strategy &lt;AUTH_STRATEGY&gt;
            Authentication scheme used.

    -c, --config &lt;FILE&gt;
            Indexer service config file.

        --database &lt;DATABASE&gt;
            Database type. [default: postgres] [possible values: postgres]

        --embedded-database
            Automatically create and start database using provided options or defaults.

        --fuel-node-host &lt;FUEL_NODE_HOST&gt;
            Host of the running Fuel node. [default: localhost]

        --fuel-node-port &lt;FUEL_NODE_PORT&gt;
            Listening port of the running Fuel node. [default: 4000]

        --graphql-api-host &lt;GRAPHQL_API_HOST&gt;
            GraphQL API host. [default: localhost]

        --graphql-api-port &lt;GRAPHQL_API_PORT&gt;
            GraphQL API port. [default: 29987]

    -h, --help
            Print help information

        --indexer-net-config
            Allow network configuration via indexer manifests.

        --jwt-expiry &lt;JWT_EXPIRY&gt;
            Amount of time (seconds) before expiring token (if JWT scheme is specified).

        --jwt-issuer &lt;JWT_ISSUER&gt;
            Issuer of JWT claims (if JWT scheme is specified).

        --jwt-secret &lt;JWT_SECRET&gt;
            Secret used for JWT scheme (if JWT scheme is specified).

        --local-fuel-node
            Start a local Fuel node.

        --log-level &lt;LOG_LEVEL&gt;
            Log level passed to the Fuel Indexer service. [default: info] [possible values: info,
            debug, error, warn]

    -m, --manifest &lt;FILE&gt;
            Indexer config file.

        --max-body-size &lt;MAX_BODY_SIZE&gt;
            Max body size for GraphQL API requests. [default: 5242880]

        --metrics
            Use Prometheus metrics reporting.

        --postgres-database &lt;POSTGRES_DATABASE&gt;
            Postgres database.

        --postgres-host &lt;POSTGRES_HOST&gt;
            Postgres host.

        --postgres-password &lt;POSTGRES_PASSWORD&gt;
            Postgres password.

        --postgres-port &lt;POSTGRES_PORT&gt;
            Postgres port.

        --postgres-user &lt;POSTGRES_USER&gt;
            Postgres username.

        --run-migrations
            Run database migrations before starting service.

        --stop-idle-indexers
            Prevent indexers from running without handling any blocks.

    -v, --verbose
            Enable verbose logging.

    -V, --version
            Print version information
</code></pre>
<h2 id="using-a-configuration-file"><a class="header" href="#using-a-configuration-file">Using a configuration file</a></h2>
<pre><code class="language-yaml"># # The following is an example Fuel indexer configuration file.
# #
# # This configuration spec is intended to be used for a single instance
# # of a Fuel indexer node or service.
# #
# # For more info on how the Fuel indexer works, read the book: https://fuellabs.github.io/fuel-indexer/master/
# # or specifically read up on these configuration options: https://fuellabs.github.io/fuel-indexer/master/getting-started/configuration.html

# # Use Prometheus metrics reporting.
# metrics: true

# # Prevent indexers from running without handling any blocks.
# stop_idle_indexers: true

# # Run database migrations before starting service.
# run_migrations: true

# # Enable verbose logging.
# verbose: false

# # Start a local Fuel node.
# local_fuel_node: false

# # Allow network configuration via indexer manifests.
# indexer_net_config: false

# # ***********************
# # Fuel Node configuration
# # ************************

# fuel_node:

#   # Host of the running Fuel node.
#   host: localhost

#   # Listening port of the running Fuel node.
#   port: 4000

# # *************************
# # GraphQL API configuration
# # *************************

# graphql_api:
#   # GraphQL API host.
#   host: localhost

#   # GraphQL API port.
#   port: 29987

#   # Max body size for GraphQL API requests.
#   max_body_size: &quot;5242880&quot;

# # ******************************
# # Database configuration options
# # ******************************

# database:

#   postgres:
#     # Postgres username.
#     user: postgres

#     # Postgres database.
#     database: postgres

#     # Postgres password.
#     password: password

#     # Postgres host.
#     host: localhost

#     # Postgres port.
#     port: 5432

# # ******************************
# # Indexer service authentication
# # ******************************

# authentication:
#   # Require users to authenticate for some operations.
#   enabled: false

#   # Which authentication scheme to use.
#   strategy: jwt

#   # Secret used if JWT authentication is specified.
#   jwt_secret: abcdefghijklmnopqrstuvwxyz1234567890*

#   # JWT issuer if JWT authentication is specified.
#   # jwt_issuer: FuelLabs

#   # Amount of time (seconds) before expiring token if JWT authentication is specified.
#   # jwt_expiry: 2592000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Below is a simple &quot;Hello World&quot; Sway contract that we want to index. This contract has a function called <code>new_greeting</code> that logs a <code>Greeting</code> and a <code>Person</code>.</p>
<pre><code class="language-rust  ignore">contract;

use std::logging::log;

struct Person {
    name: str[32],
}

struct Greeting {
    id: u64,
    greeting: str[32],
    person: Person,
}

abi Greet {
    fn new_greeting(id: u64, greeting: str[32], person_name: str[32]);
}

impl Greet for Contract {
    fn new_greeting(id: u64, greeting: str[32], person_name: str[32]) {
        log(Greeting{ id, greeting, person: Person{ name: person_name }});
    }
}</code></pre>
<p>We can define our schema like this in the schema file:</p>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    greeting: Greeting
    salutation: Salutation
}

# Calling this `Greeter` so as to not clash with `Person` in the contract
type Greeter {
    id: ID!
    name: Charfield!
    first_seen: UInt8!
    last_seen: UInt8!
    visits: Blob!
}

# Calling this `Salutation` so as to not clash with `Greeting` in the contract
type Salutation {
    id: ID!
    message_hash: Bytes32!
    message: Charfield!
    greeter: Greeter!
    first_seen: UInt8!
    last_seen: UInt8!
}
</code></pre>
<p>Now that our schema is defined, here is how we can implement the WASM module in our <code>lib.rs</code> file:</p>
<pre><code class="language-rust ignore">//! A &quot;Hello World&quot; type of program for the Fuel Indexer service.
//!
//! Build this example's WASM module using the following command. Note that a
//! wasm32-unknown-unknown target will be required.
//!
//! ```bash
//! cargo build -p hello-indexer --release --target wasm32-unknown-unknown
//! ```
//!
//! Start a local test Fuel node
//!
//! ```bash
//! cargo run --bin fuel-node
//! ```
//!
//! With your database backend set up, now start your fuel-indexer binary using the
//! assets from this example:
//!
//! ```bash
//! cargo run --bin fuel-indexer -- run --manifest examples/hello-world/hello-indexer/hello_indexer.manifest.yaml
//! ```
//!
//! Now trigger an event.
//!
//! ```bash
//! cargo run --bin hello-bin
//! ```

extern crate alloc;
use fuel_indexer_macros::indexer;
use fuel_indexer_plugin::prelude::*;

#[indexer(manifest = &quot;examples/hello-world/hello-indexer/hello_indexer.manifest.yaml&quot;)]
mod hello_world_indexer {

    fn index_logged_greeting(event: Greeting, block: BlockData) {
        // Since all events require a u64 ID field, let's derive an ID using the
        // name of the person in the Greeting
        let greeter_name = trim_sized_ascii_string(&amp;event.person.name);
        let greeting = trim_sized_ascii_string(&amp;event.greeting);
        let greeter_id = first8_bytes_to_u64(&amp;greeter_name);

        // Here we 'get or create' a Salutation based on the ID of the event
        // emitted in the LogData receipt of our smart contract
        let salutation = match Salutation::load(event.id) {
            Some(mut g) =&gt; {
                // If we found an event, let's use block height as a proxy for time
                g.last_seen = block.height;
                g
            }
            None =&gt; {
                // If we did not already have this Saluation stored in the database. Here we
                // show how you can use the Charfield type to store strings with length &lt;= 255
                let message = format!(&quot;{} üëã, my name is {}&quot;, &amp;greeting, &amp;greeter_name);

                Salutation {
                    id: event.id,
                    message_hash: first32_bytes_to_bytes32(&amp;message),
                    message,
                    greeter: greeter_id,
                    first_seen: block.height,
                    last_seen: block.height,
                }
            }
        };

        // Here we do the same with Greeter that we did for Saluation -- if we have an event
        // already saved in the database, load it and update it. If we do not have this Greeter
        // in the database then create one
        let greeter = match Greeter::load(greeter_id) {
            Some(mut g) =&gt; {
                g.last_seen = block.height;
                g
            }
            None =&gt; Greeter {
                id: greeter_id,
                first_seen: block.height,
                name: greeter_name,
                last_seen: block.height,

                // Here we show an example of an arbtrarily sized Blob type. These Blob types
                // support data up to 10485760 bytes in length
                visits: vec![1u8, 2, 3, 4, 5, 6, 7, 8],
            },
        };

        // Both entity saves will occur in the same transaction
        salutation.save();
        greeter.save();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-explorer"><a class="header" href="#block-explorer">Block Explorer</a></h1>
<p>Below is an example of a rudimentary block explorer backend implementation that demonstrates how to leverage basic Fuel indexer abstractions in order to build a cool dApp backend.</p>
<pre><code class="language-rust ignore">//! A rudimentary block explorer implementation demonstrating how blocks, transactions,
//! contracts, and accounts can be persisted into the database.
//!
//! Build this example's WASM module using the following command. Note that a
//! wasm32-unknown-unknown target will be required.
//!
//! ```bash
//! cargo build -p explorer-indexer --release --target wasm32-unknown-unknown
//! ```
//!
//! With your database backend set up, now start your fuel-indexer binary using the
//! assets from this example:
//!
//! ```bash
//! cargo run --bin fuel-indexer -- run --manifest examples/block-explorer/explorer-indexer/explorer_indexer.manifest.yaml
//! ```

extern crate alloc;
use fuel_indexer_macros::indexer;
use fuel_indexer_plugin::prelude::*;
use std::collections::HashSet;

// We'll pass our manifest to our #[indexer] attribute. This manifest contains
// all of the relevant configuration parameters in regard to how our index will
// work. In the fuel-indexer repository, we use relative paths (starting from the
// fuel-indexer root) but if you're building an index outside of the fuel-indexer
// project you'll want to use full/absolute paths.
#[indexer(
    manifest = &quot;examples/block-explorer/explorer-indexer/explorer_indexer.manifest.yaml&quot;
)]
mod explorer_index {
    // When specifying args to your handler functions, you can either use types defined
    // in your ABI JSON file, or you can use native Fuel types. These native Fuel types
    // include various `Receipt`s, as well as more comprehensive data, in the form of
    // blocks `BlockData` and transactions `TransactionData`. A list of native Fuel
    // types can be found at:
    //
    //  https://github.com/FuelLabs/fuel-indexer/blob/master/fuel-indexer-schema/src/types/fuel.rs#L28
    fn index_explorer_data(block_data: BlockData) {
        let mut block_gas_limit = 0;

        // Convert the deserialized block `BlockData` struct that we get from our Fuel node, into
        // a block entity `Block` that we can persist to the database. The `Block` type below is
        // defined in our schema/explorer.graphql and represents the type that we will
        // save to our database.
        let producer = block_data.producer.unwrap_or(Bytes32::zeroed());

        let block = Block {
            id: first8_bytes_to_u64(block_data.id),
            height: block_data.height,
            producer,
            hash: block_data.id,
            timestamp: block_data.time,
            gas_limit: block_gas_limit,
        };

        // Now that we've created the object for the database, let's save it.
        block.save();

        // Keep track of some Receipt data involved in this transaction.
        let mut accounts = HashSet::new();
        let mut contracts = HashSet::new();

        for tx in block_data.transactions.iter() {
            let mut tx_amount = 0;
            let mut tokens_transferred = Vec::new();

            // `Transaction::Script`, `Transaction::Create`, and `Transaction::Mint`
            // are unused but demonstrate properties like gas, inputs,
            // outputs, script_data, and other pieces of metadata. You can access
            // properties that have the corresponding transaction `Field` traits
            // implemented; examples below.
            match &amp;tx.transaction {
                #[allow(unused)]
                Transaction::Script(t) =&gt; {
                    Logger::info(&quot;Inside a script transaction. (&gt;^‚Äø^)&gt;&quot;);

                    let gas_limit = t.gas_limit();
                    let gas_price = t.gas_price();
                    let maturity = t.maturity();
                    let script = t.script();
                    let script_data = t.script_data();
                    let receipts_root = t.receipts_root();
                    let inputs = t.inputs();
                    let outputs = t.outputs();
                    let witnesses = t.witnesses();

                    let json = &amp;tx.transaction.to_json();
                    block_gas_limit += gas_limit;
                }
                #[allow(unused)]
                Transaction::Create(t) =&gt; {
                    Logger::info(&quot;Inside a create transaction. &lt;(^.^)&gt;&quot;);

                    let gas_limit = t.gas_limit();
                    let gas_price = t.gas_price();
                    let maturity = t.maturity();
                    let salt = t.salt();
                    let bytecode_length = t.bytecode_length();
                    let bytecode_witness_index = t.bytecode_witness_index();
                    let inputs = t.inputs();
                    let outputs = t.outputs();
                    let witnesses = t.witnesses();
                    let storage_slots = t.storage_slots();
                    block_gas_limit += gas_limit;
                }
                #[allow(unused)]
                Transaction::Mint(t) =&gt; {
                    Logger::info(&quot;Inside a mint transaction. &lt;(^‚Äø^&lt;)&quot;);

                    let tx_pointer = t.tx_pointer();
                    let outputs = t.outputs();
                }
            }

            for receipt in &amp;tx.receipts {
                // You can handle each receipt in a transaction `TransactionData` as you like.
                //
                // Below demonstrates how you can use parts of a receipt `Receipt` in order
                // to persist entities defined in your GraphQL schema, to the database.
                match receipt {
                    #[allow(unused)]
                    Receipt::Call { id, .. } =&gt; {
                        contracts.insert(Contract {
                            id: *id,
                            last_seen: 0,
                        });
                    }
                    #[allow(unused)]
                    Receipt::ReturnData { id, .. } =&gt; {
                        contracts.insert(Contract {
                            id: *id,
                            last_seen: 0,
                        });
                    }
                    #[allow(unused)]
                    Receipt::Transfer {
                        id,
                        to,
                        asset_id,
                        amount,
                        ..
                    } =&gt; {
                        contracts.insert(Contract {
                            id: *id,
                            last_seen: 0,
                        });

                        let transfer = Transfer {
                            id: first8_bytes_to_u64(bytes32_from_inputs(
                                id,
                                [id.to_vec(), to.to_vec(), asset_id.to_vec()].concat(),
                            )),
                            contract_id: *id,
                            receiver: *to,
                            amount: *amount,
                            asset_id: *asset_id,
                        };

                        transfer.save();
                        tokens_transferred.push(asset_id.to_string());
                    }
                    #[allow(unused)]
                    Receipt::TransferOut {
                        id,
                        to,
                        amount,
                        asset_id,
                        ..
                    } =&gt; {
                        contracts.insert(Contract {
                            id: *id,
                            last_seen: 0,
                        });

                        accounts.insert(Account {
                            id: *to,
                            last_seen: 0,
                        });

                        tx_amount += amount;
                        let transfer_out = TransferOut {
                            id: first8_bytes_to_u64(bytes32_from_inputs(
                                id,
                                [id.to_vec(), to.to_vec(), asset_id.to_vec()].concat(),
                            )),
                            contract_id: *id,
                            receiver: *to,
                            amount: *amount,
                            asset_id: *asset_id,
                        };

                        transfer_out.save();
                    }
                    #[allow(unused)]
                    Receipt::Log { id, rb, .. } =&gt; {
                        contracts.insert(Contract {
                            id: *id,
                            last_seen: 0,
                        });
                        let log = Log {
                            id: first8_bytes_to_u64(bytes32_from_inputs(
                                id,
                                u64::to_le_bytes(*rb).to_vec(),
                            )),
                            contract_id: *id,
                            rb: *rb,
                        };

                        log.save();
                    }
                    #[allow(unused)]
                    Receipt::LogData { id, .. } =&gt; {
                        contracts.insert(Contract {
                            id: *id,
                            last_seen: 0,
                        });

                        Logger::info(&quot;LogData types are unused in this example. (&gt;'')&gt;&quot;);
                    }
                    #[allow(unused)]
                    Receipt::ScriptResult { result, gas_used } =&gt; {
                        let result: u64 = match result {
                            ScriptExecutionResult::Success =&gt; 1,
                            ScriptExecutionResult::Revert =&gt; 2,
                            ScriptExecutionResult::Panic =&gt; 3,
                            ScriptExecutionResult::GenericFailure(_) =&gt; 4,
                        };
                        let r = ScriptResult {
                            id: first8_bytes_to_u64(bytes32_from_inputs(
                                &amp;[0u8; 32],
                                u64::to_be_bytes(result).to_vec(),
                            )),
                            result,
                            gas_used: *gas_used,
                        };
                        r.save();
                    }
                    #[allow(unused)]
                    Receipt::MessageOut {
                        sender,
                        recipient,
                        amount,
                        ..
                    } =&gt; {
                        tx_amount += amount;
                        accounts.insert(Account {
                            id: *sender,
                            last_seen: 0,
                        });
                        accounts.insert(Account {
                            id: *recipient,
                            last_seen: 0,
                        });

                        Logger::info(&quot;LogData types are unused in this example. (&gt;'')&gt;&quot;);
                    }
                    _ =&gt; {
                        Logger::info(&quot;This type is not handled yet.&quot;);
                    }
                }
            }

            // Persist the transaction to the database via the `Tx` object defined in the GraphQL schema.
            let tx_entity = Tx {
                block: block.id,
                hash: tx.id,
                timestamp: block.timestamp,
                id: first8_bytes_to_u64(tx.id),
                value: tx_amount,
                status: tx.status.clone().into(),
                tokens_transferred: Json(
                    serde_json::to_value(tokens_transferred)
                        .unwrap()
                        .to_string(),
                ),
            };

            tx_entity.save();
        }

        // Save all of our accounts
        for account in accounts.iter() {
            account.save();
        }

        // Save all of our contracts
        for contract in contracts.iter() {
            contract.save();
        }
    }
}</code></pre>
<p>Once blocks have been added to the database by the indexer, you can query for them by using a query similar to the following:</p>
<pre><code class="language-sh">curl -X POST -H &quot;Content-Type: application/graphql&quot; 
--data '{ &quot;query&quot;: &quot;query { block { id, height, timestamp } }&quot; }' 
http://127.0.0.1:29987/api/graph/fuel_examples/explorer_indexer
</code></pre>
<pre><code class="language-json">{
   &quot;data&quot;: [
   {
      &quot;height&quot; : 1,
      &quot;id&quot; : &quot;f169a30cfcbf1eebd97a07b19de98e4b38a4367b03d1819943be41744339d38a&quot;,
      &quot;timestamp&quot; : 1668710162
   },
   {
      &quot;height&quot; : 2,
      &quot;id&quot; : &quot;a8c554758f78fe73054405d38099f5ad21a90c05206b5c6137424985c8fd10c7&quot;,
      &quot;timestamp&quot; : 1668710163
   },
   {
      &quot;height&quot; : 3,
      &quot;id&quot; : &quot;850ab156ddd9ac9502768f779936710fd3d792e9ea79bc0e4082de96450b5174&quot;,
      &quot;timestamp&quot; : 1668710312
   },
   {
      &quot;height&quot; : 4,
      &quot;id&quot; : &quot;19e19807c6988164b916a6877fe049d403d55a07324fa883cb7fa5cdb33438e2&quot;,
      &quot;timestamp&quot; : 1668710313
   },
   {
      &quot;height&quot; : 5,
      &quot;id&quot; : &quot;363af43cfd2a6d8af166ee46c15276b24b130fc6a89ce7b3c8737d29d6d0e1bb&quot;,
      &quot;timestamp&quot; : 1668710314
   }
   ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-fuel-indexer-project"><a class="header" href="#a-fuel-indexer-project">A Fuel Indexer Project</a></h1>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>The Fuel indexer project can currently be used in a number of different ways:</p>
<ul>
<li>as tooling to compile arbitrary indicies</li>
<li>as a standalone service</li>
<li>as a part of a Fuel project, alongside other components of the Fuel ecosystem (e.g. <a href="https://fuellabs.github.io/sway">Sway</a>)</li>
</ul>
<p>We'll describe these three different implementations below.</p>
<h3 id="as-tooling-for-compiling-indexers"><a class="header" href="#as-tooling-for-compiling-indexers">As tooling for compiling indexers</a></h3>
<p>The Fuel indexer provides functionality to make it easy to build and compile abitrary indexers by using <a href="reference-guide/components/../plugins/forc-index/index.html"><code>forc index</code></a>. For info on how to use indexer tooling to compile arbitrary indexers, check out our <a href="reference-guide/components/./../quickstart/index.html">Quickstart</a>; additionally, you can read through our <a href="reference-guide/components/../examples/index.html">examples</a> for a more in-depth exploration of how to compile indexers.</p>
<h3 id="as-a-standalone-service"><a class="header" href="#as-a-standalone-service">As a standalone service</a></h3>
<p>You can also start the Fuel indexer as a standalone binary that connects to a Fuel node to monitor the Fuel blockchain for new blocks and transactions. To do so, run the requisite database migrations, adjust the configuration to connect to a Fuel node, and start the service.</p>
<h3 id="as-part-of-a-fuel-project"><a class="header" href="#as-part-of-a-fuel-project">As part of a Fuel project</a></h3>
<p>Finally, you can run the Fuel indexer as part of a project that uses other components of the Fuel ecosystem, such as Sway. The convention for a Fuel project layout including an indexer is as follows:</p>
<pre><code class="language-text">.
‚îú‚îÄ‚îÄ contracts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hello-contract
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ Forc.toml
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ src
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ main.sw
‚îú‚îÄ‚îÄ frontend
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ indexer
    ‚îî‚îÄ‚îÄ hello-indexer
        ‚îú‚îÄ‚îÄ Cargo.toml
        ‚îú‚îÄ‚îÄ hello_indexer.manifest.yaml
        ‚îú‚îÄ‚îÄ schema
        ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hello_indexer.schema.graphql
        ‚îî‚îÄ‚îÄ src
            ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
<h2 id="an-indexer-project-at-a-glance"><a class="header" href="#an-indexer-project-at-a-glance">An Indexer Project at a Glance</a></h2>
<p>Every Fuel indexer project requires three components:</p>
<ul>
<li>a <a href="reference-guide/components/../components/assets/manifest.html">Manifest</a> describing indexer metadata</li>
<li>a <a href="reference-guide/components/../components/assets/schema.html">Schema</a> containing models for the data you want to index</li>
<li>a <a href="reference-guide/components/../components/assets/module.html">Module</a> which houses the logic for creating and saving the aforementioned data models</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">Manifest</a></h1>
<p>A manifest serves as the YAML configuration file for a given indexer. A proper manifest has the following structure:</p>
<pre><code class="language-yaml">namespace: fuel
identifier: index1
fuel_client: beta-3.fuel.network:80
abi: path/to/my/contract-abi.json
contract_id: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;
graphql_schema: path/to/my/schema.graphql
start_block: 1564
module:
  wasm: path/to/my/wasm_module.wasm
report_metrics: true
</code></pre>
<h2 id="namespace"><a class="header" href="#namespace"><code>namespace</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>namespace</code> is the topmost organizational level of an indexer. You can think of different namespaces as separate and distinct collections comprised of indexers. A namespace is unique to a given indexer operator -- i.e., indexer operators will not be able to support more than one namespace of the same name.</p>
<h2 id="identifier"><a class="header" href="#identifier"><code>identifier</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>identifier</code> field is used to (quite literally) identify the given indexer. If a namespace describes a collection of indexers, then an identifier describes a unique indexer inside that collection. As an example, if a provided <code>namespace</code> is <code>&quot;fuel&quot;</code> and a provided <code>identifier</code> is <code>&quot;index1&quot;</code>, then the full identifier for the given indexer will be <code>fuel.index1</code>.</p>
<h2 id="fuel_client"><a class="header" href="#fuel_client"><code>fuel_client</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>fuel_client</code> denotes the address (host, port combination) of the running Fuel client that you would like your indexer to index events from. In order to use this per-indexer <code>fuel_client</code> option, the indexer service at which your indexer is deployed will have to run with the <code>--indexer_net_config</code> option.</p>
<h2 id="abi"><a class="header" href="#abi"><code>abi</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>abi</code> option is used to provide a link to the Sway JSON application binary interface (ABI) that is generated when you build your Sway project. This generated ABI contains all types, type IDs, logged types, and message types used in your Sway contract.</p>
<h2 id="contract_id"><a class="header" href="#contract_id"><code>contract_id</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>contract_id</code> specifies the particular contract to which you would like an indexer to subscribe. Setting this field to an empty string will index events from any contract that is currently executing on the network.</p>
<blockquote>
<p>Important: Contract IDs are unique to the content of a contract. If you are subscribing to a certain contract and then the contract itself is changed or updated, you will need to change the <code>contract_id</code> field of the manifest to the new ID.</p>
</blockquote>
<h2 id="graphql_schema"><a class="header" href="#graphql_schema"><code>graphql_schema</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>graphql_schema</code> field contains the file path pointing to the corresponding GraphQL schema for a given indexer. This schema file holds the structures of the data that will eventually reside in your database. You can read more about the format of the schema file <a href="reference-guide/components/assets/./schema.html">here</a>.</p>
<blockquote>
<p>Important: The objects defined in your GraphQL schema are called 'entities'. These entities are what will be eventually be stored in the database.</p>
</blockquote>
<h2 id="start_block"><a class="header" href="#start_block"><code>start_block</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>start_block</code> field indicates the block height after which you'd like your indexer to start indexing events.</p>
<h2 id="module"><a class="header" href="#module"><code>module</code></a></h2>
<p><em>Required.</em></p>
<p>The <code>module</code> field contains a file path that points to code that will be run as an <em>executor</em> inside of the indexer. There are two available options for modules/execution: <code>wasm</code> and <code>native</code>. Note that when specifying a <code>wasm</code> module, the provided path must lead to a compiled WASM binary.</p>
<blockquote>
<p>Important: At this time, <code>wasm</code> is the preferred method of execution.</p>
</blockquote>
<h2 id="report_metrics"><a class="header" href="#report_metrics"><code>report_metrics</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>report_metrics</code> field indicates whether to report Prometheus metrics to the Fuel backend.</p>
<h2 id="resumable"><a class="header" href="#resumable"><code>resumable</code></a></h2>
<p><em>Optional.</em></p>
<p>The <code>resumable</code> field contains a boolean value and specifies whether the indexer should synchronise with the latest block if it has fallen out of sync.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-schema"><a class="header" href="#graphql-schema">GraphQL Schema</a></h1>
<p>The GraphQL schema is a required component of the Fuel indexer. When data is indexed into the database, the actual values that are persisted to the database will be values created using the data structures defined in the schema.</p>
<p>In its most basic form, a Fuel indexer GraphQL schema should have a <code>schema</code> definition that contains a defined query root. The rest of the implementation is up to you. Here's an example of a well-formed schema:</p>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    thing1: FirstThing
    thing2: SecondThing
}

type FirstThing {
    id: ID!
    value: UInt8!
}

type SecondThing {
    id: ID!
    optional_value: UInt8
    timestamp: Timestamp!
}
</code></pre>
<p>The types you see above (e.g., <code>ID</code>, <code>UInt8</code>, etc) are Fuel abstractions that were created to more seamlessly integrate with the Fuel VM and are not native to GraphQL. A deeper explanation on these
types can be found in <a href="reference-guide/components/assets/../../data-types/types.html">the Types section</a>.</p>
<blockquote>
<p>Important: It is up to developers to manage their own unique IDs for each type, meaning that a data structure's <code>ID</code> field needs to be manually generated prior to saving it to the database. This generation can be as simple or complex as you want in order to fit your particular situation; the only requirement is that the developer implement their own custom generation. Examples can be found in the <a href="reference-guide/components/assets/../../../examples/block-explorer.html">Block Explorer</a> and <a href="reference-guide/components/assets/../../../examples/hello-world.html">Hello World</a> sections.</p>
</blockquote>
<h2 id="required-and-optional-fields"><a class="header" href="#required-and-optional-fields">Required and Optional Fields</a></h2>
<p>Required fields are denoted with a <code>!</code> following its type; for example, the <code>value</code> field of the <code>FirstThing</code> type is a <code>UInt8</code> and is required to be present for the indexer to successfully persist the entity. If a certain piece of information is essential to your use case, then you should mark that field as required.</p>
<p>In contrast, optional fields are not required to be present for the indexer to persist the entity in storage. You can denote an optional field by just using the type name; for example, the <code>optional_value</code> field of the <code>SecondThing</code> type is optional, and should be a <code>UInt8</code> if present. If it's possible that a value might not always exist in the data you wish to index, consider making that the corresponding field optional. In your indexer code, you will need to use the <code>Option</code> Rust type when assigning a value to an optional field; values that are present should be assigned after being wrapped in <code>Some(..)</code> while absent values should be assigned using <code>None</code>.</p>
<blockquote>
<p>Important: The <code>ID</code> field is <em>always</em> required. An indexer <strong>will</strong> return an error if an optional value is used for the <code>ID</code> field.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-modules"><a class="header" href="#wasm-modules">WASM Modules</a></h1>
<p>WebAssembly (WASM) modules are compiled binaries that are registered into a Fuel indexer at runtime. The WASM bytes are read in by the indexer and <em>executors</em> are created which will implement blocking calls to the WASM runtime.</p>
<p>The WASM module is generated based on your manifest, schema, and your <code>lib.rs</code> file.</p>
<h2 id="librs"><a class="header" href="#librs"><code>lib.rs</code></a></h2>
<p>You can implement the logic for handling events and saving data to the database in your <code>lib.rs</code> file in the <code>src</code> folder.</p>
<p>Here, you can define which functions handle different events based on the function parameters. If you add a function parameter of a certain type, the function will handle all blocks, transactions, or transaction receipts that contain a matching type.</p>
<p>We can look at the function below as an example:</p>
<pre><code class="language-rust  ignore">fn index_logged_greeting(greeter: Greeting) {
    // function logic goes here
}</code></pre>
<p>All transactions that have a receipt that contains data with a type of <code>Greeting</code> will be handled by the function.</p>
<p>You can learn more about what data can be indexed in the <a href="reference-guide/components/assets/../../indexing/what-can-i-index.html">What Can I Index</a> section.</p>
<p>To save an instance of a schema type in your database, you can call the <code>save</code> method on the instance.</p>
<pre><code class="language-rust  ignore">instance.save();</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To compile your indexer code to WASM, you'll first need to install the <code>wasm32-unknown-unknown</code> target platform through <code>rustup</code>, if you haven't done so already.</p>
<pre><code class="language-bash">rustup add target wasm32-unknown-unknown
</code></pre>
<p>After that, you would compile your indexer code by navigating to the root folder for your indexer code and build. An example of this can be found below:</p>
<pre><code class="language-bash">cd /my/index-lib &amp;&amp; cargo build --release
</code></pre>
<h2 id="notes-on-wasm"><a class="header" href="#notes-on-wasm">Notes on WASM</a></h2>
<p>There are a few points that Fuel indexer users should know when using WASM:</p>
<ol>
<li>
<p>WASM modules are only used if the execution mode specified in your manifest file is <code>wasm</code>.</p>
</li>
<li>
<p>Developers should be aware of what things may not work off-the-shelf in a module: file I/O, thread spawning, and anything that depends on system libraries. This is due to the technological limitations of WASM as a whole; more information can be found <a href="https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html">here</a>.</p>
</li>
<li>
<p>As of this writing, there is a small bug in newly built Fuel indexer WASM modules that produces a WASM runtime error due to an errant upstream dependency. For now, a quick workaround requires the use of <code>wasm-snip</code> to remove the errant symbols from the WASM module. More info can be found in the related script <a href="https://github.com/FuelLabs/fuel-indexer/blob/master/scripts/stripper.bash">here</a>.</p>
</li>
<li>
<p>Users on Apple Silicon macOS systems may experience trouble when trying to build WASM modules due to its <code>clang</code> binary not supporting WASM targets. If encountered, you can install a binary with better support from Homebrew (<code>brew install llvm</code>) and instruct <code>rustc</code> to leverage it by setting the following environment variables:</p>
</li>
</ol>
<ul>
<li><code>AR=/opt/homebrew/opt/llvm/bin/llvm-ar</code></li>
<li><code>CC=/opt/homebrew/opt/llvm/bin/clang</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-can-i-index"><a class="header" href="#what-can-i-index">What Can I Index?</a></h1>
<p>You can index three main types of data from the Fuel network: blocks, transactions, and transaction receipts. You can read more about these data types below:</p>
<ul>
<li>
<p><a href="reference-guide/indexing/./blocks-and-transactions.html"><strong>Blocks and Transactions</strong></a></p>
</li>
<li>
<p><a href="reference-guide/indexing/./receipts.html"><strong>Transaction Receipts</strong></a></p>
</li>
</ul>
<p>If you've previously built an indexer for the EVM, you may be used to only being able to index data that is emitted as an event.</p>
<p>However, with Fuel you can index the entire transaction, which means you can use much more than logged data, allowing you to reduce the number of logs you need in your contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-and-transactions"><a class="header" href="#blocks-and-transactions">Blocks and Transactions</a></h1>
<p>You can use the <code>BlockData</code> and <code>TransactionData</code> data structures to index important information about the Fuel network for your dApp.</p>
<h2 id="blockdata"><a class="header" href="#blockdata"><code>BlockData</code></a></h2>
<pre><code class="language-rust ignore">pub struct BlockData {
    pub height: u64,
    pub id: Bytes32,
    pub producer: Option&lt;Bytes32&gt;,
    pub time: i64,
    pub transactions: Vec&lt;TransactionData&gt;,
}</code></pre>
<p>The <code>BlockData</code> struct is how blocks are represented in the Fuel indexer. It contains metadata such as the ID, height, and time, as well as a list of the transactions it contains (represented by <code>TransactionData</code>). It also contains the public key hash of the block producer, if present.</p>
<h2 id="transactiondata"><a class="header" href="#transactiondata"><code>TransactionData</code></a></h2>
<pre><code class="language-rust ignore">pub struct TransactionData {
    pub transaction: Transaction,
    pub status: TransactionStatus,
    pub receipts: Vec&lt;Receipt&gt;,
    pub id: TxId,
}</code></pre>
<p>The <code>TransactionData</code> struct contains important information about a transaction in the Fuel network. The <code>id</code> field is the transaction hash, which is a 32-byte string. The <code>receipts</code> field contains a list of <code>Receipts</code>, which are generated by a Fuel node during the execution of a Sway smart contract; you can find more information in the <a href="reference-guide/indexing/./receipts/index.html">Receipts</a> section.</p>
<h3 id="transaction"><a class="header" href="#transaction"><code>Transaction</code></a></h3>
<pre><code class="language-rust ignore">pub enum Transaction {
    Script(Script),
    Create(Create),
    Mint(Mint),
}</code></pre>
<p><code>Transaction</code> refers to the Fuel transaction entity and can be one of three distinct types: <code>Script</code>, <code>Create</code>, or <code>Mint</code>. Explaining the differences between each of the types is out of scope for the Fuel indexer; however, you can find information about the <code>Transaction</code> type in the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/transaction.md">Fuel specifications</a>.</p>
<pre><code class="language-c++ ignore">enum TransactionType : uint8 {
    Script = 0,
    Create = 1,
    Mint = 2,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/transaction.md#transaction">TransactionType</a></td><td>Transaction type.</td></tr>
<tr><td><code>data</code></td><td>One of <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/transaction.md#transactionscript">TransactionScript</a>, <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/transaction.md#transactioncreate">TransactionCreate</a>, or <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/transaction.md#transactionmint">TransactionMint</a></td><td>Transaction data.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>type &gt; TransactionType.Create</code></li>
<li><code>gasLimit &gt; MAX_GAS_PER_TX</code></li>
<li><code>blockheight() &lt; maturity</code></li>
<li><code>inputsCount &gt; MAX_INPUTS</code></li>
<li><code>outputsCount &gt; MAX_OUTPUTS</code></li>
<li><code>witnessesCount &gt; MAX_WITNESSES</code></li>
<li>No inputs are of type <code>InputType.Coin</code> or <code>InputType.Message</code></li>
<li>More than one output is of type <code>OutputType.Change</code> for any asset ID in the input set</li>
<li>Any output is of type <code>OutputType.Change</code> for any asset ID not in the input set</li>
<li>More than one input of type <code>InputType.Coin</code> for any <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/id/utxo.md#coin-id">Coin ID</a> in the input set</li>
<li>More than one input of type <code>InputType.Contract</code> for any <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/id/utxo.md#contract-id">Contract ID</a> in the input set</li>
<li>More than one input of type <code>InputType.Message</code> for any <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/id/utxo.md#message-id">Message ID</a> in the input set</li>
</ul>
<p>When serializing a transaction, fields are serialized as follows (with inner structs serialized recursively):</p>
<ol>
<li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>: big-endian right-aligned to 8 bytes.</li>
<li><code>byte[32]</code>: as-is.</li>
<li><code>byte[]</code>: as-is, with padding zeroes aligned to 8 bytes.</li>
</ol>
<p>When deserializing a transaction, the reverse is done. If there are insufficient bytes or too many bytes, the transaction is invalid.</p>
<h4 id="transactionscript"><a class="header" href="#transactionscript">TransactionScript</a></h4>
<pre><code class="language-c++ ignore">enum ReceiptType : uint8 {
    Call = 0,
    Return = 1,
    ReturnData = 2,
    Panic = 3,
    Revert = 4,
    Log = 5,
    LogData = 6,
    Transfer = 7,
    TransferOut = 8,
    ScriptResult = 9,
    MessageOut = 10,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>gasPrice</code></td><td><code>uint64</code></td><td>Gas price for transaction.</td></tr>
<tr><td><code>gasLimit</code></td><td><code>uint64</code></td><td>Gas limit for transaction.</td></tr>
<tr><td><code>maturity</code></td><td><code>uint32</code></td><td>Block until which tx cannot be included.</td></tr>
<tr><td><code>scriptLength</code></td><td><code>uint16</code></td><td>Script length, in instructions.</td></tr>
<tr><td><code>scriptDataLength</code></td><td><code>uint16</code></td><td>Length of script input data, in bytes.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint8</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint8</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint8</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>receiptsRoot</code></td><td><code>byte[32]</code></td><td>Merkle root of receipts.</td></tr>
<tr><td><code>script</code></td><td><code>byte[]</code></td><td>Script to execute.</td></tr>
<tr><td><code>scriptData</code></td><td><code>byte[]</code></td><td>Script input data (parameters).</td></tr>
<tr><td><code>inputs</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/input.md">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/output.md">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/witness.md">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Given helper <code>len()</code> that returns the number of bytes of a field.</p>
<p>Transaction is invalid if:</p>
<ul>
<li>Any output is of type <code>OutputType.ContractCreated</code></li>
<li><code>scriptLength &gt; MAX_SCRIPT_LENGTH</code></li>
<li><code>scriptDataLength &gt; MAX_SCRIPT_DATA_LENGTH</code></li>
<li><code>scriptLength * 4 != len(script)</code></li>
<li><code>scriptDataLength != len(scriptData)</code></li>
</ul>
<blockquote>
<p>IMPORTANT:</p>
<p>When signing a transaction, <code>receiptsRoot</code> is set to zero.</p>
<p>When verifying a predicate, <code>receiptsRoot</code> is initialized to zero.</p>
<p>When executing a script, <code>receiptsRoot</code> is initialized to zero.</p>
</blockquote>
<p>The receipts root <code>receiptsRoot</code> is the root of the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/cryptographic_primitives.md#binary-merkle-tree">binary Merkle tree</a> of receipts. If there are no receipts, its value is set to the root of the empty tree, i.e. <code>0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</code>.</p>
<h4 id="transactioncreate"><a class="header" href="#transactioncreate">TransactionCreate</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>gasPrice</code></td><td><code>uint64</code></td><td>Gas price for transaction.</td></tr>
<tr><td><code>gasLimit</code></td><td><code>uint64</code></td><td>Gas limit for transaction.</td></tr>
<tr><td><code>maturity</code></td><td><code>uint32</code></td><td>Block until which tx cannot be included.</td></tr>
<tr><td><code>bytecodeLength</code></td><td><code>uint16</code></td><td>Contract bytecode length, in instructions.</td></tr>
<tr><td><code>bytecodeWitnessIndex</code></td><td><code>uint8</code></td><td>Witness index of contract bytecode to create.</td></tr>
<tr><td><code>storageSlotsCount</code></td><td><code>uint16</code></td><td>Number of storage slots to initialize.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint8</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint8</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint8</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>salt</code></td><td><code>byte[32]</code></td><td>Salt.</td></tr>
<tr><td><code>storageSlots</code></td><td><code>(byte[32], byte[32]])[]</code></td><td>List of storage slots to initialize (key, value).</td></tr>
<tr><td><code>inputs</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/input.md">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/output.md">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/witness.md">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>Any input is of type <code>InputType.Contract</code></li>
<li>Any output is of type <code>OutputType.Contract</code> or <code>OutputType.Variable</code></li>
<li>More than one output is of type <code>OutputType.Change</code> with <code>asset_id</code> of zero</li>
<li>Any output is of type <code>OutputType.Change</code> with non-zero <code>asset_id</code></li>
<li>It does not have exactly one output of type <code>OutputType.ContractCreated</code></li>
<li><code>bytecodeLength * 4 &gt; CONTRACT_MAX_SIZE</code></li>
<li><code>tx.data.witnesses[bytecodeWitnessIndex].dataLength != bytecodeLength * 4</code></li>
<li><code>bytecodeWitnessIndex &gt;= tx.witnessesCount</code></li>
<li>The keys of <code>storageSlots</code> are not in ascending lexicographic order</li>
<li>The computed contract ID (see below) is not equal to the <code>contractID</code> of the one <code>OutputType.ContractCreated</code> output</li>
<li><code>storageSlotsCount &gt; MAX_STORAGE_SLOTS</code></li>
<li>The <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/cryptographic_primitives.md#sparse-merkle-tree">Sparse Merkle tree</a> root of <code>storageSlots</code> is not equal to the <code>stateRoot</code> of the one <code>OutputType.ContractCreated</code> output</li>
</ul>
<p>Creates a contract with contract ID as computed <a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/id/contract.md">here</a>.</p>
<h4 id="transactionmint"><a class="header" href="#transactionmint">TransactionMint</a></h4>
<p>The transaction is created by the block producer and is not signed. Since it is not usable outside of block creation or execution, all fields must be fully set upon creation without any zeroing.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>txPointer</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/tx_pointer.md">TXPointer</a></td><td>The location of the <code>Mint</code> transaction in the block.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint8</code></td><td>Number of outputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/tx_format/output.md">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>Any output is not of type <code>OutputType.Coin</code></li>
<li>Any two outputs have the same <code>asset_id</code></li>
<li><code>txPointer</code> is zero or doesn't match the block.</li>
</ul>
<h3 id="transactionstatus"><a class="header" href="#transactionstatus"><code>TransactionStatus</code></a></h3>
<pre><code class="language-rust ignore">pub enum TransactionStatus {
    Failure {
        block_id: String,
        time: DateTime&lt;Utc&gt;,
        reason: String,
    },
    SqueezedOut {
        reason: String,
    },
    Submitted {
        submitted_at: DateTime&lt;Utc&gt;,
    },
    Success {
        block_id: String,
        time: DateTime&lt;Utc&gt;,
    },
}</code></pre>
<p><code>TransactionStatus</code> refers to the status of a <code>Transaction</code> in the Fuel network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receipts"><a class="header" href="#receipts">Receipts</a></h1>
<p>Every transaction in the Fuel network contains a list of receipts with information about that transaction, including what contract function was called, logged data, data returned from a function, etc.</p>
<p>There are several types of receipts that can be attached to a transaction and indexed. You can learn more about each of these in the sections below.</p>
<ul>
<li><a href="reference-guide/indexing/./receipts/call.html"><strong>Call</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/log.html"><strong>Log</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/logdata.html"><strong>LogData</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/messageout.html"><strong>MessageOut</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/return.html"><strong>Return</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/returndata.html"><strong>ReturnData</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/transfer.html"><strong>Transfer</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/transferout.html"><strong>TransferOut</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/scriptresult.html"><strong>ScriptResult</strong></a></li>
<li><a href="reference-guide/indexing/./receipts/revert.html"><strong>Revert</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call"><a class="header" href="#call">Call</a></h1>
<pre><code class="language-rust  ignore">use fuel_types::{AssetId, ContractId};
pub struct Call {
    pub contract_id: ContractId,
    pub to: ContractId,
    pub amount: u64,
    pub asset_id: AssetId,
    pub gas: u64,
    pub fn_name: String,
}</code></pre>
<ul>
<li>A <code>Call</code> receipt is generated whenever a function is called in a Sway contract.</li>
<li>The <code>fn_name</code> field contains the name of the called function from the aforementioned contract.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#return-receipt">Read more about <code>Call</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>Call</code> receipt type by adding a parameter with the type <code>abi::Call</code>.</p>
<pre><code class="language-rust  ignore">fn handle_log(call: abi::Call) {
  // handle all functions that produce a Call receipt
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log"><a class="header" href="#log">Log</a></h1>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Log {
    pub contract_id: ContractId,
    pub ra: u64,
    pub rb: u64,
}</code></pre>
<ul>
<li>A <code>Log</code> receipt is generated when calling <code>log()</code> on a non-reference types in a Sway contracts.
<ul>
<li>Specifically <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>.</li>
</ul>
</li>
<li>The <code>ra</code> field includes the value being logged while <code>rb</code> may include a non-zero value representing a unique ID for the <code>log</code> instance.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#log-receipt">Read more about <code>Log</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>Log</code> receipt type by adding a parameter with the type <code>abi::Log</code>.</p>
<pre><code class="language-rust  ignore">fn handle_log(log: abi::Log) {
  // handle all functions that produce a log receipt
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logdata"><a class="header" href="#logdata">LogData</a></h1>
<pre><code class="language-rust ignore">use fuel_types::ContractId;
pub struct LogData {
    pub contract_id: ContractId,
    pub data: Vec&lt;u8&gt;,
    pub rb: u64,
    pub len: u64,
    pub ptr: u64,
}</code></pre>
<ul>
<li>A <code>LogData</code> receipt is generated when calling <code>log()</code> in a Sway contract on a reference type; this includes all types <em>except</em> non-reference types.</li>
<li>The <code>data</code> field will include the logged value as a hexadecimal.
<ul>
<li>The <code>rb</code> field will contain a unique ID that can be used to look up the logged data type.</li>
</ul>
</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#logdata-receipt">Read more about <code>LogData</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>LogData</code> receipt type by using the logged type as a function parameter.</p>
<blockquote>
<p>Note: the example below will run both when the type <code>MyStruct</code> is logged as well as when <code>MyStruct</code> is returned from a function.</p>
</blockquote>
<pre><code class="language-rust  ignore">fn handle_log_data(data: MyStruct) {
  // handle the logged data
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messageout"><a class="header" href="#messageout">MessageOut</a></h1>
<pre><code class="language-rust ignore">use fuel_types::{MessageId, Bytes32, Address};
pub struct MessageOut {
    pub message_id: MessageId,
    pub sender: Address,
    pub recipient: Address,
    pub amount: u64,
    pub nonce: Bytes32,
    pub len: u64,
    pub digest: Bytes32,
    pub data: Vec&lt;u8&gt;,
}</code></pre>
<ul>
<li>A <code>MessageOut</code> receipt is generated as a result of the <code>send_typed_message()</code> Sway method in which a message is sent to a recipient address along with a certain amount of coins.</li>
<li>The <code>data</code> field supports data of an arbitrary type <code>T</code> and will be decoded by the indexer upon receipt.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#messageout-receipt">Read more about <code>MessageOut</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>MessageOut</code> receipt type by adding a parameter with the type <code>abi::MessageOut</code>.</p>
<pre><code class="language-rust  ignore">fn handle_message_out(message_out: abi::MessageOut) {
  // handle the message out
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">Panic</a></h1>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Panic {
    pub contract_id: ContractId, 
    pub reason: u32, 
}</code></pre>
<ul>
<li>A <code>Panic</code> receipt is produced when a Sway smart contract call fails for a reason that doesn't produce a revert. </li>
<li>The reason field records the reason for the panic, which is represented by a number between 0 and 255. You can find the mapping between the values and their meanings here in the FuelVM <a href="https://github.com/FuelLabs/fuel-vm/blob/master/fuel-asm/src/panic_reason.rs">source code</a>.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#panic-receipt">Read more about <code>Panic</code> in the Fuel Protocol spec</a></li>
<li>You can handle functions that could produce a <code>Panic</code> receipt by adding a parameter with the type <code>abi::Panic</code>.</li>
</ul>
<pre><code class="language-rust  ignore">fn handle_panic(panic: abi::Panic) {
  // handle the panic 
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return"><a class="header" href="#return">Return</a></h1>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Return {
    pub contract_id: ContractId,
    pub val: u64,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<ul>
<li>A <code>Return</code> receipt is generated when returning a non-reference type in a Sway contract.
<ul>
<li>Specifically <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>u64</code>.</li>
</ul>
</li>
<li>The <code>val</code> field includes the value being returned.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#return-receipt">Read more about <code>Log</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>Return</code> receipt type by adding a parameter with the type <code>abi::Return</code>.</p>
<pre><code class="language-rust  ignore">fn handle_return(data: abi::Return) {
  // handle the returned data
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returndata"><a class="header" href="#returndata">ReturnData</a></h1>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct ReturnData {
    id: ContractId,
    data: Vec&lt;u8&gt;,
}</code></pre>
<ul>
<li>A <code>ReturnData</code> receipt is generated when returning a reference type in a Sway contract; this includes all types <em>except</em> non-reference types.</li>
<li>The <code>data</code> field will include the returned value as a hexadecimal.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#returndata-receipt">Read more about <code>ReturnData</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>ReturnData</code> receipt type by using the returned type as a function parameter.</p>
<blockquote>
<p>Note: the example below will run both when the type <code>MyStruct</code> is logged as well as when <code>MyStruct</code> is returned from a function.</p>
</blockquote>
<pre><code class="language-rust  ignore">fn handle_return_data(data: MyStruct) {
  // handle the returned data
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revert"><a class="header" href="#revert">Revert</a></h1>
<pre><code class="language-rust  ignore">use fuel_types::ContractId;
pub struct Revert {
    pub contract_id: ContractId,
    pub error_val: u64,
  }</code></pre>
<ul>
<li>A <code>Revert</code> receipt is produced when a Sway smart contract function call fails. </li>
<li>The table below lists possible reasons for the failure and their values. </li>
<li>The <code>error_val</code> field records these values, enabling your indexer to identify the specific cause of the reversion.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Reason</th><th>Value</th></tr></thead><tbody>
<tr><td>FailedRequire</td><td>0</td></tr>
<tr><td>FailedTransferToAddress</td><td>1</td></tr>
<tr><td>FailedSendMessage</td><td>2</td></tr>
<tr><td>FailedAssertEq</td><td>3</td></tr>
<tr><td>FailedAssert</td><td>4</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#revert-receipt">Read more about <code>Revert</code> in the Fuel Protocol spec</a></li>
</ul>
<p>You can handle functions that could produce a <code>Revert</code> receipt by adding a parameter with the type <code>abi::Revert</code>.</p>
<pre><code class="language-rust  ignore">fn handle_revert(revert: abi::Revert) {
  // handle the revert 
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptresult"><a class="header" href="#scriptresult">ScriptResult</a></h1>
<pre><code class="language-rust ignore">pub struct ScriptResult {
    pub result: u64,
    pub gas_used: u64,
}</code></pre>
<ul>
<li>A <code>ScriptResult</code> receipt is generated when a contract call resolves; that is, it's generated as a result of the <code>RET</code>, <code>RETD</code>, and <code>RVRT</code> instructions.</li>
<li>The <code>result</code> field will contain a <code>0</code> for success, and a non-zero value otherwise.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#scriptresult-receipt">Read more about <code>ScriptResult</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>ScriptResult</code> receipt type by adding a parameter with the type <code>abi::ScriptResult</code>.</p>
<pre><code class="language-rust  ignore">fn handle_script_result(script_result: abi::ScriptResult) {
  // handle the script result
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer"><a class="header" href="#transfer">Transfer</a></h1>
<pre><code class="language-rust ignore">use fuel_types::{ContractId, AssetId};
pub struct Transfer {
    pub contract_id: ContractId,
    pub to: ContractId,
    pub amount: u64,
    pub asset_id: AssetId,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<ul>
<li>A <code>Transfer</code> receipt is generated when coins are transferred to a contract as part of a Sway contract.</li>
<li>The <code>asset_id</code> field contains the asset ID of the transferred coins, as the FuelVM has built-in support for working with multiple assets.
<ul>
<li>The <code>pc</code> and <code>is</code> fields aren't currently used for anything, but are included for completeness.</li>
</ul>
</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#transfer-receipt">Read more about <code>Transfer</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>Transfer</code> receipt type by adding a parameter with the type <code>abi::Transfer</code>.</p>
<pre><code class="language-rust  ignore">fn handle_transfer(transfer: abi::Transfer) {
  // handle the transfer
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transferout"><a class="header" href="#transferout">TransferOut</a></h1>
<pre><code class="language-rust ignore">use fuel_types::{ContractId, AssetId, Address};
pub struct TransferOut {
    pub contract_id: ContractId,
    pub to: Address,
    pub amount: u64,
    pub asset_id: AssetId,
    pub pc: u64,
    pub is: u64,
}</code></pre>
<ul>
<li>A <code>TransferOut</code> receipt is generated when coins are transferred to an address rather than a contract.</li>
<li>Every other field of the receipt works the same way as it does in the <code>Transfer</code> receipt.</li>
<li><a href="https://github.com/FuelLabs/fuel-specs/blob/master/src/protocol/abi/receipts.md#transferout-receipt">Read more about <code>TransferOut</code> in the Fuel protocol ABI spec</a></li>
</ul>
<p>You can handle functions that produce a <code>TransferOut</code> receipt type by adding a parameter with the type <code>abi::TransferOut</code>.</p>
<pre><code class="language-rust  ignore">fn handle_transferout(transfer_out: abi::TransferOut) {
  // handle the transfer out
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Below is a mapping of GraphQL schema types to their Sway and database equivalents.</p>
<div class="table-wrapper"><table><thead><tr><th>Sway Type</th><th>GraphQL Schema Type</th><th>Postgres Type</th></tr></thead><tbody>
<tr><td>u64</td><td>ID</td><td>bigint primary key</td></tr>
<tr><td>b256</td><td>Address</td><td>varchar(64)</td></tr>
<tr><td>str[4]</td><td>Bytes4</td><td>varchar(16)</td></tr>
<tr><td>str[8]</td><td>Bytes8</td><td>varchar(64)</td></tr>
<tr><td>str[32]</td><td>Bytes32</td><td>varchar(64)</td></tr>
<tr><td>str[32]</td><td>AssetId</td><td>varchar(64)</td></tr>
<tr><td>b256</td><td>ContractId</td><td>varchar(64)</td></tr>
<tr><td>str[32]</td><td>Salt</td><td>varchar(64)</td></tr>
<tr><td>u32</td><td>UInt4</td><td>integer</td></tr>
<tr><td>u64</td><td>UInt8</td><td>bigint</td></tr>
<tr><td>i64</td><td>Timestamp</td><td>timestamp</td></tr>
<tr><td>str[]</td><td>Blob</td><td>bytes</td></tr>
<tr><td>str[32]</td><td>MessageId</td><td>varchar(64)</td></tr>
<tr><td>bool</td><td>Boolean</td><td>bool</td></tr>
<tr><td></td><td>Json</td><td>json</td></tr>
<tr><td></td><td>Charfield</td><td>varchar(255)</td></tr>
<tr><td></td><td>Blob</td><td>varchar(10485760)</td></tr>
</tbody></table>
</div>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's define an <code>Event</code> struct in a Sway contract:</p>
<pre><code class="language-sway">struct Event {
    id: u64,
    address: Address,
    block_height: u64,
}
</code></pre>
<p>The corresponding GraphQL schema to mirror this <code>Event</code> struct would resemble:</p>
<pre><code class="language-graphql">type Event {
    id: ID!
    account: Address!
    block_height: UInt8!
}
</code></pre>
<p>And finally, this GraphQL schema will generate the following Postgres schema:</p>
<pre><code class="language-text">                                           Table &quot;schema.event&quot;
    Column   |     Type    | Collation | Nullable | Default | Storage  | Compression | Stats target | Description
--------------+-------------+-----------+----------+---------+----------+-------------+--------------+-------------
 id           |    bigint   |           | not null |         | plain    |             |              |
 block_height |    bigint   |           | not null |         | plain    |             |              |
 address      | varchar(64) |           | not null |         | plain    |             |              |
 object       |    bytea    |           | not null |         | extended |             |              |
Indexes:
    &quot;event_pkey&quot; PRIMARY KEY, btree (id)
Access method: heap
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql"><a class="header" href="#graphql">GraphQL</a></h1>
<p>The Fuel indexer uses GraphQL to in order to allow users to query for indexed data. Please note that the Fuel indexer does not support the full GraphQL specification; however, we do our best to reasonably support as much as we can. In this chapter, you can find information on how to leverage our supported features to efficiently get the data you want.</p>
<ul>
<li><a href="reference-guide/components/graphql/./schema.html">Schema</a></li>
<li><a href="reference-guide/components/graphql/./directives.html">Directives</a></li>
<li><a href="reference-guide/components/graphql/./api-server.html">GraphQL API Server</a></li>
<li><a href="reference-guide/components/graphql/./queries.html">Queries</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-schema-1"><a class="header" href="#graphql-schema-1">GraphQL Schema</a></h1>
<p>The GraphQL schema is a required component of the Fuel indexer. When data is indexed into the database, the actual values that are persisted to the database will be values created using the data structures defined in the schema.</p>
<p>In its most basic form, a Fuel indexer GraphQL schema should have a <code>schema</code> definition that contains a defined query root. The rest of the implementation is up to you. Here's an example of a well-formed schema:</p>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    thing1: FirstThing
    thing2: SecondThing
}

type FirstThing {
    id: ID!
    value: UInt8!
}

type SecondThing {
    id: ID!
    optional_value: UInt8
    timestamp: Timestamp!
}
</code></pre>
<p>The types you see above (e.g., <code>ID</code>, <code>UInt8</code>, etc) are Fuel abstractions that were created to more seamlessly integrate with the Fuel VM and are not native to GraphQL. A deeper explanation on these
types can be found in <a href="reference-guide/components/graphql/../../data-types/types.html">the Types section</a>.</p>
<blockquote>
<p>Important: It is up to developers to manage their own unique IDs for each type, meaning that a data structure's <code>ID</code> field needs to be manually generated prior to saving it to the database. This generation can be as simple or complex as you want in order to fit your particular situation; the only requirement is that the developer implement their own custom generation. Examples can be found in the <a href="reference-guide/components/graphql/../../../examples/block-explorer.html">Block Explorer</a> and <a href="reference-guide/components/graphql/../../../examples/hello-world.html">Hello World</a> sections.</p>
</blockquote>
<h2 id="required-and-optional-fields-1"><a class="header" href="#required-and-optional-fields-1">Required and Optional Fields</a></h2>
<p>Required fields are denoted with a <code>!</code> following its type; for example, the <code>value</code> field of the <code>FirstThing</code> type is a <code>UInt8</code> and is required to be present for the indexer to successfully persist the entity. If a certain piece of information is essential to your use case, then you should mark that field as required.</p>
<p>In contrast, optional fields are not required to be present for the indexer to persist the entity in storage. You can denote an optional field by just using the type name; for example, the <code>optional_value</code> field of the <code>SecondThing</code> type is optional, and should be a <code>UInt8</code> if present. If it's possible that a value might not always exist in the data you wish to index, consider making that the corresponding field optional. In your indexer code, you will need to use the <code>Option</code> Rust type when assigning a value to an optional field; values that are present should be assigned after being wrapped in <code>Some(..)</code> while absent values should be assigned using <code>None</code>.</p>
<blockquote>
<p>Important: The <code>ID</code> field is <em>always</em> required. An indexer <strong>will</strong> return an error if an optional value is used for the <code>ID</code> field.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="directives"><a class="header" href="#directives">Directives</a></h1>
<blockquote>
<p>Per GraphQL: A directive is a keyword preceded by a @ character (optionally followed by a list of named arguments) which can appear after almost any form of syntax in the GraphQL query or schema languages.</p>
</blockquote>
<p>As of this writing, the list of supported Fuel GraphQL schema directives includes:</p>
<ul>
<li><code>@indexed</code></li>
<li><code>@unique</code></li>
<li><code>@join</code></li>
</ul>
<h2 id="indexed"><a class="header" href="#indexed"><code>@indexed</code></a></h2>
<p>The <code>@indexed</code> directive adds a <a href="https://www.postgresql.org/docs/current/indexes-intro.html">database index</a> to the underlying column for the indicated field of that type. Generally, a database index is a data structure that allows you to quickly locate data without having to search each row in a database table.</p>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    book: Book
    library: Library
}

type Book {
    id: ID!
    name: Bytes8! @indexed
}

type Library {
    id: ID!
    book: Book!
}
</code></pre>
<p>In this example, a single <code>BTREE INDEX</code> constraint will be created on the <code>book</code> table's <code>name</code> column, which allows for faster lookups on that field.</p>
<blockquote>
<p>Important: At the moment, database index constraint support is limited to <code>BTREE</code> in Postgres with <code>ON DELETE</code>, and <code>ON UPDATE</code> actions not being supported.</p>
</blockquote>
<h2 id="unique"><a class="header" href="#unique"><code>@unique</code></a></h2>
<p>The <code>@unique</code> directive adds a <code>UNIQUE</code> database constraint to the underlying database column for the indicated field of that type. A constraint specifies a rule for the data in a table and can be used to limit the type of data that can be placed in the table. In the case of a column with a <code>UNIQUE</code> constraint, all values in the column must be different.</p>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    book: Book
    library: Library
}

type Book {
    id: ID!
    name: Bytes8! @unique
}

type Library {
    id: ID!
    book: Book!
}
</code></pre>
<p>A <code>UNIQUE</code> constraint will be created on the <code>book</code> table's <code>name</code> column, ensuring that no books can share the same name.</p>
<blockquote>
<p>Important: When using explict or implicit foreign keys, it is required that the reference column name in your foreign key relationship be unique. <code>ID</code> types are by default unique, but all other types will have to be explicitly specified as being unique via the <code>@unique</code> directive.</p>
</blockquote>
<h2 id="join"><a class="header" href="#join"><code>@join</code></a></h2>
<p>The <code>@join</code> directive is used to relate a field in one type to others by referencing fields in another type. You can think of it as a link between two tables in your database. The field in the referenced type is called a <em>foreign key</em> and it is <strong>required</strong> to be unique.</p>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    book: Book
    library: Library
}

type Book {
    id: ID!
    name: Bytes8! @unique
}

type Library {
    id: ID!
    book: Book! @join(on:name)
}
</code></pre>
<p>A foreign key constraint will be created on <code>library.book</code> that references <code>book.name</code>, which relates the <code>Book</code>s in a <code>Library</code> to the underlying <code>Book</code> table.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-api-server"><a class="header" href="#graphql-api-server">GraphQL API Server</a></h1>
<ul>
<li>The <code>fuel-indexer-api-server</code> crate of the Fuel indexer contains a standalone GraphQL API server that acts as a queryable endpoint on top of the database.</li>
<li>Note that the main <code>fuel-indexer</code> binary of the indexer project also contains a queryable GraphQL API endpoint.</li>
</ul>
<blockquote>
<p>The <code>fuel-indexer-api-server</code> crate offers a <em>standalone</em> GraphQL API endpoint, whereas the GraphQL endpoint offered in <code>fuel-indexer</code> is bundled with other Fuel indexer functionality (e.g., execution, handling, data-layer contruction, etc).</p>
</blockquote>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To run the standalone Fuel indexer GraphQL API server using a configuration file:</p>
<pre><code class="language-bash">fuel-indexer-api-server run --config config.yaml
</code></pre>
<p>In the above example, <code>config.yaml</code> is based on <a href="https://github.com/FuelLabs/fuel-indexer/blob/master/config.yaml">the default service configuration file</a>.</p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<pre><code class="language-text">USAGE:
    fuel-indexer-api-server run [OPTIONS]

OPTIONS:
        --auth-enabled
            Require users to authenticate for some operations.

        --auth-strategy &lt;AUTH_STRATEGY&gt;
            Authentication scheme used.

    -c, --config &lt;CONFIG&gt;
            API server config file.

        --database &lt;DATABASE&gt;
            Database type. [default: postgres] [possible values: postgres]

        --fuel-node-host &lt;FUEL_NODE_HOST&gt;
            Host of the running Fuel node. [default: localhost]

        --fuel-node-port &lt;FUEL_NODE_PORT&gt;
            Listening port of the running Fuel node. [default: 4000]

        --graphql-api-host &lt;GRAPHQL_API_HOST&gt;
            GraphQL API host. [default: localhost]

        --graphql-api-port &lt;GRAPHQL_API_PORT&gt;
            GraphQL API port. [default: 29987]

    -h, --help
            Print help information

        --jwt-expiry &lt;JWT_EXPIRY&gt;
            Amount of time (seconds) before expiring token (if JWT scheme is specified).

        --jwt-issuer &lt;JWT_ISSUER&gt;
            Issuer of JWT claims (if JWT scheme is specified).

        --jwt-secret &lt;JWT_SECRET&gt;
            Secret used for JWT scheme (if JWT scheme is specified).

        --max-body-size &lt;MAX_BODY_SIZE&gt;
            Max body size for GraphQL API requests. [default: 5242880]

        --metrics
            Use Prometheus metrics reporting.

        --postgres-database &lt;POSTGRES_DATABASE&gt;
            Postgres database.

        --postgres-host &lt;POSTGRES_HOST&gt;
            Postgres host.

        --postgres-password &lt;POSTGRES_PASSWORD&gt;
            Postgres password.

        --postgres-port &lt;POSTGRES_PORT&gt;
            Postgres port.

        --postgres-user &lt;POSTGRES_USER&gt;
            Postgres username.

        --run-migrations
            Run database migrations before starting service.

    -V, --version
            Print version information

    -v, --verbose
            Enable verbose logging.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-playground"><a class="header" href="#graphql-playground">GraphQL Playground</a></h1>
<p>The Fuel indexer's GraphQL Playground is an interactive, in-browser GraphQL IDE that allows developers to easily explore and test the indexer's GraphQL API server. You can read more about the GraphQL playground in general <a href="https://github.com/graphql/graphql-playground">here</a>.</p>
<p>Every public indexer can access the GraphQL playground of the Fuel indexer node on which the given indexer runs, so users and devs can get to querying their data right away.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>To use the GraphQL playground to explor your indices, simply <a href="reference-guide/components/graphql/../../../getting-started/starting-the-fuel-indexer.html">start your indexer service</a> - then open the following URL in your browser - where <code>namespace</code> and <code>identifier</code> correspond to the namespace and identifier of the index that you'd like to explore.</p>
<pre><code class="language-bash">http://localhost:29987/api/playground/:namespace/:identifier
</code></pre>
<blockquote>
<p>NOTE: On initial page render, the playground throws a 500. Don't worry about this, you should still be able to query.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-1"><a class="header" href="#database-1">Database</a></h1>
<p>The Fuel indexer uses <a href="https://github.com/docker-library/postgres/blob/2f6878ca854713264ebb27c1ba8530c884bcbca5/14/bullseye/Dockerfile">PostgreSQL</a> as the primary database. We're open to supporting other storage solutions in the future.</p>
<p>In this chapter, you can find information regarding how your data should be structured for use in the Fuel indexer:</p>
<ul>
<li><a href="reference-guide/components/database/./foreign-keys.html">Foreign Keys</a>
<ul>
<li>How foreign keys are handled in the Fuel indexer.</li>
</ul>
</li>
<li><a href="reference-guide/components/database/./ids.html">‚ö†Ô∏è IDs</a>
<ul>
<li>Explains some conventions surrounding the usage of <code>ID</code> types</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-keys"><a class="header" href="#foreign-keys">Foreign Keys</a></h1>
<ul>
<li>The Fuel indexer service supports foreign key constraints and relationships using a combination of GraphQL schema and a database.</li>
<li>There are two types of uses for foreign keys - <em>implicit</em> and <em>explicit</em>.</li>
</ul>
<blockquote>
<p>IMPORTANT:</p>
<p>Implicit foreign keys do not require a <code>@join</code> directive. When using implicit foreign key references, merely add the referenced object as a field type (shown below). A lookup will automagically be done to add a foreign key constraint using this object's' <code>id</code> field.</p>
<p>Note that implicit foreign key relationships <em>only</em> use the <code>id</code> field on the referenced table. If you plan to use implicit foreign keys, the object being referenced <em>must</em> have an <code>id</code> field.</p>
<p>In contrast, explicit foreign keys <em>do</em> require a <code>@join</code> directive. Explicit foreign key references work similarly to implicit foreign keys; however, when using explicit foreign key references, you must add a <code>@join</code> directive after your object type. This <code>@join</code> directive includes the field in your foreign object that you would like to reference (shown below).</p>
</blockquote>
<p>Let's learn how to use each foreign key type by looking at some GraphQL schema examples.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="implicit-foreign-keys"><a class="header" href="#implicit-foreign-keys">Implicit foreign keys</a></h3>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    book: Book
    library: Library
}

type Book {
    id: ID!
    name: Bytes8!
}

type Library {
    id: ID!
    book: Book!
}
</code></pre>
<h4 id="implicit-foreign-key-breakdown"><a class="header" href="#implicit-foreign-key-breakdown">Implicit foreign key breakdown</a></h4>
<p>Given the above schema, two entities will be created: a <code>Book</code> entity, and a <code>Library</code> entity. As you can see, we add the <code>Book</code> entity as an attribute on the <code>Library</code> entity, thus conveying that we want a one-to-many or one-to-one relationship between <code>Library</code> and <code>Book</code>. This means that for a given <code>Library</code>, we may also fetch one or many <code>Book</code> entities. It also means that the column <code>library.book</code> will be an integer type that references <code>book.id</code>.</p>
<h3 id="explicit-foreign-keys"><a class="header" href="#explicit-foreign-keys">Explicit foreign keys</a></h3>
<pre><code class="language-graphql">schema {
    query: QueryRoot
}

type QueryRoot {
    book: Book
    library: Library
}

type Book {
    id: ID!
    name: Bytes8! @unique
}

type Library {
    id: ID!
    book: Book! @join(on:name)
}
</code></pre>
<h4 id="explicit-foreign-key-breakdown"><a class="header" href="#explicit-foreign-key-breakdown">Explicit foreign key breakdown</a></h4>
<p>For the most part, this works the same way as implicit foreign key usage. However, as you can see, instead of implicitly using <code>book.id</code> as the reference column for our <code>Book</code> object, we're instead explicitly specifying that we want <code>book.name</code> to serve as our foreign key. Also, please note that since we're using <code>book.name</code> in our foreign key constraint, that column is required to be unique (via the <code>@unique</code> directive).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="id-types"><a class="header" href="#id-types">ID Types</a></h1>
<p>There are a few important things related to the use of IDs.</p>
<blockquote>
<p><strong>Every GraphQL type defined in your schema file is required to have an id field.</strong></p>
<ul>
<li>This field must be called <code>id</code></li>
<li>The type of this <code>id</code> field must be a <code>u64</code>
<ul>
<li>You typically want to use the <code>ID</code> type for these <code>id</code> fields</li>
</ul>
</li>
</ul>
<p><strong>Why must every field have an ID?</strong></p>
<p>Since the Fuel Indexer uses WASM runtimes to index events, a foreign function interface (FFI) is needed to call in and out of the runtime. When these calls out of the runtime are made, a pointer is passed back to the indexer service to indicate the memory location for the <code>id</code> of the type/object/entity being saved.</p>
<p><strong>Is this liable to change in the future?</strong></p>
<p>Yes, ideally we'd like ID's to be of <em>any</em> type, and we plan to work towards this in the future. üëç</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuel-indexer-plugins"><a class="header" href="#fuel-indexer-plugins">Fuel Indexer Plugins</a></h1>
<ul>
<li><a href="reference-guide/plugins/./forc-index/index.html"><code>forc index</code></a>
<ul>
<li>A <a href="https://fuellabs.github.io/sway/v0.31.3/introduction/forc_project.html">Forc</a> plugin used to interact with a Fuel Indexer service.</li>
</ul>
</li>
<li><a href="reference-guide/plugins/./forc-postgres/index.html"><code>forc index postgres</code></a>
<ul>
<li>A subcommand of the <code>forc index</code> plugin that allows for bootstrapping and management of an embedded Postgres database.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index"><a class="header" href="#forc-index">forc index</a></h1>
<p><code>forc index</code> is the recommended method for end users to interact with the Fuel indexer. After you have installed <code>fuelup</code>, you can run the <code>forc index help</code> command in your terminal to view the available commands.</p>
<pre><code class="language-text">forc index help
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    build     Build an indexer
    check     Get status checks on all indexer components
    deploy    Deploy an indexer asset bundle to a remote or locally running indexer server
    help      Print this message or the help of the given subcommand(s)
    init      Create a new indexer project in the current directory
    new       Create a new indexer project in a new directory
    remove    Stop and remove a running indexer
    revert    Revert a running indexer to its previous version
    start     Start a local indexer service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-init"><a class="header" href="#forc-index-init"><code>forc index init</code></a></h1>
<p>Create a new indexer project in the current directory.</p>
<pre><code class="language-bash">forc index init --namespace fuel
</code></pre>
<pre><code class="language-text">Create a new indexer project in the current directory

USAGE:
    forc-index init [OPTIONS] --namespace &lt;NAMESPACE&gt;

OPTIONS:
        --absolute-paths           Resolve indexer asset filepaths using absolute paths.
    -h, --help                     Print help information
        --name &lt;NAME&gt;              Name of indexer.
        --namespace &lt;NAMESPACE&gt;    Namespace to which indexer belongs.
        --native                   Initialize an indexer with native execution enabled.
    -p, --path &lt;PATH&gt;              Path at which to create indexer.
    -v, --verbose                  Enable verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-new"><a class="header" href="#forc-index-new"><code>forc index new</code></a></h1>
<p>Create a new indexer project in a new directory.</p>
<pre><code class="language-bash">forc index new --namespace fuel --path /home/fuel/projects
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index new [OPTIONS] --namespace &lt;NAMESPACE&gt; &lt;PATH&gt;

ARGS:
    &lt;PATH&gt;    Path at which to create indexer

OPTIONS:
        --absolute-paths           Resolve indexer asset filepaths using absolute paths.
    -h, --help                     Print help information
        --name &lt;NAME&gt;              Name of indexer.
        --namespace &lt;NAMESPACE&gt;    Namespace to which indexer belongs.
        --native                   Whether to initialize an indexer with native execution enabled.
    -v, --verbose &lt;verbose&gt;        Enable verbose output. [default: true]

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-check"><a class="header" href="#forc-index-check"><code>forc index check</code></a></h1>
<p>Check to see which indexer components you have installed.</p>
<pre><code class="language-bash">forc index check
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index check [OPTIONS]

OPTIONS:
        --grpahql-api-port &lt;GRPAHQL_API_PORT&gt;
            Port at which to detect indexer service API is running. [default: 29987]

    -h, --help
            Print help information

        --url &lt;URL&gt;
            URL at which to find indexer service. [default: http://localhost:29987]
</code></pre>
<p>You can expect the command output to look something like this example in which the requisite components are installed but the indexer service is not running:</p>
<pre><code class="language-text">‚ûú  forc index check

‚ùå Could not connect to indexer service: error sending request for url (http://localhost:29987/api/health): error trying to connect: tcp connect error: Connection refused (os error 61)

+--------+------------------------+----------------------------------------------------------------------------+
| Status |       Component        |                                  Details                                   |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚úÖ   | fuel-indexer binary    |  Found 'fuel-indexer' at '/Users/me/.fuelup/bin/fuel-indexer'              |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚õîÔ∏è   | fuel-indexer service   |  Failed to detect a locally running fuel-indexer service at Port(29987).   |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚úÖ   | psql                   |  Found 'psql' at '/usr/local/bin/psql'                                     |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚úÖ   | fuel-core              |  Found 'fuel-core' at '/Users/me/.fuelup/bin/fuel-core'                    |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚úÖ   | docker                 |  Found 'docker' at '/usr/local/bin/docker'                                 |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚úÖ   | fuelup                 |  Found 'fuelup' at '/Users/me/.fuelup/bin/fuelup'                          |
+--------+------------------------+----------------------------------------------------------------------------+
|   ‚úÖ   | wasm-snip              |  Found 'wasm-snip' at '/Users/me/.cargo/bin/wasm-snip'                     |
+--------+------------------------+----------------------------------------------------------------------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-build"><a class="header" href="#forc-index-build"><code>forc index build</code></a></h1>
<p>Build an indexer.</p>
<pre><code class="language-bash">forc index build --release
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index build [OPTIONS]

OPTIONS:
    -h, --help                       Print help information
        --locked                     Ensure that the Cargo.lock file is up-to-date.
    -m, --manifest &lt;MANIFEST&gt;        Manifest file name of indexer being built.
        --native                     Building for native execution.
    -p, --path &lt;PATH&gt;                Path to the indexer project.
        --profile &lt;PROFILE&gt;          Build with the given profile.
    -r, --release                    Build optimized artifacts with the release profile. [default:
                                     true] 
        --target &lt;TARGET&gt;            Target at which to compile. [default: wasm32-unknown-unknown]
        --target-dir &lt;TARGET_DIR&gt;    Directory for all generated artifacts and intermediate files.
    -v, --verbose                    Enable verbose output.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-start"><a class="header" href="#forc-index-start"><code>forc index start</code></a></h1>
<p>Start a local Fuel Indexer service.</p>
<pre><code class="language-bash">forc index start
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index start [OPTIONS]

OPTIONS:
        --auth-enabled
            Require users to authenticate for some operations.

        --auth-strategy &lt;AUTH_STRATEGY&gt;
            Authentication scheme used.

    -c, --config &lt;FILE&gt;
            Indexer service config file.

        --database &lt;DATABASE&gt;
            Database type. [default: postgres] [possible values: postgres]

        --embedded-database
            Automatically create and start database using provided options or defaults.

        --fuel-node-host &lt;FUEL_NODE_HOST&gt;
            Host of the running Fuel node. [default: localhost]

        --fuel-node-port &lt;FUEL_NODE_PORT&gt;
            Listening port of the running Fuel node. [default: 4000]

        --graphql-api-host &lt;GRAPHQL_API_HOST&gt;
            GraphQL API host. [default: localhost]

        --graphql-api-port &lt;GRAPHQL_API_PORT&gt;
            GraphQL API port. [default: 29987]

    -h, --help
            Print help information

        --jwt-expiry &lt;JWT_EXPIRY&gt;
            Amount of time (seconds) before expiring token (if JWT scheme is specified).

        --jwt-issuer &lt;JWT_ISSUER&gt;
            Issuer of JWT claims (if JWT scheme is specified).

        --jwt-secret &lt;JWT_SECRET&gt;
            Secret used for JWT scheme (if JWT scheme is specified).

        --log-level &lt;LOG_LEVEL&gt;
            Log level passed to the Fuel Indexer service. [default: info] [possible values: info,
            debug, error, warn]

    -m, --manifest &lt;FILE&gt;
            Index config file.

        --max-body-size &lt;MAX_BODY_SIZE&gt;
            Max body size for GraphQL API requests. [default: 5242880]

        --metrics
            Use Prometheus metrics reporting.

        --postgres-database &lt;POSTGRES_DATABASE&gt;
            Postgres database.

        --postgres-host &lt;POSTGRES_HOST&gt;
            Postgres host.

        --postgres-password &lt;POSTGRES_PASSWORD&gt;
            Postgres password.

        --postgres-port &lt;POSTGRES_PORT&gt;
            Postgres port.

        --postgres-user &lt;POSTGRES_USER&gt;
            Postgres username.

        --run-migrations
            Run database migrations before starting service.

        --stop-idle-indexers
            Prevent indexers from running without handling any blocks.

    -V, --version
            Print version information

        --verbose
            Enable verbose logging.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-deploy"><a class="header" href="#forc-index-deploy"><code>forc index deploy</code></a></h1>
<p>Deploy an indexer to an indexer service.</p>
<pre><code class="language-bash">forc index deploy --url https://indexer.fuel.network
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index deploy [OPTIONS]

OPTIONS:
        --auth &lt;AUTH&gt;                Authentication header value.
    -h, --help                       Print help information
        --locked                     Ensure that the Cargo.lock file is up-to-date.
    -m, --manifest &lt;MANIFEST&gt;        Path to the manifest of indexer project being deployed.
        --native                     Building for native execution.
    -p, --path &lt;PATH&gt;                Path to the indexer project.
        --profile &lt;PROFILE&gt;          Build with the given profile.
    -r, --release                    Build optimized artifacts with the release profile. [default:
                                     true] 
        --skip-build                 Do not build before deploying.
        --target &lt;TARGET&gt;            Target at which to compile. [default: wasm32-unknown-unknown]
        --target-dir &lt;TARGET_DIR&gt;    Directory for all generated artifacts and intermediate files.
        --url &lt;URL&gt;                  URL at which to deploy indexer assets. [default:
                                     http://localhost:29987]
    -v, --verbose                    Enable verbose logging.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-remove"><a class="header" href="#forc-index-remove"><code>forc index remove</code></a></h1>
<p>Stop and remove a running indexer.</p>
<pre><code class="language-bash">forc index remove --url https://indexer.fuel.network
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index remove [OPTIONS]

OPTIONS:
        --auth &lt;AUTH&gt;            Authentication header value.
    -h, --help                   Print help information
    -m, --manifest &lt;MANIFEST&gt;    Path to the manifest of the indexer project being removed.
    -p, --path &lt;PATH&gt;            Path to the indexer project.
        --url &lt;URL&gt;              URL at which indexer is deployed. [default: http://localhost:29987]
    -v, --verbose                Enable verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-auth"><a class="header" href="#forc-index-auth"><code>forc index auth</code></a></h1>
<p>Authenticate against an indexer operator.</p>
<blockquote>
<p>IMPORTANT: There must be an indexer service running at <code>--url</code> in order for this to work.</p>
</blockquote>
<pre><code class="language-bash">forc index auth --account 0
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index auth [OPTIONS] --account &lt;ACCOUNT&gt;

OPTIONS:
        --account &lt;ACCOUNT&gt;    Index of account to use for signing.
    -h, --help                 Print help information
        --url &lt;URL&gt;            URL at which to deploy indexer assets. [default:
                               http://localhost:29987]
    -v, --verbose              Verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-revert"><a class="header" href="#forc-index-revert"><code>forc index revert</code></a></h1>
<p>Revert the running indexer to the previous version.</p>
<pre><code class="language-bash">forc index revert
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index revert [OPTIONS]

OPTIONS:
        --auth &lt;AUTH&gt;            Authentication header value.
    -h, --help                   Print help information
    -m, --manifest &lt;MANIFEST&gt;    Path to the manifest of the indexer project being reverted.
    -p, --path &lt;PATH&gt;            Path of indexer project.
        --url &lt;URL&gt;              URL at which indexer is deployed. [default: http://localhost:29987]
    -v, --verbose                Enable verbose output.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres"><a class="header" href="#forc-index-postgres">forc index postgres</a></h1>
<p><code>forc index postgres</code> is provided as a way to simplify the setup and management of an embedded Postgres database. After you have installed <code>fuelup</code>, you can run the <code>forc index postgres help</code> command in your terminal to view the available commands.</p>
<pre><code class="language-text">forc index postgres help
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    create    Create a new database
    drop      Drop a database
    help      Print this message or the help of the given subcommand(s)
    start     Start PostgreSQL with a database
    stop      Stop PostgreSQL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-create"><a class="header" href="#forc-index-postgres-create"><code>forc index postgres create</code></a></h1>
<p>Create a new database.</p>
<pre><code class="language-text">forc index postgres create example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres create [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
        --auth-method &lt;AUTH_METHOD&gt;
            Authentication method. [default: plain] [possible values: plain, md5, scram-sha-256]

    -c, --config &lt;CONFIG&gt;
            Fuel indexer configuration file.

        --database-dir &lt;DATABASE_DIR&gt;
            Where to store the PostgreSQL database.

    -h, --help
            Print help information

        --migration-dir &lt;MIGRATION_DIR&gt;
            The directory containing migration scripts.

    -p, --password &lt;PASSWORD&gt;
            Database password. [default: postgres]

    -p, --port &lt;PORT&gt;
            Port to use. [default: 5432]

        --persistent
            Do not clean up files and directories on database drop.

        --postgres-version &lt;POSTGRES_VERSION&gt;
            PostgreSQL version to use. [default: v14] [possible values: v15, v14, v13, v12, v11,
            v10, v9]

        --start
            Start the PostgreSQL instance after creation.

        --timeout &lt;TIMEOUT&gt;
            Duration to wait before terminating process execution for pg_ctl start/stop and initdb.

    -u, --user &lt;USER&gt;
            Database user. [default: postgres]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-start"><a class="header" href="#forc-index-postgres-start"><code>forc index postgres start</code></a></h1>
<p>Start PostgreSQL with a database.</p>
<pre><code class="language-text">forc index postgres start example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres start [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
    -c, --config &lt;CONFIG&gt;                Fuel indexer configuration file.
        --database-dir &lt;DATABASE_DIR&gt;    Where the PostgreSQL database is stored.
    -h, --help                           Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-stop"><a class="header" href="#forc-index-postgres-stop"><code>forc index postgres stop</code></a></h1>
<p>Stop PostgreSQL.</p>
<pre><code class="language-text">forc index postgres stop example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres stop [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
    -c, --config &lt;CONFIG&gt;                Fuel indexer configuration file.
        --database-dir &lt;DATABASE_DIR&gt;    Where the PostgreSQL database is stored.
    -h, --help                           Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forc-index-postgres-drop"><a class="header" href="#forc-index-postgres-drop"><code>forc index postgres drop</code></a></h1>
<p>Drop a database.</p>
<pre><code class="language-text">forc index postgres drop example_database
</code></pre>
<pre><code class="language-text">USAGE:
    forc-index postgres drop [OPTIONS] &lt;NAME&gt;

ARGS:
    &lt;NAME&gt;    Name of database.

OPTIONS:
    -c, --config &lt;CONFIG&gt;
            Fuel indexer configuration file.

        --database-dir &lt;DATABASE_DIR&gt;
            Where the PostgreSQL database is stored.

    -h, --help
            Print help information

        --remove-persisted
            Remove all database files that might have been persisted to disk.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>The Fuel indexer's authentication functionality offers users a range of options for verifying their identity. The system supports any arbitrary authentication scheme (in theory); however, in practice the service defaults to JWT authentication due to its stateless nature and popularity.</p>
<p>To authenticate using JWT, users ask an indexer operator for a nonce, sign that nonce with their wallet, then send both the nonce and signature to the indexer operator for verification. Once the signature is verified on the backend, a valid JWT is produced and returned to the user, thus authenticating the user.</p>
<p>It is important to note that authentication is disabled by default. However, if authentication is enabled, users will need to authenticate before performing operations that involve modifying the state of the service, such as uploading, or reverting indexers.</p>
<p>The new authentication functionality offers a flexible and secure way for users to authenticate and perform operations that affect the service's state.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>Below is a demonstration of basic JWT authentication using an indexer operator at &quot;https://indexer.fuel.network&quot;</p>
<pre><code class="language-bash">forc index auth --url https://indexer.fuel.network:29987
</code></pre>
<p>You will first be prompted for the password for your wallet:</p>
<pre><code class="language-text">Please enter your password:
</code></pre>
<p>After successfully entering your wallet password you should be presented with your new JWT token.</p>
<pre><code class="language-text">‚úÖ Successfully authenticated at https://indexer.fuel.network:29987/api/auth/signature.

Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiODNlNjhiOTFmNDhjYWM4M....
</code></pre>
<p>Use this token in your <code>Authorization</code> headers when making requests for operations such as uploading indexers, stopping indexers, and other operations that mutate state in this way.</p>
<p>Users can just pass this JWT token value to the <code>--auth</code> flag, if using <code>forc index</code> commands that support authentication (e.g., <code>forc index deploy --auth $MY_JWT_TOKEN</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-contributors"><a class="header" href="#for-contributors">For Contributors</a></h1>
<p>Thanks for your interest in contributing to the Fuel indexer! Below we've compiled a list of sections that you may find useful as you work on a potential contribution:</p>
<ul>
<li><a href="for-contributors/index.html#dependencies">Dependencies</a>
<ul>
<li><a href="for-contributors/index.html#fuelup"><code>fuelup</code></a></li>
<li><a href="for-contributors/index.html#docker"><code>docker</code></a></li>
<li><a href="for-contributors/index.html#database">Database</a>
<ul>
<li><a href="for-contributors/index.html#postgresql">PostgreSQL</a></li>
</ul>
</li>
<li><a href="for-contributors/index.html#sqlx">SQLx</a></li>
</ul>
</li>
<li><a href="for-contributors/index.html#building-from-source">Building from source</a></li>
<li><a href="for-contributors/index.html#run-migrations">Run migrations</a></li>
<li><a href="for-contributors/index.html#start-the-service">Start the service</a></li>
<li><a href="for-contributors/index.html#testing">Testing</a>
<ul>
<li><a href="for-contributors/index.html#default-tests">Default tests</a></li>
<li><a href="for-contributors/index.html#end-to-end-tests">End-to-end tests</a></li>
<li><a href="for-contributors/index.html#trybuild-tests"><code>trybuild</code> tests</a></li>
</ul>
</li>
</ul>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<h3 id="fuelup-1"><a class="header" href="#fuelup-1"><code>fuelup</code></a></h3>
<p>We use fuelup in order to get the binaries produced by services in the Fuel ecosystem. Fuelup will install binaries related to the Fuel node, the Fuel indexer, the Fuel orchestrator (forc), and other components. <code>fuelup</code> can be downloaded <a href="https://github.com/FuelLabs/fuelup">here</a>.</p>
<h3 id="docker"><a class="header" href="#docker"><code>docker</code></a></h3>
<p>We use Docker to produce reproducible environments for users that may be concerned with installing components with large sets of dependencies (e.g. Postgres). Docker can be downloaded <a href="https://docs.docker.com/engine/install/">here</a>.</p>
<h3 id="database-2"><a class="header" href="#database-2">Database</a></h3>
<p>At this time, the Fuel indexer requires the use of a database. We currently support a single database option: Postgres. PostgreSQL is a database solution with a complex feature set and requires a database server.</p>
<h4 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h4>
<blockquote>
<p>Note: The following explanation is for demonstration purposes only. A production setup should use secure users, permissions, and passwords.</p>
</blockquote>
<p>On macOS systems, you can install PostgreSQL through Homebrew. If it isn't present on your system, you can install it according to the <a href="https://brew.sh/">instructions</a>. Once installed, you can add PostgreSQL to your system by running <code>brew install postgresql</code>. You can then start the service through <code>brew services start postgresql</code>. You'll need to create a database for your indexed data, which you can do by running <code>createdb [DATABASE_NAME]</code>. You may also need to create the <code>postgres</code> role; you can do so by running <code>createuser -s postgres</code>.</p>
<p>For Linux-based systems, the installation process is similar. First, you should install PostgreSQL according to your distribution's instructions. Once installed, there should be a new <code>postgres</code> user account; you can switch to that account by running <code>sudo -i -u postgres</code>. After you have switched accounts, you may need to create a <code>postgres</code> database role by running <code>createuser --interactive</code>. You will be asked a few questions; the name of the role should be <code>postgres</code> and you should elect for the new role to be a superuser. Finally, you can create a database by running <code>createdb [DATABASE_NAME]</code>.</p>
<p>In either case, your PostgreSQL database should now be accessible at <code>postgres://postgres@localhost:5432/[DATABASE_NAME]</code>.</p>
<h3 id="sqlx"><a class="header" href="#sqlx">SQLx</a></h3>
<p>After setting up your database, you should install <code>sqlx-cli</code> in order to run migrations for your indexer service. You can do so by running <code>cargo install sqlx-cli --features postgres</code>. Once installed, you can run the migrations by running the following command after changing <code>DATABASE_URL</code> to match your setup.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<h3 id="clone-repository"><a class="header" href="#clone-repository">Clone repository</a></h3>
<pre><code class="language-bash">git clone git@github.com:FuelLabs/fuel-indexer.git &amp;&amp; cd fuel-indexer/
</code></pre>
<h3 id="run-migrations"><a class="header" href="#run-migrations">Run migrations</a></h3>
<h4 id="postgres-migrations"><a class="header" href="#postgres-migrations">Postgres migrations</a></h4>
<pre><code class="language-sh">cd packages/fuel-indexer-database/postgres
DATABASE_URL=postgres://postgres@localhost sqlx migrate run
</code></pre>
<h3 id="start-the-service"><a class="header" href="#start-the-service">Start the service</a></h3>
<pre><code class="language-bash">cargo run --bin fuel-indexer run
</code></pre>
<p>You can also start the service with a fresh local node for development purposes:</p>
<pre><code class="language-bash">cargo run --features fuel-core-lib --bin fuel-indexer run
</code></pre>
<blockquote>
<p>If no configuration file or other options are passed, the service will default to a <code>postgres://postgres@localhost</code> database connection.</p>
</blockquote>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Fuel indexer tests are currently broken out by a database feature flag. In order to run tests with a Postgres backend, use <code>--features postgres</code>.</p>
<p>Further, the indexer uses end-to-end (E2E) tests. In order to trigger these end-to-end tests, you'll want to use the <code>e2e</code> features flag: <code>--features e2e</code>.</p>
<blockquote>
<p>All end-to-end tests also require the use of a database feature. For example, to run the end-to-end tests with a Posgres backend, use <code>--features e2e,postgres</code>.</p>
</blockquote>
<h3 id="default-tests"><a class="header" href="#default-tests">Default tests</a></h3>
<pre><code class="language-bash">cargo test --locked --workspace --all-targets
</code></pre>
<h3 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-end tests</a></h3>
<pre><code class="language-bash">cargo test --locked --workspace --all-targets --features e2e,postgres
</code></pre>
<h3 id="trybuild-tests"><a class="header" href="#trybuild-tests"><code>trybuild</code> tests</a></h3>
<p>For tests related to the meta-programming used in the Fuel indexer, we use <code>trybuild</code>.</p>
<pre><code class="language-bash">RUSTFLAGS='-D warnings' cargo test -p fuel-indexer-macros --locked
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<h1 id="contributing-to-fuel-indexer"><a class="header" href="#contributing-to-fuel-indexer">Contributing to Fuel Indexer</a></h1>
<p>Thanks for your interest in contributing to Fuel Indexer! This document outlines some the conventions on building, running, and testing Fuel Indexer.</p>
<p>Fuel Indexer has many dependent repositories. If you need any help or mentoring getting started, understanding the codebase, or anything else, please ask on our <a href="https://discord.gg/xfpK4Pe">Discord</a>.</p>
<h2 id="code-standards"><a class="header" href="#code-standards">Code Standards</a></h2>
<p>We use an RFC process to maintain our code standards. They currently live in the RFC repo: <a href="https://github.com/FuelLabs/rfcs/tree/master/text/code-standards">https://github.com/FuelLabs/rfcs/tree/master/text/code-standards</a></p>
<h2 id="building-and-setting-up-a-development-workspace"><a class="header" href="#building-and-setting-up-a-development-workspace">Building and setting up a development workspace</a></h2>
<p>Fuel Core is mostly written in Rust, but includes components written in C++ (RocksDB).
We are currently using the latest Rust stable toolchain to build the project.
But for <code>rustfmt</code>, we use Rust nightly toolchain because it provides more code style features(you can check <a href="for-contributors/.rustfmt.toml"><code>rustfmt.toml</code></a>).</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>To build Fuel Core you'll need to at least have the following installed:</p>
<ul>
<li><code>git</code> - version control</li>
<li><a href="https://rustup.rs/"><code>rustup</code></a> - Rust installer and toolchain manager</li>
<li><a href="http://releases.llvm.org/download.html"><code>clang</code></a> - Used to build system libraries (required for rocksdb).</li>
<li><a href="https://grpc.io/docs/protoc-installation/"><code>postgresql/libpq</code></a> - Used for Postgres backend.</li>
</ul>
<p>See the <a href="for-contributors/README.html#system-requirements">README.md</a> for platform specific setup steps.</p>
<h3 id="getting-the-repository"><a class="header" href="#getting-the-repository">Getting the repository</a></h3>
<blockquote>
<p>Future instructions assume you are in this repository</p>
</blockquote>
<pre><code class="language-sh">git clone https://github.com/FuelLabs/fuel-indexer
cd fuel-indexer
</code></pre>
<h3 id="configuring-your-rust-toolchain"><a class="header" href="#configuring-your-rust-toolchain">Configuring your Rust toolchain</a></h3>
<p><code>rustup</code> is the official toolchain manager for Rust.</p>
<p>We use some additional components such as <code>clippy</code> and <code>rustfmt</code>, to install those:</p>
<pre><code class="language-sh">rustup component add clippy
rustup component add rustfmt
</code></pre>
<p>Fuel Indexer also uses a few other tools installed via <code>cargo</code></p>
<pre><code class="language-sh">cargo install sqlx-cli
cargo install wasm-snip
</code></pre>
<h3 id="building-and-testing"><a class="header" href="#building-and-testing">Building and testing</a></h3>
<p>Fuel Indexer's two primary crates are <code>fuel-indexer</code> and <code>fuel-indexer-api-server</code>.</p>
<p>You can build Fuel Indexer:</p>
<pre><code class="language-sh">cargo build -p fuel-indexer -p fuel-indexer-api-server
</code></pre>
<p>This command will run <code>cargo build</code> and also dump the latest schema into <code>/assets/</code> folder.</p>
<p>Linting is done using rustfmt and clippy, which are each separate commands:</p>
<pre><code class="language-sh">cargo fmt --all --check
</code></pre>
<pre><code class="language-sh">cargo clippy --all-features --all-targets -- -D warnings
</code></pre>
<p>The test suite follows the Rust cargo standards. The GraphQL service will be instantiated by
Tower and will emulate a server/client structure.</p>
<p>Testing is simply done using Cargo:</p>
<pre><code class="language-sh">RUSTFLAGS='-D warnings' SQLX_OFFLINE=1 cargo test --locked --all-targets --all-features
</code></pre>
<h4 id="build-options"><a class="header" href="#build-options">Build Options</a></h4>
<p>For optimal performance, we recommend using native builds. The generated binary will be optimized for your CPU and may contain specific instructions supported only in your hardware.</p>
<p>To build, run:</p>
<pre><code class="language-sh">cargo build --release --bin fuel-indexer
</code></pre>
<p>The generated binary will be located in <code>./target/release/fuel-indexer</code></p>
<h3 id="build-issues"><a class="header" href="#build-issues">Build issues</a></h3>
<ul>
<li>Due to dependencies on external components such as RocksDb, build times can be large without caching.
We currently use <a href="https://github.com/mozilla/sccache">sccache</a></li>
</ul>
<pre><code class="language-sh">cargo build -p fuel-indexer --no-default-features
</code></pre>
<h2 id="contribution-flow"><a class="header" href="#contribution-flow">Contribution flow</a></h2>
<p>This is a rough outline of what a contributor's workflow looks like:</p>
<ul>
<li>Make sure what you want to contribute is already tracked as an issue.
We may discuss the problem and solution in the issue.
‚ö†Ô∏è <strong>DO NOT submit PRs that do not have an associated issue</strong> ‚ö†Ô∏è</li>
<li>Create a Git branch from where you want to base your work.
<ul>
<li>Most work is usually branched off of <code>master</code></li>
<li>Give your branch a name related to the work you're doing</li>
</ul>
</li>
<li>Write code, add test cases, and commit your work.</li>
<li>Run tests and make sure all tests pass.</li>
<li>Your commit message should be formatted as <code>[commit type]: [short commit blurb]</code>
<ul>
<li>Examples:
<ul>
<li>If you fixed a bug, your message is <code>fix: database locking issue</code></li>
<li>If you added new functionality, your message would be <code>enhancement: i add something super cool</code></li>
<li>If you just did a chore your message is: <code>chore: i did somthing not fun</code></li>
</ul>
</li>
<li>Keeping commit messages short and consistent helps users parse release
notes</li>
</ul>
</li>
<li>Push up your branch to Github then (on the right hand side of the Github UI):
<ul>
<li>Assign yourself as the owner of the PR</li>
<li>Add any and all necessary labels to your PR</li>
<li>Link the issue your PR solves, to your PR</li>
</ul>
</li>
<li>If you are part of the FuelLabs Github org, please open a PR from the repository itself.</li>
<li>Otherwise, push your changes to a branch in your fork of the repository and submit a pull request.
<ul>
<li>Make sure mention the issue, which is created at step 1, in the commit message.</li>
</ul>
</li>
<li>Your PR will be reviewed and some changes may be requested.
<ul>
<li>Once you've made changes, your PR must be re-reviewed and approved.</li>
<li>If the PR becomes out of date, you can use GitHub's 'update branch' button.</li>
<li>If there are conflicts, you can merge and resolve them locally. Then push to your PR branch.
<ul>
<li>Any changes to the branch will require a re-review.</li>
</ul>
</li>
</ul>
</li>
<li>Our CI (Github Actions) automatically tests all authorized pull requests.</li>
<li>Use Github to merge the PR once approved.</li>
</ul>
<h3 id="commit-categories"><a class="header" href="#commit-categories">Commit categories</a></h3>
<ul>
<li><code>bug</code>: If fixing broken functionality</li>
<li><code>enhancement</code>: If adding new functionality</li>
<li><code>chore</code>: If finishing valuable work (that's no fun!)</li>
<li><code>testing</code>: If only updating/writing tests</li>
<li><code>docs</code>: If just updating docs</li>
<li><code>feat</code>: If adding a non-trivial new feature</li>
<li>There will be categories not covered in this doc - use your best judgement!</li>
</ul>
<p>Thanks for your contributions!</p>
<h2 id="finding-something-to-work-on"><a class="header" href="#finding-something-to-work-on">Finding something to work on</a></h2>
<p>For beginners, we have prepared many suitable tasks for you. Checkout our <a href="https://github.com/FuelLabs/fuel-indexer/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Good First Issues</a> for a list.</p>
<p>If you are planning something that relates to multiple components or changes current behaviors, make sure to open an issue to discuss with us before continuing.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable MD041 -->
<h1 id="release-schedule"><a class="header" href="#release-schedule">Release Schedule</a></h1>
<p><a href="https://semver.org/">https://semver.org/</a></p>
<h2 id="major-releases"><a class="header" href="#major-releases">Major releases</a></h2>
<ul>
<li>E.g., <code>v2.0.0</code> -&gt; <code>v3.0.0</code></li>
<li>Major releases of large features and breaking changes</li>
<li>Cadence: TBD - as needed</li>
</ul>
<h2 id="minor-releases"><a class="header" href="#minor-releases">Minor releases</a></h2>
<ul>
<li>E.g., <code>v0.3.0</code> -&gt; <code>v0.4.0</code></li>
<li>General releases of new functionality, fixes, and some breaking changes</li>
<li>Cadence: Every other week, Tuesday morning 11am EST</li>
</ul>
<h2 id="patch-releases"><a class="header" href="#patch-releases">Patch releases</a></h2>
<ul>
<li>E.g., <code>v0.1.3</code> -&gt; <code>v0.1.4</code></li>
<li>Releases for bug fixes and time sensitive improvements</li>
<li>Cadence: Ad-hoc as needed throughout the week</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>Here is a list of terms and their definitions in order to help users properly understand certain concepts about the Fuel indexer.</p>
<ul>
<li><code>asset</code>: a component that is used to create and operate an indexer</li>
<li><code>executor</code>: an async task run by an indexer</li>
<li><code>index</code>/<code>indices</code>: data produced by an indexer</li>
<li><code>indexer service</code>: a service that runs one or more indexers</li>
<li><code>indexer</code>: an abstraction that takes data from Fuel virtual machine and produces indices</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
